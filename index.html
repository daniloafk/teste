<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <meta name="description" content="Mapa interativo para gerenciamento de entregas e rotas">
    <title>Mapa Interativo</title>

    <!-- PWA Web App Manifest (inline) -->
    <script  nonce="5ab9d124b17845e5baff0ba357e" src="//local.adguard.org?ts=1768877512215&amp;type=content-script&amp;dmn=pfst.cf2.poecdn.net&amp;url=https%3A%2F%2Fpfst.cf2.poecdn.net%2Fbase%2Ftext%2F4b28e52924b696dd33739f55507b6bffb8109aad50d5cb7cf4e94484c97bcc1e%3Fpmaid%3D554643253&amp;app=firefox.exe&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1"></script><script  nonce="5ab9d124b17845e5baff0ba357e" src="//local.adguard.org?ts=1768877512215&amp;name=AdGuard%20Extra&amp;name=AdGuard%20Popup%20Blocker&amp;type=user-script"></script><link rel="manifest" href="data:application/json,%7B%22name%22%3A%22Mapa%20de%20Entregas%22%2C%22short_name%22%3A%22Entregas%22%2C%22description%22%3A%22Gerenciamento%20de%20rotas%20e%20entregas%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%230f172a%22%2C%22theme_color%22%3A%22%230ea5e9%22%2C%22orientation%22%3A%22portrait-primary%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%2520viewBox%3D%270%25200%2520192%2520192%27%253E%253Crect%2520fill%3D%27%25230ea5e9%27%2520width%3D%27192%27%2520height%3D%27192%27%2520rx%3D%2732%27%2F%253E%253Cpath%2520fill%3D%27white%27%2520d%3D%27M96%252025c-25%25200-45%252020-45%252045c0%252035%252045%252085%252045%252085s45-50%252045-85c0-25-20-45-45-45zm0%252060c-8%25200-15-7-15-15s7-15%252015-15s15%25207%252015%252015s-7%252015-15%252015z%27%2F%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%2C%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%2520viewBox%3D%270%25200%2520512%2520512%27%253E%253Crect%2520fill%3D%27%25230ea5e9%27%2520width%3D%27512%27%2520height%3D%27512%27%2520rx%3D%2764%27%2F%253E%253Cpath%2520fill%3D%27white%27%2520d%3D%27M256%252070c-65%25200-120%252055-120%2520120c0%252090%2520120%2520220%2520120%2520220s120-130%2520120-220c0-65-55-120-120-120zm0%2520160c-22%25200-40-18-40-40s18-40%252040-40s40%252018%252040%252040s-18%252040-40%252040z%27%2F%253E%253C%2Fsvg%253E%22%2C%22sizes%22%3A%22512x512%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">

    <!-- Apple Touch Icon (SVG fallback) -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect fill='%230ea5e9' width='180' height='180' rx='40'/%3E%3Cpath fill='white' d='M90 30c-30 0-55 25-55 55c0 40 55 90 55 90s55-50 55-90c0-30-25-55-55-55zm0 75c-11 0-20-9-20-20s9-20 20-20s20 9 20 20s-9 20-20 20z'/%3E%3C/svg%3E">

    <!-- CSS crítico inline para loader imediato -->
    <style id="critical-css">
        .app-loader{position:fixed;inset:0;background:linear-gradient(135deg,#0f172a 0%,#1e293b 50%,#0f172a 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:99999;transition:opacity .5s,visibility .5s}
        .app-loader.hidden{opacity:0;visibility:hidden;pointer-events:none}
        .loader-content{text-align:center;animation:fadeInUp .6s ease}
        .loader-icon{width:80px;height:80px;margin:0 auto 24px;position:relative}
        .loader-ring{position:absolute;inset:0;border:4px solid rgba(14,165,233,.2);border-top-color:#0ea5e9;border-radius:50%;animation:spin 1s linear infinite}
        .loader-ring:nth-child(2){inset:8px;border-top-color:#8b5cf6;animation-duration:.8s;animation-direction:reverse}
        .loader-pin{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:24px;height:24px}
        .loader-pin svg{width:100%;height:100%;color:#0ea5e9}
        .loader-title{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:20px;font-weight:700;color:#f1f5f9;margin-bottom:8px;letter-spacing:-.02em}
        .loader-status{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;font-size:14px;color:#94a3b8;margin-bottom:20px}
        .loader-progress{width:200px;height:4px;background:rgba(255,255,255,.1);border-radius:2px;overflow:hidden;margin:0 auto}
        .loader-bar{height:100%;background:linear-gradient(90deg,#0ea5e9,#8b5cf6);border-radius:2px;width:0;transition:width .3s ease}
        @keyframes spin{to{transform:rotate(360deg)}}
        @keyframes fadeInUp{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
        @media(prefers-color-scheme:light){.app-loader{background:linear-gradient(135deg,#f8fafc 0%,#e2e8f0 50%,#f8fafc 100%)}.loader-title{color:#1e293b}.loader-status{color:#64748b}.loader-progress{background:rgba(0,0,0,.1)}}
    </style>

    <!-- Mapbox CSS -->
    <link href="https://cdn.jsdelivr.net/npm/mapbox-gl@3.4.0/dist/mapbox-gl.min.css" rel="stylesheet">

    <!-- Fontes com preconnect e async loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet"></noscript>

    <style>
        :root {
            --sidebar-width: 400px;
            --primary: #0ea5e9;
            --primary-dark: #0284c7;
            --bg-light: #f8fafc;
            --bg-dark: #0f172a;
            --surface-light: #ffffff;
            --surface-dark: #1e293b;
            --text-light: #1e293b;
            --text-dark: #f1f5f9;
            --text-muted-light: #64748b;
            --text-muted-dark: #94a3b8;
            --border-light: #e2e8f0;
            --border-dark: #334155;
            --shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            width: 100vw;
            font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-light);
            color: var(--text-light);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body.dark {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none; /* Let Mapbox handle all touch gestures */
        }

        /* Location Error */
        .location-error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--surface-light);
            padding: 32px;
            border-radius: 16px;
            box-shadow: var(--shadow);
            text-align: center;
            max-width: 400px;
            z-index: 100;
            display: none;
        }

        body.dark .location-error {
            background: var(--surface-dark);
        }

        .location-error.show {
            display: block;
        }

        .location-error-icon {
            width: 64px;
            height: 64px;
            background: #fee2e2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
        }

        body.dark .location-error-icon {
            background: #7f1d1d;
        }

        .location-error-icon svg {
            width: 32px;
            height: 32px;
            color: #dc2626;
        }

        body.dark .location-error-icon svg {
            color: #f87171;
        }

        .location-error h3 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .location-error p {
            font-size: 14px;
            color: var(--text-muted-light);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        body.dark .location-error p {
            color: var(--text-muted-dark);
        }

        .retry-btn {
            padding: 12px 24px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .retry-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 140px;
            left: 16px;
            z-index: 1000;
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            max-width: 44px;
            max-height: 44px;
            border: none;
            border-radius: 50%;
            background: #22c55e;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .offline-indicator svg {
            width: 20px;
            height: 20px;
            color: white;
        }

        .offline-indicator.offline {
            background: #ef4444;
            animation: pulse-offline 2s infinite;
        }

        .offline-indicator.syncing {
            background: #f59e0b;
            animation: spin-sync 1s linear infinite;
        }

        @keyframes pulse-offline {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }

        @keyframes spin-sync {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .offline-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            min-width: 18px;
            height: 18px;
            padding: 0 5px;
            border-radius: 9px;
            background: #dc2626;
            color: white;
            font-size: 10px;
            font-weight: 700;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Menu Button */
        .menu-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1000;
            width: 48px;
            height: 48px;
            min-width: 48px;
            min-height: 48px;
            max-width: 48px;
            max-height: 48px;
            border: none;
            border-radius: 12px;
            background: var(--surface-light);
            box-shadow: var(--shadow);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
        }

        body.dark .menu-btn {
            background: var(--surface-dark);
        }

        .menu-btn:hover {
            transform: scale(1.05);
            background: var(--primary);
        }

        .menu-btn:hover .hamburger span {
            background: white;
        }

        /* Toggle Markers Button */
        .toggle-markers-btn {
            position: fixed;
            top: 76px;
            left: 16px;
            z-index: 1000;
            width: 48px;
            height: 48px;
            min-width: 48px;
            min-height: 48px;
            max-width: 48px;
            max-height: 48px;
            border: none;
            border-radius: 12px;
            background: var(--surface-light);
            box-shadow: var(--shadow);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
        }

        body.dark .toggle-markers-btn {
            background: var(--surface-dark);
        }

        .toggle-markers-btn:hover {
            transform: scale(1.05);
        }

        .toggle-markers-btn.active {
            background: var(--primary);
        }

        .toggle-markers-btn.active svg {
            color: white;
        }

        .toggle-markers-btn svg {
            width: 24px;
            height: 24px;
            color: var(--text-light);
            transition: color 0.3s ease;
        }

        body.dark .toggle-markers-btn svg {
            color: var(--text-dark);
        }

        .toggle-markers-btn:hover svg {
            color: var(--primary);
        }

        .toggle-markers-btn.active:hover svg {
            color: white;
        }

        .hamburger {
            width: 22px;
            height: 16px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hamburger span {
            display: block;
            width: 100%;
            height: 2.5px;
            background: var(--text-light);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }

        body.dark .hamburger span {
            background: var(--text-dark);
        }

        .menu-btn.active .hamburger span:nth-child(1) {
            transform: translateY(6.75px) rotate(45deg);
        }

        .menu-btn.active .hamburger span:nth-child(2) {
            opacity: 0;
            transform: scaleX(0);
        }

        .menu-btn.active .hamburger span:nth-child(3) {
            transform: translateY(-6.75px) rotate(-45deg);
        }

        /* Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            width: var(--sidebar-width);
            max-width: 90vw;
            height: 100%;
            background: var(--surface-light);
            z-index: 1001;
            transform: translateX(-100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow);
        }

        body.dark .sidebar {
            background: var(--surface-dark);
        }

        .sidebar.active {
            transform: translateX(0);
        }

        .sidebar-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        body.dark .sidebar-header {
            border-bottom-color: var(--border-dark);
        }

        .sidebar-header-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, var(--primary) 0%, #8b5cf6 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-header-icon svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .sidebar-header-text h2 {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .sidebar-header-text p {
            font-size: 13px;
            color: var(--text-muted-light);
            margin-top: 2px;
        }

        body.dark .sidebar-header-text p {
            color: var(--text-muted-dark);
        }

        /* Search Bar */
        .sidebar-search {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-light);
        }

        body.dark .sidebar-search {
            border-bottom-color: var(--border-dark);
        }

        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input-wrapper svg {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            color: var(--text-muted-light);
            pointer-events: none;
            z-index: 1;
            flex-shrink: 0;
        }

        body.dark .search-input-wrapper svg {
            color: var(--text-muted-dark);
        }

        .search-input {
            width: 100%;
            padding: 10px 14px 10px 42px;
            border: 2px solid var(--border-light);
            border-radius: 10px;
            font-family: inherit;
            font-size: 14px;
            background: var(--bg-light);
            color: var(--text-light);
            transition: all 0.2s ease;
        }

        body.dark .search-input {
            border-color: var(--border-dark);
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--surface-light);
        }

        body.dark .search-input:focus {
            background: var(--surface-dark);
        }

        .search-input::placeholder {
            color: var(--text-muted-light);
        }

        body.dark .search-input::placeholder {
            color: var(--text-muted-dark);
        }

        /* Close Button */
        .close-btn {
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            max-width: 36px;
            max-height: 36px;
            border: none;
            border-radius: 10px;
            background: var(--bg-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: auto;
            flex-shrink: 0;
        }

        body.dark .close-btn {
            background: var(--bg-dark);
        }

        .close-btn:hover {
            background: #fee2e2;
            transform: scale(1.1);
        }

        body.dark .close-btn:hover {
            background: #7f1d1d;
        }

        .close-btn svg {
            width: 20px;
            height: 20px;
            color: var(--text-muted-light);
            transition: color 0.2s ease;
        }

        body.dark .close-btn svg {
            color: var(--text-muted-dark);
        }

        .close-btn:hover svg {
            color: #dc2626;
        }

        body.dark .close-btn:hover svg {
            color: #f87171;
        }

        /* PWA Install Button */
        .pwa-install-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: linear-gradient(135deg, #0ea5e9 0%, #8b5cf6 100%);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(14, 165, 233, 0.4);
            z-index: 9999;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
        }

        .pwa-install-btn.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .pwa-install-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(14, 165, 233, 0.5);
        }

        .pwa-install-btn:active {
            transform: translateY(0);
        }

        .pwa-install-btn svg {
            width: 20px;
            height: 20px;
        }

        /* PWA Update Notification */
        .pwa-update-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 99999;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .pwa-update-notification.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .pwa-update-content {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--surface-light);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: 500;
        }

        body.dark .pwa-update-content {
            background: var(--surface-dark);
            color: var(--text-dark);
        }

        .pwa-update-content button {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pwa-update-content button:first-of-type {
            background: var(--primary);
            color: white;
        }

        .pwa-update-content button:first-of-type:hover {
            background: var(--primary-dark);
        }

        .pwa-update-content button:last-of-type {
            background: transparent;
            color: var(--text-muted-light);
        }

        body.dark .pwa-update-content button:last-of-type {
            color: var(--text-muted-dark);
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .pwa-install-btn {
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%) translateY(20px);
            }

            .pwa-install-btn.visible {
                transform: translateX(-50%) translateY(0);
            }

            .pwa-install-btn:hover {
                transform: translateX(-50%) translateY(-2px);
            }
        }

        /* Sidebar Content */
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 3px;
        }

        body.dark .sidebar-content::-webkit-scrollbar-thumb {
            background: var(--border-dark);
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
        }

        .empty-state-icon {
            width: 80px;
            height: 80px;
            background: var(--bg-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        body.dark .empty-state-icon {
            background: var(--bg-dark);
        }

        .empty-state-icon svg {
            width: 36px;
            height: 36px;
            color: var(--text-muted-light);
        }

        body.dark .empty-state-icon svg {
            color: var(--text-muted-dark);
        }

        .empty-state h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            color: var(--text-muted-light);
            line-height: 1.5;
        }

        body.dark .empty-state p {
            color: var(--text-muted-dark);
        }

        /* Cliente List - Virtual Scrolling */
        .cliente-list {
            position: relative;
            width: 100%;
        }

        .cliente-list-spacer {
            width: 100%;
            pointer-events: none;
        }

        .cliente-list-viewport {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
        }

        .cliente-item {
            background: var(--bg-light);
            border-radius: 12px;
            padding: 14px;
            transition: background 0.2s ease, border-color 0.2s ease;
            cursor: pointer;
            border: 2px solid transparent;
            position: absolute;
            left: 0;
            right: 0;
            box-sizing: border-box;
        }

        .cliente-item:last-child {
            margin-bottom: 0;
        }

        body.dark .cliente-item {
            background: var(--bg-dark);
        }

        .cliente-item:hover {
            border-color: var(--primary);
            background: var(--surface-light);
        }

        body.dark .cliente-item:hover {
            background: var(--surface-dark);
        }

        .cliente-item-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .cliente-item-id {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            flex-shrink: 0;
            margin-right: 8px;
        }

        .cliente-item-title {
            font-weight: 600;
            font-size: 14px;
            line-height: 1.4;
            flex: 1;
            padding-right: 8px;
        }

        .cliente-item-actions {
            display: flex;
            gap: 4px;
        }

        .cliente-item-btn {
            width: 28px;
            height: 28px;
            min-width: 28px;
            min-height: 28px;
            max-width: 28px;
            max-height: 28px;
            border: none;
            border-radius: 6px;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .cliente-item-btn:hover {
            background: var(--surface-light);
        }

        body.dark .cliente-item-btn:hover {
            background: var(--surface-dark);
        }

        .cliente-item-btn svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted-light);
        }

        body.dark .cliente-item-btn svg {
            color: var(--text-muted-dark);
        }

        .cliente-item-btn.delete:hover {
            background: #fee2e2;
        }

        body.dark .cliente-item-btn.delete:hover {
            background: #7f1d1d;
        }

        .cliente-item-btn.delete:hover svg {
            color: #dc2626;
        }

        body.dark .cliente-item-btn.delete:hover svg {
            color: #f87171;
        }

        .cliente-item-info {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .cliente-item-bairro {
            font-size: 11px;
            color: #8b5cf6;
            font-weight: 500;
            padding: 3px 8px;
            background: rgba(139, 92, 246, 0.1);
            border-radius: 6px;
        }

        body.dark .cliente-item-bairro {
            color: #a78bfa;
            background: rgba(139, 92, 246, 0.15);
        }

        .cliente-item-cep {
            font-size: 11px;
            color: #0ea5e9;
            font-weight: 500;
            padding: 3px 8px;
            background: rgba(14, 165, 233, 0.1);
            border-radius: 6px;
        }

        body.dark .cliente-item-cep {
            color: #38bdf8;
            background: rgba(14, 165, 233, 0.15);
        }

        .cliente-item-coords {
            font-size: 11px;
            color: var(--text-muted-light);
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        body.dark .cliente-item-coords {
            color: var(--text-muted-dark);
        }


        /* Loading */
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted-light);
        }

        body.dark .loading {
            color: var(--text-muted-dark);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-light);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        body.dark .loading-spinner {
            border-color: var(--border-dark);
            border-top-color: var(--primary);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Quick Success Toast */
        .quick-success {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            z-index: 10001;
            animation: quickSuccessAnim 1.2s ease forwards;
        }

        .quick-success-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(34, 197, 94, 0.5);
        }

        .quick-success-icon svg {
            width: 44px;
            height: 44px;
            color: white;
            stroke-width: 3;
        }

        @keyframes quickSuccessAnim {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            30% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            70% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        }


        /* Navigation Info Notification - bottom left during navigation */
        .navigation-info-notification {
            position: fixed;
            bottom: 100px;
            left: 12px;
            z-index: 10001;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px 14px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.4), 0 2px 8px rgba(0, 0, 0, 0.1);
            animation: navInfoSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            max-width: 280px;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .navigation-info-notification.fade-out {
            animation: navInfoSlideOut 0.4s ease forwards;
        }

        .nav-info-icon {
            width: 36px;
            height: 36px;
            min-width: 36px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .nav-info-icon svg {
            width: 20px;
            height: 20px;
            color: white;
        }

        .nav-info-content {
            flex: 1;
            min-width: 0;
        }

        .nav-info-title {
            font-size: 13px;
            font-weight: 700;
            color: white;
            margin-bottom: 2px;
        }

        .nav-info-order {
            font-size: 12px;
            font-weight: 700;
            color: #fef08a;
            margin-bottom: 2px;
        }

        .nav-info-address {
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.95);
            line-height: 1.3;
            word-break: break-word;
        }

        .nav-info-distance {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 3px;
        }

        .nav-info-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .nav-info-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Plus Jakarta Sans', sans-serif;
        }

        .nav-info-btn svg {
            width: 14px;
            height: 14px;
            flex-shrink: 0;
        }

        .nav-info-btn.delivered {
            background: #10b981;
            color: white;
        }

        .nav-info-btn.delivered:hover {
            background: #059669;
        }

        .nav-info-btn.delivered:active {
            background: #047857;
            transform: scale(0.95);
        }

        .nav-info-btn.not-delivered {
            background: #dc2626;
            color: white;
        }

        .nav-info-btn.not-delivered:hover {
            background: #b91c1c;
        }

        .nav-info-btn.not-delivered:active {
            background: #991b1b;
            transform: scale(0.95);
        }

        @keyframes navInfoSlideIn {
            0% { transform: translateX(-100px); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        @keyframes navInfoSlideOut {
            0% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-100px); opacity: 0; }
        }

        /* Dark mode for navigation info notification */
        body.dark .navigation-info-notification {
            box-shadow: 0 6px 24px rgba(59, 130, 246, 0.3), 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Mobile adjustments for navigation info notification */
        @media (max-width: 480px) {
            .navigation-info-notification {
                bottom: 80px;
                left: 8px;
                padding: 10px 12px;
                gap: 8px;
                max-width: 240px;
                border-radius: 10px;
            }

            .nav-info-icon {
                width: 32px;
                height: 32px;
                min-width: 32px;
            }

            .nav-info-icon svg {
                width: 18px;
                height: 18px;
            }

            .nav-info-title {
                font-size: 12px;
            }

            .nav-info-order {
                font-size: 11px;
            }

            .nav-info-address {
                font-size: 10px;
            }

            .nav-info-distance {
                font-size: 9px;
            }

            .nav-info-actions {
                gap: 4px;
                margin-top: 6px;
            }

            .nav-info-btn {
                padding: 5px 8px;
                font-size: 10px;
                gap: 3px;
            }

            .nav-info-btn svg {
                width: 12px;
                height: 12px;
            }
        }

        /* End Navigation Button */
        .end-nav-btn {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            min-width: 180px;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .end-nav-btn.active {
            display: flex;
        }

        .end-nav-btn:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 24px rgba(239, 68, 68, 0.5);
        }

        .end-nav-btn:active {
            transform: translateX(-50%) translateY(0);
        }

        .end-nav-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Cadastrar Button */
        .cadastrar-btn {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            min-width: 180px;
            padding: 14px 24px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary) 0%, #0284c7 100%);
            box-shadow: 0 4px 20px rgba(14, 165, 233, 0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cadastrar-btn:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 24px rgba(14, 165, 233, 0.5);
        }

        .cadastrar-btn:active {
            transform: translateX(-50%) translateY(0);
        }

        .cadastrar-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Spreadsheet Button - positioned below Mapbox controls (zoom, compass, geolocate ~180px) */
        .spreadsheet-btn {
            position: fixed;
            top: 200px;
            right: 10px;
            z-index: 1000;
            width: 48px;
            height: 48px;
            min-width: 48px;
            min-height: 48px;
            max-width: 48px;
            max-height: 48px;
            border: none;
            border-radius: 12px;
            background: var(--surface-light);
            box-shadow: var(--shadow);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
        }

        body.dark .spreadsheet-btn {
            background: var(--surface-dark);
        }

        .spreadsheet-btn:hover {
            transform: scale(1.05);
            background: #22c55e;
        }

        .spreadsheet-btn:hover svg {
            color: white;
        }

        .spreadsheet-btn svg {
            width: 24px;
            height: 24px;
            color: #22c55e;
            transition: color 0.3s ease;
        }

        body.dark .spreadsheet-btn svg {
            color: #4ade80;
        }

        /* Route Markers Button */
        .route-markers-btn {
            position: fixed;
            top: 260px;
            right: 10px;
            z-index: 1000;
            width: 48px;
            height: 48px;
            min-width: 48px;
            min-height: 48px;
            max-width: 48px;
            max-height: 48px;
            border: none;
            border-radius: 12px;
            background: var(--surface-light);
            box-shadow: var(--shadow);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
            overflow: hidden;
        }

        body.dark .route-markers-btn {
            background: var(--surface-dark);
        }

        .route-markers-btn:hover {
            transform: scale(1.05);
            background: #8b5cf6;
        }

        .route-markers-btn:hover svg {
            color: white;
        }

        .route-markers-btn.active {
            background: #8b5cf6;
        }

        .route-markers-btn.active svg {
            color: white;
        }

        .route-markers-btn svg {
            width: 24px;
            height: 24px;
            color: #8b5cf6;
            transition: color 0.3s ease;
            position: relative;
            z-index: 2;
        }

        body.dark .route-markers-btn svg {
            color: #a78bfa;
        }

        /* Barra de progresso estilo "copo enchendo" */
        .route-markers-btn .progress-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(180deg, #22d3ee 0%, #06b6d4 50%, #0891b2 100%);
            box-shadow: 0 -2px 10px rgba(6, 182, 212, 0.6), inset 0 1px 0 rgba(255,255,255,0.3);
            transition: height 0.15s ease-out;
            z-index: 1;
            border-radius: 0 0 12px 12px;
        }

        .route-markers-btn.loading .progress-fill {
            display: block;
        }

        .route-markers-btn.loading svg {
            color: white;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }

        body.dark .route-markers-btn.loading svg {
            color: white;
        }

        /* Efeito de brilho na superfície do "líquido" */
        .route-markers-btn .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Route Popup */
        .mapboxgl-popup {
            touch-action: none;
            pointer-events: auto;
        }

        .mapboxgl-popup-content {
            touch-action: pan-x pan-y;
            padding: 12px !important;
            width: 100%;
            box-sizing: border-box !important;
            overflow: hidden;
        }

        .mapboxgl-popup-close-button {
            touch-action: manipulation;
            width: 28px !important;
            height: 28px !important;
            min-width: 28px !important;
            min-height: 28px !important;
            max-width: 28px !important;
            max-height: 28px !important;
            font-size: 20px !important;
            line-height: 28px !important;
            text-align: center;
            padding: 0 !important;
            margin: 0 !important;
            top: -34px;
            left: 50%;
            right: auto !important;
            transform: translateX(-50%);
            background: rgba(239, 68, 68, 0.9) !important;
            border-radius: 50% !important;
            color: white !important;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            flex-shrink: 0 !important;
            flex-grow: 0 !important;
            aspect-ratio: 1 / 1 !important;
            box-sizing: border-box !important;
            border: none !important;
        }

        .mapboxgl-popup-close-button:hover {
            background: #dc2626;
            color: white;
        }

        /* Dark mode */
        body.dark .mapboxgl-popup-close-button {
            background: rgba(239, 68, 68, 0.9);
            color: white;
        }

        body.dark .mapboxgl-popup-close-button:hover {
            background: #dc2626;
            color: white;
        }

        /* Navigation User Marker - smooth animated */
        .nav-user-marker {
            width: 28px;
            height: 28px;
            position: relative;
            transition: transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .nav-user-dot {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 3px 12px rgba(59, 130, 246, 0.6);
            position: absolute;
            top: 0;
            left: 0;
        }

        .nav-user-arrow {
            display: none;
        }

        .nav-user-pulse {
            width: 28px;
            height: 28px;
            background: rgba(59, 130, 246, 0.4);
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: navPulse 2s ease-out infinite;
        }

        @keyframes navPulse {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(2.5); opacity: 0; }
        }

        .route-popup-content {
            font-size: 13px;
            width: 100%;
            min-width: 250px; /* Garante espaço mínimo para os 3 botões */
            box-sizing: border-box;
        }

        .route-popup-address {
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .route-popup-orders {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .route-popup-order {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .route-popup-actions {
            display: flex;
            flex-wrap: nowrap; /* Mantém botões em uma linha */
            gap: 6px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e2e8f0;
        }

        .route-popup-btn {
            flex: 1 1 0; /* Todos os botões com largura igual */
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            padding: 8px 6px;
            border: none;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            background: #10b981;
            color: white;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 0; /* Remove largura mínima para flex funcionar corretamente */
        }

        .route-popup-btn svg {
            width: 12px;
            height: 12px;
            flex-shrink: 0;
        }

        .route-popup-btn:hover {
            background: #059669;
            color: white;
        }

        .route-popup-btn:active {
            background: #047857;
        }

        .route-popup-btn.active {
            background: #047857;
            color: white;
            font-weight: 700;
        }

        .route-popup-btn.not-delivered {
            background: #dc2626;
            color: white;
        }

        .route-popup-btn.not-delivered:hover {
            background: #b91c1c;
            color: white;
        }

        .route-popup-btn.not-delivered:active {
            background: #991b1b;
        }

        .route-popup-btn.not-delivered.active {
            background: #991b1b;
            color: white;
            font-weight: 700;
        }

        .route-popup-btn:disabled {
            opacity: 0.6;
            cursor: wait;
            pointer-events: none;
        }

        .route-popup-btn.navigate {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
            color: white;
            font-weight: 700;
        }

        .route-popup-btn.navigate:hover {
            background: linear-gradient(135deg, #0369a1 0%, #01579b 100%);
        }

        /* Mobile-specific adjustments for popup */
        @media (max-width: 480px) {
            .mapboxgl-popup-content {
                padding: 10px !important;
                width: 100% !important;
            }

            .route-popup-content {
                min-width: 0 !important;
                width: 100% !important;
                max-width: 100% !important;
            }

            .route-popup-address {
                width: 100%;
                box-sizing: border-box;
            }

            .route-popup-actions {
                gap: 4px;
                width: 100%;
                box-sizing: border-box;
            }

            .route-popup-btn {
                flex: 1 1 0;
                min-width: 0;
                padding: 8px 4px;
                font-size: 9px;
                box-sizing: border-box;
            }

            .route-popup-btn svg {
                width: 11px;
                height: 11px;
            }

            .route-popup-btn .btn-text {
                display: inline;
            }

            .route-popup-orders {
                width: 100%;
                box-sizing: border-box;
            }
        }

        /* Upload Modal */
        .upload-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .upload-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .upload-modal-content {
            background: var(--surface-light);
            border-radius: 20px;
            box-shadow: var(--shadow);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .upload-modal.active .upload-modal-content {
            transform: scale(1);
        }

        body.dark .upload-modal-content {
            background: var(--surface-dark);
        }

        .upload-modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        body.dark .upload-modal-header {
            border-bottom-color: var(--border-dark);
        }

        .upload-modal-header h3 {
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .upload-modal-header h3 svg {
            width: 24px;
            height: 24px;
            color: #22c55e;
        }

        .upload-modal-close {
            width: 32px;
            height: 32px;
            min-width: 32px;
            min-height: 32px;
            max-width: 32px;
            max-height: 32px;
            border: none;
            border-radius: 8px;
            background: var(--bg-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        body.dark .upload-modal-close {
            background: var(--bg-dark);
        }

        .upload-modal-close:hover {
            background: #fee2e2;
        }

        body.dark .upload-modal-close:hover {
            background: #7f1d1d;
        }

        .upload-modal-close svg {
            width: 18px;
            height: 18px;
            color: var(--text-muted-light);
        }

        .upload-modal-close:hover svg {
            color: #dc2626;
        }

        .upload-modal-body {
            padding: 24px;
            overflow-y: auto;
        }

        .upload-dropzone {
            border: 2px dashed var(--border-light);
            border-radius: 16px;
            padding: 40px 24px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        body.dark .upload-dropzone {
            border-color: var(--border-dark);
        }

        .upload-dropzone:hover,
        .upload-dropzone.dragover {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.05);
        }

        .upload-dropzone-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
        }

        .upload-dropzone-icon svg {
            width: 32px;
            height: 32px;
            color: white;
        }

        .upload-dropzone h4 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .upload-dropzone p {
            font-size: 14px;
            color: var(--text-muted-light);
        }

        body.dark .upload-dropzone p {
            color: var(--text-muted-dark);
        }

        .upload-dropzone input[type="file"] {
            display: none;
        }

        /* Upload Preview */
        .upload-preview {
            display: none;
        }

        .upload-preview.active {
            display: block;
        }

        .upload-file-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-light);
            border-radius: 12px;
            margin-bottom: 16px;
        }

        body.dark .upload-file-info {
            background: var(--bg-dark);
        }

        .upload-file-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .upload-file-icon svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .upload-file-details {
            flex: 1;
            min-width: 0;
        }

        .upload-file-name {
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .upload-file-meta {
            font-size: 12px;
            color: var(--text-muted-light);
            margin-top: 2px;
        }

        body.dark .upload-file-meta {
            color: var(--text-muted-dark);
        }

        .upload-preview-table {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-light);
            border-radius: 10px;
            margin-bottom: 16px;
        }

        body.dark .upload-preview-table {
            border-color: var(--border-dark);
        }

        .upload-preview-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .upload-preview-table th,
        .upload-preview-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
            white-space: nowrap;
        }

        body.dark .upload-preview-table th,
        body.dark .upload-preview-table td {
            border-bottom-color: var(--border-dark);
        }

        .upload-preview-table th {
            background: var(--bg-light);
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        body.dark .upload-preview-table th {
            background: var(--bg-dark);
        }

        .upload-warning {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 16px;
            background: #fef3c7;
            border-radius: 10px;
            margin-bottom: 16px;
        }

        body.dark .upload-warning {
            background: #78350f;
        }

        .upload-warning svg {
            width: 20px;
            height: 20px;
            color: #d97706;
            flex-shrink: 0;
            margin-top: 2px;
        }

        body.dark .upload-warning svg {
            color: #fbbf24;
        }

        .upload-warning p {
            font-size: 13px;
            color: #92400e;
            line-height: 1.5;
        }

        body.dark .upload-warning p {
            color: #fde68a;
        }

        .upload-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        body.dark .upload-modal-footer {
            border-top-color: var(--border-dark);
        }

        .upload-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-btn-secondary {
            background: var(--bg-light);
            color: var(--text-light);
            border: 2px solid var(--border-light);
        }

        body.dark .upload-btn-secondary {
            background: var(--bg-dark);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }

        .upload-btn-secondary:hover {
            background: var(--border-light);
        }

        body.dark .upload-btn-secondary:hover {
            background: var(--border-dark);
        }

        .upload-btn-primary {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
        }

        .upload-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }

        .upload-btn-primary:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }


        .upload-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Upload Progress */
        .upload-progress {
            display: none;
            text-align: center;
            padding: 24px;
        }

        .upload-progress.active {
            display: block;
        }

        .upload-progress-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-light);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        body.dark .upload-progress-spinner {
            border-color: var(--border-dark);
            border-top-color: #22c55e;
        }

        .upload-progress p {
            font-size: 14px;
            color: var(--text-muted-light);
        }

        body.dark .upload-progress p {
            color: var(--text-muted-dark);
        }

        /* Upload Success */
        .upload-success {
            display: none;
            text-align: center;
            padding: 24px;
        }

        .upload-success.active {
            display: block;
        }

        .upload-success-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
        }

        .upload-success-icon svg {
            width: 32px;
            height: 32px;
            color: white;
        }

        .upload-success h4 {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .upload-success p {
            font-size: 14px;
            color: var(--text-muted-light);
        }

        body.dark .upload-success p {
            color: var(--text-muted-dark);
        }

        /* Fixed Stats Panel - Bottom Right (Compact Vertical) */
        .fixed-stats-panel {
            position: fixed;
            bottom: 20px;
            right: 12px;
            display: none;
            flex-direction: column;
            gap: 4px;
            z-index: 1000;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            animation: slideInStats 0.3s ease-out;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
        }

        .fixed-stats-panel.visible {
            display: flex;
        }

        @keyframes slideInStats {
            from {
                opacity: 0;
                transform: translateX(10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .fixed-stat-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        }

        body.dark .fixed-stat-item {
            background: rgba(30, 30, 40, 0.9);
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        }

        .fixed-stat-number {
            font-size: 14px;
            font-weight: 700;
            min-width: 24px;
            text-align: right;
            line-height: 1;
        }

        .fixed-stat-item.total .fixed-stat-number {
            color: #8b5cf6;
        }

        .fixed-stat-item.registered .fixed-stat-number {
            color: #22c55e;
        }

        .fixed-stat-item.pending .fixed-stat-number {
            color: #f59e0b;
        }

        .fixed-stat-item.delivered .fixed-stat-number {
            color: #6b7280;
        }

        .fixed-stat-label {
            font-size: 9px;
            font-weight: 500;
            color: var(--text-muted-light);
            white-space: nowrap;
            line-height: 1;
        }

        body.dark .fixed-stat-label {
            color: var(--text-muted-dark);
        }

        .fixed-stat-item.unregistered .fixed-stat-number {
            color: #ef4444;
        }

        /* Pulse animation for updates */
        .fixed-stat-item.updating .fixed-stat-number {
            animation: statPulse 0.3s ease;
        }

        @keyframes statPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .fixed-stats-panel {
                bottom: 70px;
                right: 8px;
            }

            .fixed-stat-item {
                padding: 3px 6px;
                gap: 4px;
            }

            .fixed-stat-number {
                font-size: 12px;
                min-width: 20px;
            }

            .fixed-stat-label {
                font-size: 8px;
            }
        }

        /* QR Scanner Modal */
        .qr-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .qr-modal.active {
            opacity: 1;
            visibility: visible;
        }

        .qr-modal-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
        }

        .qr-modal-title {
            color: white;
            font-size: 18px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .qr-modal-title svg {
            width: 24px;
            height: 24px;
        }

        .qr-modal-close {
            width: 40px;
            height: 40px;
            min-width: 40px;
            min-height: 40px;
            max-width: 40px;
            max-height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .qr-modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .qr-modal-close svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        .qr-scanner-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
        }

        .qr-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 16px;
        }

        .qr-canvas {
            display: none;
        }

        .qr-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .qr-scan-area {
            width: 250px;
            height: 250px;
            position: relative;
        }

        .qr-scan-area::before,
        .qr-scan-area::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border-color: var(--primary);
            border-style: solid;
        }

        .qr-scan-area::before {
            top: 0;
            left: 0;
            border-width: 4px 0 0 4px;
            border-radius: 8px 0 0 0;
        }

        .qr-scan-area::after {
            top: 0;
            right: 0;
            border-width: 4px 4px 0 0;
            border-radius: 0 8px 0 0;
        }

        .qr-scan-area-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
        }

        .qr-scan-area-bottom::before,
        .qr-scan-area-bottom::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border-color: var(--primary);
            border-style: solid;
        }

        .qr-scan-area-bottom::before {
            bottom: 0;
            left: 0;
            border-width: 0 0 4px 4px;
            border-radius: 0 0 0 8px;
        }

        .qr-scan-area-bottom::after {
            bottom: 0;
            right: 0;
            border-width: 0 4px 4px 0;
            border-radius: 0 0 8px 0;
        }

        .qr-scan-line {
            position: absolute;
            left: 10px;
            right: 10px;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            border-radius: 2px;
            animation: scanLine 2s ease-in-out infinite;
        }

        @keyframes scanLine {
            0%, 100% { top: 10px; }
            50% { top: calc(100% - 13px); }
        }

        /* Torch flash overlay - covers camera during exposure adjustment */
        .qr-torch-flash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            transition: opacity 0.6s ease-out;
        }

        .qr-torch-flash.active {
            opacity: 1;
            transition: none; /* Instant on */
        }

        .qr-status {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 24px;
            text-align: center;
        }

        .qr-status-text {
            color: white;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .qr-status-hint {
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
        }

        .qr-loading {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .qr-loading.active {
            display: flex;
        }

        .qr-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 16px;
        }

        .qr-loading-text {
            color: white;
            font-size: 14px;
        }

        /* QR Address List - Virtualized */
        .qr-address-list-container {
            width: 100%;
            max-width: 400px;
            margin-top: 16px;
            height: 180px;
            border-radius: 12px;
            overflow: hidden;
        }

        .qr-address-list {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            background: #1a1a1a;
            border-radius: 12px;
        }

        .qr-address-viewport {
            position: relative;
        }

        .qr-address-item {
            position: absolute;
            left: 0;
            right: 0;
            height: 52px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 14px;
            box-sizing: border-box;
            border-bottom: 1px solid #2a2a2a;
            transition: background 0.2s ease;
        }

        .qr-address-item.selected {
            background: rgba(59, 130, 246, 0.25);
            border-left: 3px solid #3b82f6;
            padding-left: 11px;
        }

        .qr-address-id {
            min-width: 45px;
            padding: 4px 6px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            color: #a78bfa;
            text-align: center;
            flex-shrink: 0;
        }

        .qr-address-order {
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }

        .qr-address-text {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .qr-address-text p {
            color: white;
            font-size: 12px;
            line-height: 1.3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: 0;
        }

        .qr-address-text span {
            color: #808080;
            font-size: 10px;
        }

        .qr-address-list-empty {
            padding: 20px;
            text-align: center;
            color: #808080;
            font-size: 12px;
        }

        /* Center Pin - Positioned relative to map container */
        .center-pin {
            position: absolute;
            z-index: 1000;
            pointer-events: none;
            display: none;
            /* Será posicionado via JavaScript no centro exato do mapa */
            width: 0;
            height: 0;
        }

        .center-pin.active {
            display: block;
        }

        .center-pin-marker {
            position: absolute;
            width: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            /*
             * Cálculo preciso do posicionamento:
             * - Agora apenas a bola vermelha (sem agulha)
             * - O centro da bola indica exatamente as coordenadas
             * - transform: translate(-50%, -50%) centraliza a bola no ponto exato
             */
            top: 0;
            left: 0;
            transform: translate(-50%, -50%);
        }

        .center-pin-head {
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 6px rgba(239, 68, 68, 0.7);
            flex-shrink: 0;
            cursor: grab;
        }

        /* Agulha removida - apenas bola vermelha */
        .center-pin-needle {
            display: none;
        }

        .center-pin-shadow {
            display: none;
        }

        .center-pin-precision {
            display: none;
        }

        /* Display de coordenadas - oculto conforme solicitado */
        .center-pin-coords {
            display: none;
        }

        /* Crosshair removido - apenas bola vermelha */
        .center-pin-crosshair {
            display: none;
        }

        /* Estado desabilitado durante animação */
        .adjust-mode-btn-confirm.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* View Marker (for "Ver no mapa" button) */
        .view-marker {
            position: relative;
            width: 30px;
            height: 40px;
        }

        .view-marker-pin {
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 3px solid white;
            border-radius: 50% 50% 50% 0;
            transform: rotate(-45deg);
            box-shadow: 0 3px 10px rgba(59, 130, 246, 0.5);
            position: absolute;
            top: 0;
            left: 0;
        }

        .view-marker-pulse {
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 14px;
            height: 14px;
            background: rgba(59, 130, 246, 0.4);
            border-radius: 50%;
            animation: markerPulse 1.5s ease-out infinite;
        }

        @keyframes markerPulse {
            0% { transform: translateX(-50%) scale(1); opacity: 1; }
            100% { transform: translateX(-50%) scale(2.5); opacity: 0; }
        }

        /* View Marker Popup Close Button - positioned outside popup */
        .mapboxgl-popup-content:has(.view-popup-close-btn) {
            position: relative;
            overflow: visible;
        }

        .view-popup-close-btn {
            position: absolute;
            top: -34px;
            left: 50%;
            transform: translateX(-50%);
            width: 26px;
            height: 26px;
            min-width: 26px;
            min-height: 26px;
            max-width: 26px;
            max-height: 26px;
            aspect-ratio: 1 / 1;
            flex-shrink: 0;
            border: none;
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.5);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 10;
            padding: 0;
            box-sizing: border-box;
        }

        .view-popup-close-btn:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 3px 12px rgba(239, 68, 68, 0.6);
        }

        .view-popup-close-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        .view-popup-close-btn svg {
            width: 14px;
            height: 14px;
            color: white;
        }

        /* Adjust Mode UI */
        .adjust-mode-bar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .adjust-mode-bar.active {
            display: flex;
        }

        .adjust-mode-info {
            background: var(--surface-light);
            padding: 12px 20px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            text-align: center;
            max-width: 300px;
        }

        body.dark .adjust-mode-info {
            background: var(--surface-dark);
        }

        .adjust-mode-info p {
            font-size: 13px;
            color: var(--text-muted-light);
            margin-bottom: 4px;
        }

        body.dark .adjust-mode-info p {
            color: var(--text-muted-dark);
        }

        .adjust-mode-info strong {
            font-size: 14px;
            color: var(--text-light);
        }

        body.dark .adjust-mode-info strong {
            color: var(--text-dark);
        }

        .adjust-mode-actions {
            display: flex;
            gap: 12px;
        }

        .adjust-mode-btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .adjust-mode-btn-cancel {
            background: var(--surface-light);
            color: var(--text-light);
        }

        body.dark .adjust-mode-btn-cancel {
            background: var(--surface-dark);
            color: var(--text-dark);
        }

        .adjust-mode-btn-confirm {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
        }

        .adjust-mode-btn-confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
        }

        .adjust-mode-btn svg {
            width: 18px;
            height: 18px;
        }

        /* Address Already Registered Modal */
        .address-exists-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            z-index: 2000;
            background: var(--surface-light);
            border-radius: 20px;
            box-shadow: var(--shadow);
            padding: 32px;
            max-width: 400px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body.dark .address-exists-modal {
            background: var(--surface-dark);
        }

        .address-exists-modal.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .address-exists-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
        }

        .address-exists-icon svg {
            width: 32px;
            height: 32px;
            color: white;
        }

        .address-exists-modal h3 {
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 12px;
        }

        .address-exists-modal p {
            font-size: 14px;
            color: var(--text-muted-light);
            text-align: center;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        body.dark .address-exists-modal p {
            color: var(--text-muted-dark);
        }

        .address-exists-address {
            background: var(--bg-light);
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            margin: 16px 0;
            text-align: center;
            color: var(--primary);
        }

        body.dark .address-exists-address {
            background: var(--bg-dark);
        }

        .address-exists-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .address-exists-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .address-exists-btn-cancel {
            background: var(--bg-light);
            color: var(--text-light);
        }

        body.dark .address-exists-btn-cancel {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        .address-exists-btn-cancel:hover {
            background: var(--border-light);
        }

        body.dark .address-exists-btn-cancel:hover {
            background: var(--border-dark);
        }

        .address-exists-btn-adjust {
            background: linear-gradient(135deg, var(--primary) 0%, #0284c7 100%);
            color: white;
        }

        .address-exists-btn-adjust:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(14, 165, 233, 0.4);
        }

        /* Old Position Marker */
        .old-position-marker {
            width: 40px;
            height: 40px;
            display: none;
        }

        .old-position-marker.active {
            display: block;
        }

        .old-position-marker-inner {
            width: 100%;
            height: 100%;
            background: #ef4444;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .old-position-marker-inner::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: #ef4444;
            border-radius: 50%;
            opacity: 0.3;
            animation: oldMarkerPulse 2s ease-out infinite;
        }

        .old-position-marker svg {
            width: 20px;
            height: 20px;
            color: white;
            position: relative;
            z-index: 1;
        }

        @keyframes oldMarkerPulse {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(2.5); opacity: 0; }
        }

        .old-position-marker-label {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: #ef4444;
            color: white;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .old-position-marker-label::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-top: 4px solid #ef4444;
        }

        /* Responsive */
        /* ========================================
           RESPONSIVE DESIGN
           ======================================== */

        /* Mobile Devices (Portrait) - até 480px */
        @media (max-width: 480px) {
            .sidebar {
                width: 100%;
                max-width: 100%;
            }

            /* Botões de navegação - esquerda */
            .menu-btn {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
                top: 12px !important;
                left: 12px !important;
            }

            .toggle-markers-btn {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
                top: 64px !important;
                left: 12px !important;
            }

            .offline-indicator {
                width: 38px !important;
                height: 38px !important;
                min-width: 38px !important;
                min-height: 38px !important;
                max-width: 38px !important;
                max-height: 38px !important;
                top: 116px !important;
                left: 12px !important;
            }

            .offline-indicator svg {
                width: 18px !important;
                height: 18px !important;
            }

            /* Popup de rotas */
            .mapboxgl-popup-content {
                padding: 10px !important;
                max-width: 260px !important;
            }

            .route-popup-content {
                font-size: 11px !important;
                max-width: 100% !important;
            }

            .route-popup-address {
                font-size: 11px !important;
                margin-bottom: 6px !important;
            }

            .route-popup-btn {
                font-size: 9px !important;
                padding: 6px 6px !important;
                min-height: 32px !important;
                max-height: 32px !important;
                gap: 2px !important;
                min-width: 60px !important;
                flex: 1 1 auto !important;
            }

            .route-popup-btn svg {
                width: 10px !important;
                height: 10px !important;
            }

            .route-popup-btn .btn-text {
                font-size: 9px !important;
            }

            .route-popup-order {
                font-size: 9px !important;
                padding: 2px 6px !important;
            }

            .route-popup-actions {
                flex-wrap: nowrap !important;
                gap: 3px !important;
                margin-top: 8px !important;
                padding-top: 8px !important;
            }

            .mapboxgl-popup-close-button {
                width: 32px !important;
                height: 32px !important;
                min-width: 32px !important;
                min-height: 32px !important;
                max-width: 32px !important;
                max-height: 32px !important;
                font-size: 22px !important;
                line-height: 32px !important;
                top: -38px;
            }

            /* Sidebar header */
            .sidebar-header {
                padding: 16px;
            }

            .sidebar-header-icon {
                width: 36px;
                height: 36px;
            }

            .sidebar-header-icon svg {
                width: 18px;
                height: 18px;
            }

            .sidebar-title {
                font-size: 16px;
            }

            /* Sidebar content */
            .sidebar-content {
                padding: 16px;
            }

            /* Botões do sidebar - exceto close-btn e cliente-item-btn */
            .sidebar button:not(.close-btn):not(.cliente-item-btn) {
                padding: 10px 16px !important;
                font-size: 13px !important;
                min-height: 40px !important;
            }

            /* Botão fechar sidebar - mobile */
            .close-btn {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                max-width: 40px !important;
                max-height: 40px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .close-btn svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botão excluir cliente - mobile */
            .cliente-item-btn {
                width: 32px !important;
                height: 32px !important;
                min-width: 32px !important;
                min-height: 32px !important;
                max-width: 32px !important;
                max-height: 32px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .cliente-item-btn svg {
                width: 18px !important;
                height: 18px !important;
            }

            /* Inputs - exceto search-input que tem estilos próprios */
            input[type="text"]:not(.search-input),
            input[type="file"],
            select,
            textarea {
                padding: 10px !important;
                font-size: 14px !important;
                min-height: 40px !important;
            }

            /* Search input específico - mobile */
            .search-input {
                padding: 12px 14px 12px 42px !important;
                font-size: 16px !important;
                min-height: 44px !important;
            }

            .search-input-wrapper svg {
                width: 20px !important;
                height: 20px !important;
                left: 12px !important;
            }

            /* Location error modal */
            .location-error {
                padding: 20px;
                max-width: 85%;
            }

            .location-error h3 {
                font-size: 16px;
            }

            .location-error p {
                font-size: 13px;
            }

            .retry-btn {
                padding: 10px 20px !important;
                font-size: 13px !important;
            }

            /* Upload modal - mobile */
            .upload-modal-content {
                width: 95% !important;
                max-width: 100% !important;
                max-height: 85vh !important;
                border-radius: 16px !important;
                margin: 10px !important;
            }

            .upload-modal-header {
                padding: 16px !important;
            }

            .upload-modal-header h3 {
                font-size: 16px !important;
            }

            .upload-modal-body {
                padding: 16px !important;
            }

            .upload-dropzone {
                padding: 24px 16px !important;
            }

            .upload-modal-close {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                min-height: 36px !important;
                max-width: 36px !important;
                max-height: 36px !important;
                padding: 0 !important;
            }

            /* QR modal - mobile */
            .qr-modal-header {
                padding: 12px 16px !important;
            }

            .qr-modal-title {
                font-size: 16px !important;
            }

            .qr-modal-close {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
                padding: 0 !important;
            }

            .qr-scanner-container {
                max-width: 320px !important;
            }

            .qr-scan-area {
                width: 200px !important;
                height: 200px !important;
            }

            /* Adjust mode bar - mobile */
            .adjust-mode-bar {
                padding: 12px 16px !important;
            }

            .adjust-mode-btn {
                padding: 10px 16px !important;
                font-size: 13px !important;
                min-height: 40px !important;
                max-height: 40px !important;
            }

            .adjust-mode-info p {
                font-size: 11px !important;
            }

            .adjust-mode-info strong {
                font-size: 12px !important;
            }

            /* Upload de arquivos */
            .file-upload-label {
                padding: 12px !important;
                font-size: 13px !important;
            }

            /* Botões do lado direito - mobile (abaixo dos controles Mapbox: zoom, compass, geolocate ~160px) */
            .spreadsheet-btn {
                top: 175px !important;
                right: 10px !important;
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
            }

            .route-markers-btn {
                top: 227px !important;
                right: 10px !important;
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
            }

            .spreadsheet-btn svg, .route-markers-btn svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botão cadastrar - mobile */
            .cadastrar-btn {
                min-width: 160px !important;
                padding: 12px 20px !important;
                font-size: 14px !important;
                bottom: 20px !important;
            }

            .cadastrar-btn svg {
                width: 18px !important;
                height: 18px !important;
            }

            /* Botão encerrar navegação - mobile (mesma posição do cadastrar) */
            .end-nav-btn {
                min-width: 160px !important;
                padding: 12px 20px !important;
                font-size: 14px !important;
                bottom: 20px !important;
            }

            .end-nav-btn svg {
                width: 18px !important;
                height: 18px !important;
            }
        }

        /* Mobile Devices (Landscape) & Small Tablets - 481px a 768px */
        @media (min-width: 481px) and (max-width: 768px) {
            .sidebar {
                width: 360px;
                max-width: 80vw;
            }

            .route-popup-content {
                font-size: 12px;
                max-width: 220px;
            }

            .route-popup-btn {
                font-size: 10px !important;
                padding: 6px 8px !important;
                min-height: 34px !important;
                max-height: 34px !important;
                min-width: 65px !important;
                flex: 1 1 auto !important;
            }

            .route-popup-actions {
                flex-wrap: nowrap !important;
                gap: 4px !important;
            }

            /* Botão fechar popup - tablet pequeno */
            .mapboxgl-popup-close-button {
                width: 32px !important;
                height: 32px !important;
                min-width: 32px !important;
                min-height: 32px !important;
                max-width: 32px !important;
                max-height: 32px !important;
                font-size: 22px !important;
                line-height: 32px !important;
                top: -38px;
            }

            /* Botões do sidebar - exceto close-btn e cliente-item-btn */
            .sidebar button:not(.close-btn):not(.cliente-item-btn) {
                min-height: 42px !important;
                font-size: 14px !important;
            }

            /* Botão fechar sidebar - tablet */
            .close-btn {
                width: 38px !important;
                height: 38px !important;
                min-width: 38px !important;
                min-height: 38px !important;
                max-width: 38px !important;
                max-height: 38px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .close-btn svg {
                width: 20px !important;
                height: 20px !important;
            }

            /* Botão excluir cliente - tablet */
            .cliente-item-btn {
                width: 30px !important;
                height: 30px !important;
                min-width: 30px !important;
                min-height: 30px !important;
                max-width: 30px !important;
                max-height: 30px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .cliente-item-btn svg {
                width: 16px !important;
                height: 16px !important;
            }

            /* Inputs - exceto search-input */
            input[type="text"]:not(.search-input),
            input[type="file"],
            select,
            textarea {
                min-height: 42px !important;
                font-size: 14px !important;
            }

            /* Search input específico - tablet */
            .search-input {
                padding: 11px 14px 11px 42px !important;
                font-size: 15px !important;
                min-height: 42px !important;
            }

            .search-input-wrapper svg {
                width: 18px !important;
                height: 18px !important;
                left: 14px !important;
            }

            /* Botões de navegação - esquerda - tablets */
            .menu-btn {
                width: 46px !important;
                height: 46px !important;
                min-width: 46px !important;
                min-height: 46px !important;
                max-width: 46px !important;
                max-height: 46px !important;
                top: 14px !important;
                left: 14px !important;
            }

            .toggle-markers-btn {
                width: 46px !important;
                height: 46px !important;
                min-width: 46px !important;
                min-height: 46px !important;
                max-width: 46px !important;
                max-height: 46px !important;
                top: 70px !important;
                left: 14px !important;
            }

            .offline-indicator {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                max-width: 40px !important;
                max-height: 40px !important;
                top: 126px !important;
                left: 14px !important;
            }

            /* Botões do lado direito - small tablets (abaixo dos controles Mapbox) */
            .spreadsheet-btn {
                top: 180px !important;
                right: 12px !important;
                width: 46px !important;
                height: 46px !important;
                min-width: 46px !important;
                min-height: 46px !important;
                max-width: 46px !important;
                max-height: 46px !important;
            }

            .route-markers-btn {
                top: 236px !important;
                right: 12px !important;
                width: 46px !important;
                height: 46px !important;
                min-width: 46px !important;
                min-height: 46px !important;
                max-width: 46px !important;
                max-height: 46px !important;
            }

            .spreadsheet-btn svg, .route-markers-btn svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botões inferiores - small tablets */
            .cadastrar-btn {
                min-width: 180px !important;
                padding: 14px 24px !important;
                font-size: 14px !important;
                bottom: 24px !important;
            }

            .end-nav-btn {
                min-width: 180px !important;
                padding: 14px 24px !important;
                font-size: 14px !important;
                bottom: 24px !important;
            }

            /* Upload modal - tablets */
            .upload-modal-content {
                width: 90% !important;
                max-width: 480px !important;
            }

            .upload-modal-close {
                width: 38px !important;
                height: 38px !important;
                min-width: 38px !important;
                min-height: 38px !important;
                max-width: 38px !important;
                max-height: 38px !important;
                padding: 0 !important;
            }

            /* QR modal - tablets */
            .qr-modal-close {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
                padding: 0 !important;
            }

            .qr-scanner-container {
                max-width: 360px !important;
            }

            /* Adjust mode bar - tablets */
            .adjust-mode-btn {
                padding: 12px 20px !important;
                font-size: 14px !important;
                min-height: 44px !important;
                max-height: 44px !important;
            }
        }

        /* Tablets & Small Laptops - 769px a 1024px */
        @media (min-width: 769px) and (max-width: 1024px) {
            .sidebar {
                width: 380px;
            }

            /* Botão fechar popup - tablets */
            .mapboxgl-popup-close-button {
                width: 32px !important;
                height: 32px !important;
                min-width: 32px !important;
                min-height: 32px !important;
                max-width: 32px !important;
                max-height: 32px !important;
                font-size: 22px !important;
                line-height: 32px !important;
                top: -38px;
            }

            /* Botões de navegação - esquerda */
            .menu-btn {
                top: 16px;
                left: 16px;
            }

            .toggle-markers-btn {
                top: 76px;
                left: 16px;
            }

            .offline-indicator {
                top: 136px;
                left: 16px;
            }

            /* Botões do lado direito - tablets (abaixo dos controles Mapbox) */
            .spreadsheet-btn {
                top: 190px;
                right: 12px;
            }

            .route-markers-btn {
                top: 250px;
                right: 12px;
            }
        }

        /* Multimídia Veicular (Landscape) - típico 800x480 a 1280x720 */
        @media (min-width: 600px) and (max-width: 1280px) and (orientation: landscape) {
            /* Botões maiores para toque em telas de carro */
            .menu-btn {
                width: 52px !important;
                height: 52px !important;
                min-width: 52px !important;
                min-height: 52px !important;
                max-width: 52px !important;
                max-height: 52px !important;
                top: 16px !important;
                left: 16px !important;
            }

            .toggle-markers-btn {
                width: 52px !important;
                height: 52px !important;
                min-width: 52px !important;
                min-height: 52px !important;
                max-width: 52px !important;
                max-height: 52px !important;
                top: 80px !important;
                left: 16px !important;
            }

            .offline-indicator {
                top: 144px !important;
                left: 16px !important;
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                min-height: 44px !important;
                max-width: 44px !important;
                max-height: 44px !important;
            }

            .offline-indicator svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botões do lado direito - posicionados abaixo dos controles do Mapbox */
            .spreadsheet-btn {
                top: 220px !important;
                right: 14px !important;
                width: 50px !important;
                height: 50px !important;
                min-width: 50px !important;
                min-height: 50px !important;
                max-width: 50px !important;
                max-height: 50px !important;
            }

            .route-markers-btn {
                top: 282px !important;
                right: 14px !important;
                width: 50px !important;
                height: 50px !important;
                min-width: 50px !important;
                min-height: 50px !important;
                max-width: 50px !important;
                max-height: 50px !important;
            }

            .spreadsheet-btn svg, .route-markers-btn svg {
                width: 24px !important;
                height: 24px !important;
            }

            /* Botão cadastrar maior para touch */
            .cadastrar-btn {
                min-width: 200px !important;
                padding: 16px 28px !important;
                font-size: 15px !important;
                bottom: 24px !important;
            }

            /* Botão encerrar navegação (mesma posição do cadastrar) */
            .end-nav-btn {
                min-width: 200px !important;
                padding: 16px 28px !important;
                font-size: 15px !important;
                bottom: 24px !important;
            }

            /* Popups maiores para melhor legibilidade */
            .route-popup-content {
                font-size: 14px;
                max-width: 280px;
            }

            .route-popup-btn {
                font-size: 10px !important;
                padding: 8px 10px !important;
                min-height: 36px !important;
                max-height: 36px !important;
                min-width: 70px !important;
                flex: 1 1 auto !important;
            }

            .route-popup-btn svg {
                width: 12px !important;
                height: 12px !important;
            }

            .route-popup-actions {
                flex-wrap: nowrap !important;
                gap: 4px !important;
            }

            /* Botão fechar popup - landscape */
            .mapboxgl-popup-close-button {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                min-height: 36px !important;
                max-width: 36px !important;
                max-height: 36px !important;
                font-size: 24px !important;
                line-height: 36px !important;
                top: -42px;
            }

            /* Sidebar otimizada para landscape */
            .sidebar {
                width: 420px;
                max-width: 50vw;
            }

            .sidebar-header {
                padding: 20px;
            }

            .sidebar-content {
                padding: 20px;
            }

            /* Formulários com campos maiores - exceto search-input */
            input[type="text"]:not(.search-input),
            input[type="file"],
            select,
            textarea {
                min-height: 48px;
                font-size: 15px;
            }

            /* Search input específico - veicular */
            .search-input {
                padding: 12px 14px 12px 44px !important;
                font-size: 16px !important;
                min-height: 48px !important;
            }

            .search-input-wrapper svg {
                width: 20px !important;
                height: 20px !important;
                left: 14px !important;
            }

            /* Botões gerais - exceto close-btn, cliente-item-btn e route-popup-btn */
            button:not(.close-btn):not(.cliente-item-btn):not(.route-popup-btn) {
                min-height: 48px;
                font-size: 15px;
            }

            /* Botão fechar sidebar - veicular */
            .close-btn {
                width: 42px !important;
                height: 42px !important;
                min-height: 42px !important;
                max-height: 42px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .close-btn svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botão excluir cliente - veicular */
            .cliente-item-btn {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                min-height: 36px !important;
                max-width: 36px !important;
                max-height: 36px !important;
                padding: 0 !important;
                flex-shrink: 0;
            }

            .cliente-item-btn svg {
                width: 18px !important;
                height: 18px !important;
            }

            /* Upload modal - veicular */
            .upload-modal-content {
                width: 85% !important;
                max-width: 500px !important;
                max-height: 80vh !important;
            }

            .upload-modal-header {
                padding: 18px 24px !important;
            }

            .upload-modal-close {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                max-width: 40px !important;
                max-height: 40px !important;
                padding: 0 !important;
            }

            /* QR modal - veicular */
            .qr-modal-header {
                padding: 16px 20px !important;
            }

            .qr-scanner-container {
                max-width: 380px !important;
            }

            /* Adjust mode bar - veicular */
            .adjust-mode-bar {
                padding: 16px 24px !important;
            }

            .adjust-mode-btn {
                padding: 14px 24px !important;
                font-size: 15px !important;
                min-height: 48px !important;
                max-height: 48px !important;
            }

            /* Location error - veicular */
            .location-error {
                padding: 24px !important;
                max-width: 400px !important;
            }

            .location-error h3 {
                font-size: 18px !important;
            }

            .location-error p {
                font-size: 14px !important;
            }
        }

        /* Desktop - 1025px em diante */
        @media (min-width: 1025px) {
            .sidebar {
                width: 400px;
            }

            /* Botões de navegação - esquerda */
            .menu-btn {
                top: 16px;
                left: 16px;
            }

            .toggle-markers-btn {
                top: 76px;
                left: 16px;
            }

            .offline-indicator {
                top: 140px;
                left: 16px;
            }

            /* Botões do lado direito */
            .spreadsheet-btn {
                top: 195px;
                right: 12px;
            }

            .route-markers-btn {
                top: 255px;
                right: 12px;
            }

            .route-popup-content {
                max-width: 240px;
            }
        }

        /* Large Desktop - 1440px em diante */
        @media (min-width: 1440px) {
            .sidebar {
                width: 450px;
            }

            .route-popup-content {
                font-size: 14px;
                max-width: 260px;
            }

            /* Botões do lado direito - large desktop */
            .spreadsheet-btn {
                top: 200px;
                right: 14px;
            }

            .route-markers-btn {
                top: 260px;
                right: 14px;
            }
        }

        /* Extra Large Desktop - 1920px em diante */
        @media (min-width: 1920px) {
            .sidebar {
                width: 500px;
            }

            /* Botões de navegação - esquerda */
            .menu-btn {
                width: 52px;
                height: 52px;
                top: 20px;
                left: 20px;
            }

            .toggle-markers-btn {
                width: 52px;
                height: 52px;
                top: 84px;
                left: 20px;
            }

            .offline-indicator {
                width: 48px;
                height: 48px;
                top: 148px;
                left: 20px;
            }

            /* Botões do lado direito */
            .spreadsheet-btn {
                top: 210px;
                right: 16px;
                width: 52px;
                height: 52px;
            }

            .route-markers-btn {
                top: 274px;
                right: 16px;
                width: 52px;
                height: 52px;
            }

            /* Botões inferiores */
            .cadastrar-btn {
                min-width: 200px;
                padding: 16px 28px;
                font-size: 16px;
                bottom: 28px;
            }

            .end-nav-btn {
                min-width: 200px;
                padding: 16px 28px;
                font-size: 16px;
                bottom: 28px;
            }

            .route-popup-content {
                font-size: 15px;
                max-width: 300px;
            }
        }

        /* Touch devices - área de toque maior (exceto mobile pequeno) */
        @media (hover: none) and (pointer: coarse) and (min-width: 481px) {
            .menu-btn, .toggle-markers-btn {
                min-width: 48px;
                min-height: 48px;
            }

            .spreadsheet-btn, .route-markers-btn {
                min-width: 46px;
                min-height: 46px;
            }

            /* Botões gerais - exceto close-btn, cliente-item-btn e route-popup-btn */
            button:not(.route-popup-btn):not(.close-btn):not(.cliente-item-btn) {
                min-height: 44px;
            }

            .route-popup-btn {
                font-size: 10px !important;
                padding: 8px 10px !important;
                min-height: 36px !important;
                max-height: 36px !important;
                min-width: 70px !important;
                flex: 1 1 auto !important;
            }

            .route-popup-actions {
                flex-wrap: nowrap !important;
                gap: 4px !important;
            }

            .cadastrar-btn, .end-nav-btn {
                min-height: 48px;
                padding: 14px 24px;
            }

            /* Botão fechar sidebar - touch */
            .close-btn {
                width: 44px !important;
                height: 44px !important;
                min-height: 44px !important;
                padding: 0 !important;
            }

            .close-btn svg {
                width: 22px !important;
                height: 22px !important;
            }

            /* Botão fechar popup - touch devices */
            .mapboxgl-popup-close-button {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                min-height: 36px !important;
                max-width: 36px !important;
                max-height: 36px !important;
                font-size: 24px !important;
                line-height: 36px !important;
                top: -42px;
            }

            /* Botão excluir cliente - touch */
            .cliente-item-btn {
                width: 36px !important;
                height: 36px !important;
                min-width: 36px !important;
                min-height: 36px !important;
                max-width: 36px !important;
                max-height: 36px !important;
                padding: 0 !important;
            }

            .cliente-item-btn svg {
                width: 18px !important;
                height: 18px !important;
            }

            /* Upload modal close - touch */
            .upload-modal-close {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                max-width: 40px !important;
                max-height: 40px !important;
                padding: 0 !important;
            }

            /* QR modal close - touch */
            .qr-modal-close {
                width: 48px !important;
                height: 48px !important;
                min-width: 48px !important;
                min-height: 48px !important;
                max-width: 48px !important;
                max-height: 48px !important;
                padding: 0 !important;
            }

            /* Adjust mode buttons - touch */
            .adjust-mode-btn {
                min-height: 48px !important;
                max-height: 48px !important;
                padding: 14px 24px !important;
            }

            /* Botão fechar sidebar - touch - garantir dimensões */
            .close-btn {
                max-height: 44px !important;
            }
        }

        /* High DPI Screens (Retina, etc) */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            /* Ajustes para telas de alta resolução se necessário */
        }
    </style>
</head>
<body>
    <!-- Loader de inicialização - aparece imediatamente -->
    <div class="app-loader" id="appLoader">
        <div class="loader-content">
            <div class="loader-icon">
                <div class="loader-ring"></div>
                <div class="loader-ring"></div>
                <div class="loader-pin">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                    </svg>
                </div>
            </div>
            <div class="loader-title">Mapa Interativo</div>
            <div class="loader-status" id="loaderStatus">Inicializando...</div>
            <div class="loader-progress">
                <div class="loader-bar" id="loaderBar"></div>
            </div>
        </div>
    </div>

    <div id="map">
        <!-- Center Pin for Adjust Mode - inside map container for accurate positioning -->
        <div class="center-pin" id="centerPin">
            <div class="center-pin-marker">
                <div class="center-pin-head"></div>
            </div>
        </div>
    </div>

    <!-- Location Error -->
    <div class="location-error" id="locationError">
        <div class="location-error-icon">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </div>
        <h3>Localização não disponível</h3>
        <p id="errorMessage">Permita o acesso à sua localização para usar o mapa.</p>
        <button class="retry-btn" id="retryBtn">Tentar novamente</button>
    </div>

    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator" title="Online" onclick="manualSync()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.141 0M1.394 9.393c5.857-5.857 15.355-5.857 21.213 0" />
        </svg>
        <span class="offline-badge" id="offlineBadge">0</span>
    </div>

    <!-- Menu Button -->
    <button class="menu-btn" id="menuBtn" aria-label="Abrir menu">
        <div class="hamburger">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </button>

    <!-- Toggle Markers Button -->
    <button class="toggle-markers-btn" id="toggleMarkersBtn" aria-label="Exibir/ocultar marcadores" title="Exibir/ocultar marcadores">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
    </button>

    <!-- End Navigation Button -->
    <button class="end-nav-btn" id="endNavBtn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
        </svg>
        Encerrar
    </button>

    <!-- Cadastrar Button -->
    <button class="cadastrar-btn" id="cadastrarBtn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
        </svg>
        Cadastrar
    </button>

    <!-- Spreadsheet Button -->
    <button class="spreadsheet-btn" id="spreadsheetBtn" aria-label="Planilha" title="Planilha">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M3 5a2 2 0 012-2h14a2 2 0 012 2v14a2 2 0 01-2 2H5a2 2 0 01-2-2V5zm2 0v4h4V5H5zm6 0v4h4V5h-4zm6 0v4h2V5h-2zM5 11v4h4v-4H5zm6 0v4h4v-4h-4zm6 0v4h2v-4h-2zM5 17v2h4v-2H5zm6 0v2h4v-2h-4zm6 0v2h2v-2h-2z"/>
        </svg>
    </button>

    <!-- Route Markers Button -->
    <button class="route-markers-btn" id="routeMarkersBtn" aria-label="Paradas da Rota" title="Paradas da Rota">
        <div class="progress-fill" id="routeProgressFill"></div>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
            <circle cx="12" cy="9" r="2"/>
        </svg>
    </button>

    <!-- Fixed Stats Panel -->
    <div class="fixed-stats-panel" id="fixedStatsPanel">
        <div class="fixed-stat-item total" title="Marcadores verdes + vermelhos">
            <span class="fixed-stat-number" id="fixedStatTotal">0</span>
            <span class="fixed-stat-label">Paradas</span>
        </div>
        <div class="fixed-stat-item registered" title="Marcadores verdes (cadastrados)">
            <span class="fixed-stat-number" id="fixedStatRegistered">0</span>
            <span class="fixed-stat-label">Cadastrados</span>
        </div>
        <div class="fixed-stat-item unregistered" title="Marcadores vermelhos (não cadastrados)">
            <span class="fixed-stat-number" id="fixedStatUnregistered">0</span>
            <span class="fixed-stat-label">Não Cadast.</span>
        </div>
        <div class="fixed-stat-item pending" title="Pacotes pendentes de entrega">
            <span class="fixed-stat-number" id="fixedStatPending">0</span>
            <span class="fixed-stat-label">Pendentes</span>
        </div>
        <div class="fixed-stat-item delivered" title="Entregas realizadas">
            <span class="fixed-stat-number" id="fixedStatDelivered">0</span>
            <span class="fixed-stat-label">Entregas</span>
        </div>
    </div>

    <!-- QR Scanner Modal -->
    <div class="qr-modal" id="qrModal">
        <div class="qr-modal-header">
            <div class="qr-modal-title">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z" />
                </svg>
                Escanear QR Code
            </div>
            <button class="qr-modal-close" id="qrModalClose">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>

        <div class="qr-scanner-container">
            <video class="qr-video" id="qrVideo" playsinline></video>
            <canvas class="qr-canvas" id="qrCanvas"></canvas>

            <div class="qr-overlay">
                <div class="qr-scan-area">
                    <div class="qr-scan-line"></div>
                    <div class="qr-scan-area-bottom"></div>
                </div>
            </div>

            <div class="qr-loading" id="qrLoading">
                <div class="qr-loading-spinner"></div>
                <p class="qr-loading-text">Iniciando câmera...</p>
            </div>

            <!-- Torch flash overlay - hides bright flash when torch turns on -->
            <div class="qr-torch-flash" id="qrTorchFlash"></div>

        </div>

        <div class="qr-status">
            <p class="qr-status-text" id="qrStatusText">Posicione o QR Code dentro da área</p>
            <p class="qr-status-hint">A leitura é automática</p>
        </div>

        <!-- Address List for Manual Selection -->
        <div class="qr-address-list-container" id="qrAddressListContainer">
            <div class="qr-address-list" id="qrAddressList">
                <div class="qr-address-list-empty">Carregando...</div>
            </div>
        </div>
    </div>

    <!-- Address Already Registered Modal -->
    <div class="address-exists-modal" id="addressExistsModal">
        <div class="address-exists-icon">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
        </div>
        <h3>Endereço Já Cadastrado</h3>
        <p>Este endereço já possui coordenadas registradas no sistema.</p>
        <div class="address-exists-address" id="addressExistsText">Endereço</div>
        <p style="font-size: 12px; margin-top: 12px;">Deseja ajustar a localização no mapa?</p>
        <div class="address-exists-actions">
            <button class="address-exists-btn address-exists-btn-cancel" id="addressExistsCancel">Cancelar</button>
            <button class="address-exists-btn address-exists-btn-adjust" id="addressExistsAdjust">Ajustar no Mapa</button>
        </div>
    </div>

    <!-- Upload Modal -->
    <div class="upload-modal" id="uploadModal">
        <div class="upload-modal-content">
            <div class="upload-modal-header">
                <h3>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 5a2 2 0 012-2h14a2 2 0 012 2v14a2 2 0 01-2 2H5a2 2 0 01-2-2V5zm2 0v4h4V5H5zm6 0v4h4V5h-4zm6 0v4h2V5h-2zM5 11v4h4v-4H5zm6 0v4h4v-4h-4zm6 0v4h2v-4h-2zM5 17v2h4v-2H5zm6 0v2h4v-2h-4zm6 0v2h2v-2h-2z"/>
                    </svg>
                    Importar Planilha
                </h3>
                <button class="upload-modal-close" id="uploadModalClose">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>

            <div class="upload-modal-body">
                <!-- Dropzone -->
                <div class="upload-dropzone" id="uploadDropzone">
                    <div class="upload-dropzone-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                    </div>
                    <h4>Arraste sua planilha aqui</h4>
                    <p>ou clique para selecionar um arquivo .xlsx</p>
                    <input type="file" id="fileInput" accept=".xlsx,.xls">
                </div>

                <!-- Preview -->
                <div class="upload-preview" id="uploadPreview">
                    <div class="upload-file-info">
                        <div class="upload-file-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 5a2 2 0 012-2h14a2 2 0 012 2v14a2 2 0 01-2 2H5a2 2 0 01-2-2V5zm2 0v4h4V5H5zm6 0v4h4V5h-4zm6 0v4h2V5h-2zM5 11v4h4v-4H5zm6 0v4h4v-4h-4zm6 0v4h2v-4h-2zM5 17v2h4v-2H5zm6 0v2h4v-2h-4zm6 0v2h2v-2h-2z"/>
                            </svg>
                        </div>
                        <div class="upload-file-details">
                            <div class="upload-file-name" id="fileName">planilha.xlsx</div>
                            <div class="upload-file-meta" id="fileMeta">68 registros encontrados</div>
                        </div>
                    </div>

                    <div class="upload-preview-table" id="previewTable">
                        <table>
                            <thead id="previewHead"></thead>
                            <tbody id="previewBody"></tbody>
                        </table>
                    </div>

                    <div class="upload-warning">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                        </svg>
                        <p><strong>Atenção:</strong> Os dados da planilha anterior serão substituídos pelos novos dados.</p>
                    </div>
                </div>

                <!-- Progress -->
                <div class="upload-progress" id="uploadProgress">
                    <div class="upload-progress-spinner"></div>
                    <p id="progressText">Enviando dados para o servidor...</p>
                </div>

                <!-- Success -->
                <div class="upload-success" id="uploadSuccess">
                    <div class="upload-success-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                        </svg>
                    </div>
                    <h4>Planilha importada!</h4>
                    <p id="successText">68 registros foram salvos com sucesso.</p>
                </div>
            </div>

            <div class="upload-modal-footer" id="uploadModalFooter">
                <button class="upload-btn upload-btn-secondary" id="uploadCancel">Cancelar</button>
                <button class="upload-btn upload-btn-primary" id="uploadConfirm" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                    </svg>
                    Importar
                </button>
            </div>
        </div>
    </div>


    <!-- Adjust Mode Bar -->
    <div class="adjust-mode-bar" id="adjustModeBar">
        <div class="adjust-mode-actions">
            <button class="adjust-mode-btn adjust-mode-btn-cancel" id="adjustModeCancel">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
                Cancelar
            </button>
            <button class="adjust-mode-btn adjust-mode-btn-confirm" id="adjustModeConfirm">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                </svg>
                Confirmar
            </button>
        </div>
        <div class="adjust-mode-info">
            <p>Mova o mapa para ajustar a posição</p>
            <strong id="adjustModeAddress">Endereço aqui...</strong>
        </div>
    </div>

    <!-- Overlay -->
    <div class="overlay" id="overlay"></div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-header-icon">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </div>
            <div class="sidebar-header-text">
                <h2>Clientes</h2>
                <p id="clienteCount">Carregando...</p>
            </div>
            <button class="close-btn" id="closeBtn" aria-label="Fechar menu">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>

        <div class="sidebar-search">
            <div class="search-input-wrapper">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
                <input type="text" class="search-input" id="searchInput" placeholder="Buscar endereço...">
            </div>
        </div>

        <div class="sidebar-content" id="sidebarContent">
            <!-- Loading State -->
            <div class="loading" id="loadingState">
                <div class="loading-spinner"></div>
                <p>Carregando clientes...</p>
            </div>

            <!-- Empty State -->
            <div class="empty-state" id="emptyState" style="display: none;">
                <div class="empty-state-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </div>
                <h3>Nenhum cliente encontrado</h3>
                <p>Nenhum registro foi encontrado no banco de dados.</p>
            </div>

            <!-- Cliente List - Virtual Scrolling Container -->
            <div class="cliente-list" id="clienteList" style="display: none;">
                <div class="cliente-list-spacer" id="clienteListSpacer"></div>
                <div class="cliente-list-viewport" id="clienteListViewport"></div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // LOADER SYSTEM - Controle de progresso
        // ============================================
        const loaderStatus = document.getElementById('loaderStatus');
        const loaderBar = document.getElementById('loaderBar');
        const appLoader = document.getElementById('appLoader');

        let loadProgress = 0;
        const loadSteps = {
            scripts: 20,
            mapbox: 40,
            supabase: 60,
            gps: 80,
            ready: 100
        };

        function updateLoader(step, message) {
            loadProgress = loadSteps[step] || loadProgress;
            if (loaderStatus) loaderStatus.textContent = message;
            if (loaderBar) loaderBar.style.width = loadProgress + '%';
        }

        function hideLoader() {
            if (appLoader) {
                appLoader.classList.add('hidden');
                // Remove do DOM após a transição
                setTimeout(() => {
                    if (appLoader.parentNode) appLoader.remove();
                }, 600);
            }
        }

        // Função para carregar scripts dinamicamente
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Verifica se já foi carregado
                if (document.querySelector(`script[src="${src}"]`)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Falha ao carregar: ${src}`));
                document.head.appendChild(script);
            });
        }

        // Inicialização assíncrona de todos os recursos
        async function initializeApp() {
            try {
                updateLoader('scripts', 'Carregando recursos...');

                // Carrega scripts em paralelo para maior velocidade
                await Promise.all([
                    loadScript('https://cdn.jsdelivr.net/npm/mapbox-gl@3.4.0/dist/mapbox-gl.min.js'),
                    loadScript('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2'),
                    loadScript('https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'),
                    loadScript('https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js')
                ]);

                updateLoader('mapbox', 'Preparando mapa...');

                // Pequena pausa para garantir que os scripts foram processados
                await new Promise(r => setTimeout(r, 100));

                // Inicia o resto da aplicação
                initApplication();

            } catch (error) {
                if (loaderStatus) loaderStatus.textContent = 'Erro ao carregar. Recarregando...';
                // Tenta recarregar após 2 segundos
                setTimeout(() => location.reload(), 2000);
            }
        }

        // Inicia carregamento assim que possível
        initializeApp();

        function initApplication() {
            // Supabase initialization
            const SUPABASE_URL = 'https://wwvftlyvewetspombnky.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind3dmZ0bHl2ZXdldHNwb21ibmt5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYzNjE5NjYsImV4cCI6MjA4MTkzNzk2Nn0.qvW0QconrSPOWWtB8SNalIpfWhlO2-Oc8LzJURk4zVs';
            window.db = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
            const db = window.db;

            updateLoader('supabase', 'Conectando banco de dados...');

        // ============================================
        // OFFLINE SYSTEM - IndexedDB & Sync
        // ============================================
        let offlineDB = null;
        let isOnline = navigator.onLine;
        let isSyncing = false;
        let isSyncingPendingData = false; // Flag para bloquear syncs do servidor durante sync de dados offline
        let lastRouteMarkersSave = 0; // Timestamp do último save local (para proteção contra piscada)

        // Initialize IndexedDB for offline storage
        function initOfflineDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MapaInterativoDB', 7);

                request.onerror = () => {
                    // Erro ao abrir IndexedDB
                    reject(request.error);
                };

                request.onsuccess = () => {
                    offlineDB = request.result;
                    resolve(offlineDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    const oldVersion = event.oldVersion;

                    // Store for pending clients (QR code/manual registration)
                    if (!db.objectStoreNames.contains('pendingClients')) {
                        const clientStore = db.createObjectStore('pendingClients', { keyPath: 'localId', autoIncrement: true });
                        clientStore.createIndex('address', 'address', { unique: false });
                        clientStore.createIndex('synced', 'synced', { unique: false });
                    }

                    // Store for pending planilha data
                    if (!db.objectStoreNames.contains('pendingPlanilha')) {
                        const planilhaStore = db.createObjectStore('pendingPlanilha', { keyPath: 'localId', autoIncrement: true });
                        planilhaStore.createIndex('synced', 'synced', { unique: false });
                    }

                    // Store for pending delivery status updates
                    if (!db.objectStoreNames.contains('pendingDeliveryStatus')) {
                        const statusStore = db.createObjectStore('pendingDeliveryStatus', { keyPath: 'localId', autoIncrement: true });
                        statusStore.createIndex('synced', 'synced', { unique: false });
                    }

                    // Store for cached planilha data (for offline reading)
                    if (!db.objectStoreNames.contains('cachedPlanilha')) {
                        const cacheStore = db.createObjectStore('cachedPlanilha', { keyPath: 'id' });
                        cacheStore.createIndex('sequence', 'sequence', { unique: false });
                        cacheStore.createIndex('spx_tn', 'spx_tn', { unique: false });
                    }

                    // v5: Corrige cachedClients removendo autoIncrement para preservar IDs do Supabase
                    // Se vindo da versão 4 ou anterior, deleta e recria a store
                    if (oldVersion < 5 && db.objectStoreNames.contains('cachedClients')) {
                        db.deleteObjectStore('cachedClients');
                    }

                    // Store for cached clients data (for offline reading)
                    // Sem autoIncrement para preservar os IDs originais do Supabase
                    if (!db.objectStoreNames.contains('cachedClients')) {
                        const clientsCacheStore = db.createObjectStore('cachedClients', { keyPath: 'id' });
                        clientsCacheStore.createIndex('address', 'address', { unique: false });
                        clientsCacheStore.createIndex('bairro', 'bairro', { unique: false });
                        clientsCacheStore.createIndex('city', 'city', { unique: false });
                        clientsCacheStore.createIndex('zipcode', 'zipcode', { unique: false });
                    }

                    // Store for cached route markers (persistent markers on map)
                    if (!db.objectStoreNames.contains('cachedRouteMarkers')) {
                        db.createObjectStore('cachedRouteMarkers', { keyPath: 'id' });
                    }

                    // Store for pending similarity overrides
                    if (!db.objectStoreNames.contains('pendingSimilarityOverrides')) {
                        const similarityStore = db.createObjectStore('pendingSimilarityOverrides', { keyPath: 'localId', autoIncrement: true });
                        similarityStore.createIndex('synced', 'synced', { unique: false });
                    }

                    // v6: Store for cache metadata (incremental sync optimization)
                    if (!db.objectStoreNames.contains('cacheMetadata')) {
                        db.createObjectStore('cacheMetadata', { keyPath: 'storeName' });
                    }

                    // v7: Store for pending deletes (offline delete support)
                    if (!db.objectStoreNames.contains('pendingDeletes')) {
                        const deleteStore = db.createObjectStore('pendingDeletes', { keyPath: 'localId', autoIncrement: true });
                        deleteStore.createIndex('clientId', 'clientId', { unique: false });
                        deleteStore.createIndex('synced', 'synced', { unique: false });
                    }

                };
            });
        }

        // Save data to IndexedDB
        function saveToOfflineDB(storeName, data) {
            return new Promise((resolve, reject) => {
                if (!offlineDB) {
                    // Tenta reinicializar o IndexedDB
                    initOfflineDB().then(() => {
                        saveToOfflineDB(storeName, data).then(resolve).catch(reject);
                    }).catch(reject);
                    return;
                }

                try {
                    const transaction = offlineDB.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);

                    // Garante que synced está definido
                    data.synced = 0; // 0 = false, 1 = true (IndexedDB não aceita boolean como chave)
                    data.createdAt = data.createdAt || new Date().toISOString();

                    // Usa add() para novos registros (autoIncrement gera localId)
                    const request = store.add(data);

                    request.onsuccess = () => {
                        resolve(request.result);
                    };

                    request.onerror = (event) => {
                        // Se falhar por duplicação, ignora (já existe)
                        if (event.target.error?.name === 'ConstraintError') {
                            resolve(null);
                        } else {
                            console.error('[IndexedDB] Erro ao salvar:', storeName, event.target.error);
                            reject(event.target.error);
                        }
                    };

                    transaction.onerror = (event) => {
                        console.error('[IndexedDB] Erro na transação:', storeName, event.target.error);
                    };
                } catch (error) {
                    console.error('[IndexedDB] Exceção ao salvar:', storeName, error);
                    reject(error);
                }
            });
        }

        // Get all pending (unsynced) data from a store
        function getPendingFromOfflineDB(storeName) {
            return new Promise((resolve, reject) => {
                if (!offlineDB) {
                    // Retorna array vazio se IndexedDB não está disponível
                    resolve([]);
                    return;
                }

                try {
                    const transaction = offlineDB.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);

                    // Tenta usar o índice 'synced' primeiro
                    try {
                        const index = store.index('synced');
                        const request = index.getAll(IDBKeyRange.only(0)); // 0 = false (não sincronizado)

                        request.onsuccess = () => {
                            resolve(request.result || []);
                        };

                        request.onerror = () => {
                            // Fallback: busca todos os registros
                            const allRequest = store.getAll();
                            allRequest.onsuccess = () => {
                                const all = allRequest.result || [];
                                // Filtra manualmente os não sincronizados
                                const pending = all.filter(item => item.synced === 0 || item.synced === false || item.synced === undefined);
                                resolve(pending);
                            };
                            allRequest.onerror = () => resolve([]);
                        };
                    } catch (indexError) {
                        // Índice não existe, busca todos e filtra
                        const allRequest = store.getAll();
                        allRequest.onsuccess = () => {
                            const all = allRequest.result || [];
                            const pending = all.filter(item => item.synced === 0 || item.synced === false || item.synced === undefined);
                            resolve(pending);
                        };
                        allRequest.onerror = () => resolve([]);
                    }
                } catch (error) {
                    console.error('[IndexedDB] Erro ao buscar pendentes:', storeName, error);
                    resolve([]);
                }
            });
        }

        // Delete synced data from IndexedDB
        // CORREÇÃO: Retorna resolve em vez de reject para não interromper loops de sync
        function deleteSyncedFromOfflineDB(storeName, localId) {
            return new Promise((resolve) => {
                if (!offlineDB) {
                    // Não rejeita - apenas loga e continua
                    console.warn('[IndexedDB] DB não inicializado ao tentar deletar de:', storeName);
                    resolve(false);
                    return;
                }

                if (localId === undefined || localId === null) {
                    console.warn('[IndexedDB] localId inválido para deletar de:', storeName);
                    resolve(false);
                    return;
                }

                try {
                    const transaction = offlineDB.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(localId);

                    request.onsuccess = () => resolve(true);
                    request.onerror = () => {
                        console.warn('[IndexedDB] Erro ao deletar de', storeName, ':', request.error);
                        resolve(false); // Não rejeita - permite que o loop continue
                    };

                    transaction.onerror = () => {
                        console.warn('[IndexedDB] Erro na transação de delete:', transaction.error);
                        resolve(false);
                    };
                } catch (err) {
                    console.warn('[IndexedDB] Exceção ao deletar de', storeName, ':', err);
                    resolve(false);
                }
            });
        }

        // Count pending items in a store
        function countPendingItems(storeName) {
            return new Promise((resolve, reject) => {
                if (!offlineDB) {
                    resolve(0);
                    return;
                }

                const transaction = offlineDB.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const index = store.index('synced');
                const request = index.count(IDBKeyRange.only(0)); // 0 = false (não sincronizado)

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // PERFORMANCE: Flag para detectar quando o usuário está interagindo com o mapa
        let isMapInteracting = false;

        // Função para ceder controle ao main thread durante loops pesados
        // Usa setTimeout com delay real para garantir renderização de frames
        function yieldToMain(minDelay = 50) {
            return new Promise(resolve => {
                // Se o mapa está sendo movido, aguarda mais tempo para não competir
                const delay = isMapInteracting ? 300 : minDelay;
                setTimeout(resolve, delay);
            });
        }

        // Pausa mais longa entre operações pesadas
        function longYield() {
            return new Promise(resolve => setTimeout(resolve, isMapInteracting ? 600 : 200));
        }

        // ============================================
        // BATCH OPERATIONS - Otimização Supabase
        // ============================================
        // Funções auxiliares para agrupar operações e reduzir chamadas ao banco

        // Divide array em chunks de tamanho máximo
        function chunkArray(array, chunkSize) {
            const chunks = [];
            for (let i = 0; i < array.length; i += chunkSize) {
                chunks.push(array.slice(i, i + chunkSize));
            }
            return chunks;
        }

        // Agrupa items por chave (ex: agrupar por status)
        function groupBy(array, keyFn) {
            const groups = new Map();
            for (const item of array) {
                const key = keyFn(item);
                if (!groups.has(key)) {
                    groups.set(key, []);
                }
                groups.get(key).push(item);
            }
            return groups;
        }

        // Constantes para batch
        const BATCH_SIZE = 100; // Supabase recomenda até 1000, mas 100 é mais seguro
        const BATCH_IDS_SIZE = 500; // Máximo de IDs em cláusula IN

        // ============================================
        // DEBOUNCE & THROTTLE - Otimização de Eventos
        // ============================================
        // Funções para limitar frequência de execução de handlers

        /**
         * BEEP SOUND: Som de confirmação para leitura de QR Code
         * Usa Web Audio API para gerar um beep sintetizado
         */
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playQrBeep() {
            try {
                // Resume context if suspended (required after user interaction)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Frequência do beep (1000Hz = tom agudo típico de scanner)
                oscillator.frequency.value = 1000;
                oscillator.type = 'sine';

                // Volume (0.8 = 80% - bem audível)
                gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
                // Fade out rápido
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                // Silently fail if audio not supported
            }
        }

        /**
         * DEBOUNCE: Aguarda o usuário parar de disparar eventos por X ms antes de executar
         * Ideal para: input de busca, resize, validação de formulários
         * @param {Function} func - Função a ser executada
         * @param {number} wait - Tempo de espera em ms
         * @param {boolean} immediate - Se true, executa imediatamente na primeira chamada
         */
        function debounce(func, wait, immediate = false) {
            let timeout;
            return function executedFunction(...args) {
                const context = this;
                const later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        }

        /**
         * THROTTLE: Executa no máximo 1x a cada X ms (para eventos contínuos)
         * Ideal para: scroll, mousemove, drag, resize contínuo
         * @param {Function} func - Função a ser executada
         * @param {number} limit - Intervalo mínimo entre execuções em ms
         */
        function throttle(func, limit) {
            let inThrottle;
            let lastResult;
            return function throttledFunction(...args) {
                const context = this;
                if (!inThrottle) {
                    lastResult = func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => {
                        inThrottle = false;
                    }, limit);
                }
                return lastResult;
            };
        }

        /**
         * THROTTLE com execução final garantida
         * Garante que a última chamada sempre execute (útil para posição final do mapa)
         * @param {Function} func - Função a ser executada
         * @param {number} limit - Intervalo mínimo entre execuções em ms
         */
        function throttleWithTrailing(func, limit) {
            let lastCall = 0;
            let timeout;
            return function throttledFunction(...args) {
                const context = this;
                const now = Date.now();

                // Limpa timeout pendente
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }

                if (now - lastCall >= limit) {
                    // Tempo suficiente passou, executa imediatamente
                    lastCall = now;
                    func.apply(context, args);
                } else {
                    // Agenda execução final após o limite
                    timeout = setTimeout(() => {
                        lastCall = Date.now();
                        func.apply(context, args);
                    }, limit - (now - lastCall));
                }
            };
        }

        // ============================================
        // MEMORY MANAGEMENT - Gerenciamento de Memória
        // ============================================
        // Sistema para evitar memory leaks e gerenciar recursos

        /**
         * Registry de recursos para limpeza automática
         * Rastreia popups, marcadores, timeouts e listeners para cleanup
         */
        const ResourceRegistry = {
            // Popups ativos (WeakMap para auto-cleanup quando elemento é removido)
            popups: new Set(),

            // Marcadores ativos
            markers: new Set(),

            // Timeouts/Intervals ativos (para cancelamento)
            timers: new Map(),

            // Contadores para IDs únicos
            _timerId: 0,

            /**
             * Registra um popup para gerenciamento
             */
            registerPopup(popup) {
                if (popup) {
                    this.popups.add(popup);
                }
                return popup;
            },

            /**
             * Remove e limpa um popup
             */
            removePopup(popup) {
                if (popup) {
                    try {
                        popup.remove();
                    } catch (e) {}
                    this.popups.delete(popup);
                }
            },

            /**
             * Registra um marcador para gerenciamento
             */
            registerMarker(marker) {
                if (marker) {
                    this.markers.add(marker);
                }
                return marker;
            },

            /**
             * Remove e limpa um marcador
             */
            removeMarker(marker) {
                if (marker) {
                    try {
                        marker.remove();
                    } catch (e) {}
                    this.markers.delete(marker);
                }
            },

            /**
             * Limpa todos os popups registrados
             */
            clearAllPopups() {
                for (const popup of this.popups) {
                    try {
                        popup.remove();
                    } catch (e) {}
                }
                this.popups.clear();
            },

            /**
             * Limpa todos os marcadores registrados
             */
            clearAllMarkers() {
                for (const marker of this.markers) {
                    try {
                        marker.remove();
                    } catch (e) {}
                }
                this.markers.clear();
            },

            /**
             * Registra um timeout com ID para cancelamento posterior
             */
            setTimeout(callback, delay, id = null) {
                const timerId = id || `timeout_${++this._timerId}`;

                // Cancela timer anterior com mesmo ID
                if (this.timers.has(timerId)) {
                    clearTimeout(this.timers.get(timerId));
                }

                const timer = setTimeout(() => {
                    this.timers.delete(timerId);
                    callback();
                }, delay);

                this.timers.set(timerId, timer);
                return timerId;
            },

            /**
             * Registra um interval com ID para cancelamento posterior
             */
            setInterval(callback, delay, id = null) {
                const timerId = id || `interval_${++this._timerId}`;

                // Cancela interval anterior com mesmo ID
                if (this.timers.has(timerId)) {
                    clearInterval(this.timers.get(timerId));
                }

                const timer = setInterval(callback, delay);
                this.timers.set(timerId, timer);
                return timerId;
            },

            /**
             * Cancela um timer específico
             */
            clearTimer(timerId) {
                if (this.timers.has(timerId)) {
                    const timer = this.timers.get(timerId);
                    clearTimeout(timer);
                    clearInterval(timer);
                    this.timers.delete(timerId);
                }
            },

            /**
             * Cancela todos os timers
             */
            clearAllTimers() {
                for (const timer of this.timers.values()) {
                    clearTimeout(timer);
                    clearInterval(timer);
                }
                this.timers.clear();
            },

            /**
             * Retorna estatísticas de uso de memória
             */
            getStats() {
                return {
                    popups: this.popups.size,
                    markers: this.markers.size,
                    timers: this.timers.size
                };
            },

            /**
             * Limpa TODOS os recursos registrados
             * Útil para reset completo ou antes de navegação
             */
            clearAll() {
                this.clearAllPopups();
                this.clearAllMarkers();
                this.clearAllTimers();
            }
        };

        /**
         * Limpa caches antigos do IndexedDB para evitar crescimento indefinido
         * @param {number} maxAgeDays - Idade máxima em dias para manter dados
         */
        async function pruneOldCacheData(maxAgeDays = 7) {
            try {
                // Limpa metadados de cache antigos
                const metadata = await getCacheMetadata('cachedClients');
                if (metadata && metadata.lastUpdated) {
                    const age = Date.now() - metadata.lastUpdated;
                    const maxAge = maxAgeDays * 24 * 60 * 60 * 1000;

                    if (age > maxAge) {
                        // Cache muito antigo, força refresh completo
                        await saveCacheMetadata('cachedClients', { count: 0, maxId: 0 });
                        await saveCacheMetadata('cachedPlanilha', { count: 0, maxId: 0 });
                    }
                }
            } catch (e) {
                // Erro silencioso - não crítico
            }
        }

        /**
         * Monitora uso de memória (se API disponível)
         * Retorna info sobre memória usada pelo JS heap
         */
        function getMemoryUsage() {
            if (performance && performance.memory) {
                return {
                    usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                    totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                    jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                };
            }
            return null;
        }

        /**
         * Força garbage collection se possível (apenas em debug)
         * Nota: gc() só está disponível se Chrome for iniciado com --expose-gc
         */
        function forceGC() {
            if (typeof gc === 'function') {
                gc();
                return true;
            }
            return false;
        }

        // ============================================
        // ERROR HANDLING - Sistema Centralizado de Erros
        // ============================================

        /**
         * Sistema centralizado para tratamento de erros
         * Classifica, loga e notifica o usuário de forma amigável
         */
        const ErrorHandler = {
            // Tipos de erro para classificação
            types: {
                NETWORK: 'network',
                DATABASE: 'database',
                SUPABASE: 'supabase',
                GEOLOCATION: 'geolocation',
                VALIDATION: 'validation',
                PERMISSION: 'permission',
                TIMEOUT: 'timeout',
                UNKNOWN: 'unknown'
            },

            // Mensagens amigáveis por tipo de erro
            messages: {
                network: 'Problema de conexão. Verifique sua internet e tente novamente.',
                database: 'Erro ao acessar dados locais. Tente recarregar a página.',
                supabase: 'Erro ao comunicar com o servidor. Tente novamente.',
                geolocation: 'Não foi possível obter sua localização. Verifique as permissões.',
                validation: 'Dados inválidos. Verifique as informações e tente novamente.',
                permission: 'Permissão negada para esta ação.',
                timeout: 'A operação demorou muito. Tente novamente.',
                unknown: 'Ocorreu um erro inesperado. Tente novamente.'
            },

            // Histórico de erros para debug (últimos 50)
            errorLog: [],
            maxLogSize: 50,

            /**
             * Classifica o tipo de erro com base na mensagem e propriedades
             */
            classify(error) {
                if (!error) return this.types.UNKNOWN;

                const msg = (error.message || error.toString()).toLowerCase();
                const code = error.code || '';

                // Network errors
                if (msg.includes('network') || msg.includes('fetch') ||
                    msg.includes('failed to fetch') || msg.includes('net::') ||
                    msg.includes('connection') || !navigator.onLine) {
                    return this.types.NETWORK;
                }

                // Supabase errors
                if (msg.includes('supabase') || error.hint || error.details ||
                    msg.includes('postgresql') || msg.includes('pgrst')) {
                    return this.types.SUPABASE;
                }

                // IndexedDB errors
                if (msg.includes('indexeddb') || msg.includes('idb') ||
                    msg.includes('objectstore') || msg.includes('transaction')) {
                    return this.types.DATABASE;
                }

                // Geolocation errors
                if (code === 1 || msg.includes('permission denied') ||
                    msg.includes('geolocation') || msg.includes('position')) {
                    return this.types.GEOLOCATION;
                }

                // Timeout errors
                if (msg.includes('timeout') || msg.includes('timed out') ||
                    code === 3) {
                    return this.types.TIMEOUT;
                }

                // Permission errors
                if (msg.includes('permission') || msg.includes('denied') ||
                    msg.includes('not allowed')) {
                    return this.types.PERMISSION;
                }

                // Validation errors
                if (msg.includes('invalid') || msg.includes('required') ||
                    msg.includes('validation')) {
                    return this.types.VALIDATION;
                }

                return this.types.UNKNOWN;
            },

            /**
             * Handler principal - processa e notifica erros
             * @param {Error|string} error - O erro a ser tratado
             * @param {Object} context - Contexto adicional (ação, dados, etc.)
             * @param {Object} options - Opções de tratamento
             */
            handle(error, context = {}, options = {}) {
                const {
                    silent = false,       // Se true, não mostra notificação
                    logOnly = false,      // Se true, apenas loga
                    customMessage = null  // Mensagem personalizada
                } = options;

                // Cria objeto de erro estruturado
                const errorInfo = {
                    type: this.classify(error),
                    message: error?.message || error?.toString() || 'Unknown error',
                    code: error?.code || null,
                    context: context,
                    timestamp: Date.now(),
                    stack: error?.stack || null,
                    isOnline: navigator.onLine
                };

                // Adiciona ao log
                this.log(errorInfo);

                // Log no console para debug
                console.error('[ErrorHandler]', errorInfo.type, errorInfo.message, context);

                // Notifica usuário se não for silencioso
                if (!silent && !logOnly) {
                    const displayMessage = customMessage || this.messages[errorInfo.type];
                    this.notify(displayMessage, errorInfo.type);
                }

                return errorInfo;
            },

            /**
             * Adiciona erro ao histórico (para debug)
             */
            log(errorInfo) {
                this.errorLog.unshift(errorInfo);
                if (this.errorLog.length > this.maxLogSize) {
                    this.errorLog.pop();
                }
            },

            /**
             * Retorna histórico de erros para debug
             */
            getLog() {
                return [...this.errorLog];
            },

            /**
             * Limpa histórico de erros
             */
            clearLog() {
                this.errorLog = [];
            },

            /**
             * Mostra notificação toast para o usuário
             */
            notify(message, type = 'unknown') {
                // Remove toast anterior se existir
                const existingToast = document.querySelector('.error-toast');
                if (existingToast) {
                    existingToast.remove();
                }

                // Cores por tipo
                const colors = {
                    network: '#f59e0b',    // Amarelo/laranja
                    database: '#ef4444',   // Vermelho
                    supabase: '#ef4444',   // Vermelho
                    geolocation: '#3b82f6', // Azul
                    validation: '#f59e0b', // Amarelo
                    permission: '#ef4444', // Vermelho
                    timeout: '#f59e0b',    // Amarelo
                    unknown: '#6b7280'     // Cinza
                };

                // Ícones por tipo
                const icons = {
                    network: '<path stroke-linecap="round" stroke-linejoin="round" d="M8.288 15.038a5.25 5.25 0 017.424 0M5.106 11.856c3.807-3.808 9.98-3.808 13.788 0M1.924 8.674c5.565-5.565 14.587-5.565 20.152 0M12.53 18.22l-.53.53-.53-.53a.75.75 0 011.06 0z" />',
                    database: '<path stroke-linecap="round" stroke-linejoin="round" d="M20.25 6.375c0 2.278-3.694 4.125-8.25 4.125S3.75 8.653 3.75 6.375m16.5 0c0-2.278-3.694-4.125-8.25-4.125S3.75 4.097 3.75 6.375m16.5 0v11.25c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125V6.375m16.5 0v3.75m-16.5-3.75v3.75m16.5 0v3.75C20.25 16.153 16.556 18 12 18s-8.25-1.847-8.25-4.125v-3.75m16.5 0c0 2.278-3.694 4.125-8.25 4.125s-8.25-1.847-8.25-4.125" />',
                    supabase: '<path stroke-linecap="round" stroke-linejoin="round" d="M5.25 14.25h13.5m-13.5 0a3 3 0 01-3-3m3 3a3 3 0 100 6h13.5a3 3 0 100-6m-16.5-3a3 3 0 013-3h13.5a3 3 0 013 3m-19.5 0a4.5 4.5 0 01.9-2.7L5.737 5.1a3.375 3.375 0 012.7-1.35h7.126c1.062 0 2.062.5 2.7 1.35l2.587 3.45a4.5 4.5 0 01.9 2.7m0 0a3 3 0 01-3 3m0 3h.008v.008h-.008v-.008zm0-6h.008v.008h-.008v-.008zm-3 6h.008v.008h-.008v-.008zm0-6h.008v.008h-.008v-.008z" />',
                    geolocation: '<path stroke-linecap="round" stroke-linejoin="round" d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z" />',
                    validation: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />',
                    permission: '<path stroke-linecap="round" stroke-linejoin="round" d="M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636" />',
                    timeout: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />',
                    unknown: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" />'
                };

                const color = colors[type] || colors.unknown;
                const icon = icons[type] || icons.unknown;

                // Cria elemento toast
                const toast = document.createElement('div');
                toast.className = 'error-toast';
                toast.innerHTML = `
                    <div class="error-toast-icon" style="color: ${color}">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                            ${icon}
                        </svg>
                    </div>
                    <div class="error-toast-message">${message}</div>
                    <button class="error-toast-close" aria-label="Fechar">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" width="16" height="16">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                `;

                // Adiciona estilos inline para o toast (dark mode aware)
                toast.style.cssText = `
                    position: fixed;
                    bottom: 90px;
                    left: 50%;
                    transform: translateX(-50%) translateY(100px);
                    background: var(--bg-color, #ffffff);
                    color: var(--text-color, #1f2937);
                    border: 1px solid var(--border-color, #e5e7eb);
                    border-left: 4px solid ${color};
                    padding: 12px 16px;
                    border-radius: 8px;
                    box-shadow: 0 10px 25px rgba(0,0,0,0.15);
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    max-width: 90%;
                    width: 360px;
                    z-index: 10000;
                    font-size: 14px;
                    opacity: 0;
                    transition: all 0.3s ease;
                `;

                document.body.appendChild(toast);

                // Botão fechar
                toast.querySelector('.error-toast-close').addEventListener('click', () => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(-50%) translateY(100px)';
                    setTimeout(() => toast.remove(), 300);
                });

                // Anima entrada
                requestAnimationFrame(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(-50%) translateY(0)';
                });

                // Auto-remove após 5 segundos
                ResourceRegistry.setTimeout(() => {
                    if (toast.parentNode) {
                        toast.style.opacity = '0';
                        toast.style.transform = 'translateX(-50%) translateY(100px)';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, 5000, 'error-toast-timeout');
            },

            /**
             * Wrapper para try-catch com tratamento automático
             * @param {Function} fn - Função a ser executada
             * @param {Object} context - Contexto para o erro
             * @param {Object} options - Opções de tratamento
             */
            async tryAsync(fn, context = {}, options = {}) {
                try {
                    return await fn();
                } catch (error) {
                    this.handle(error, context, options);
                    return options.fallback !== undefined ? options.fallback : null;
                }
            },

            /**
             * Versão síncrona do wrapper
             */
            trySync(fn, context = {}, options = {}) {
                try {
                    return fn();
                } catch (error) {
                    this.handle(error, context, options);
                    return options.fallback !== undefined ? options.fallback : null;
                }
            }
        };

        // Sync pending clients to Supabase
        // CORREÇÃO: Usa estratégia de upsert mais segura para evitar race conditions
        // Retorna array de endereços que foram sincronizados com sucesso
        async function syncPendingClients() {
            const syncedAddresses = [];
            try {
                const pendingClients = await getPendingFromOfflineDB('pendingClients');
                if (pendingClients.length === 0) return syncedAddresses;

                // Processa cada cliente individualmente (INSERT ou UPDATE)
                for (const pendingClient of pendingClients) {
                    try {
                        // Validação básica
                        if (!pendingClient.address || pendingClient.latitude === undefined || pendingClient.longitude === undefined) {
                            console.warn('[SYNC] Cliente inválido, pulando:', pendingClient);
                            // Remove item inválido da fila
                            if (pendingClient.localId) {
                                await deleteSyncedFromOfflineDB('pendingClients', pendingClient.localId);
                            }
                            continue;
                        }

                        const clientData = {
                            address: pendingClient.address,
                            bairro: pendingClient.bairro || null,
                            city: pendingClient.city || null,
                            zipcode: pendingClient.zipcode || null,
                            latitude: pendingClient.latitude,
                            longitude: pendingClient.longitude
                        };

                        let syncSuccess = false;

                        // CORREÇÃO: Estratégia INSERT-first com fallback para UPDATE
                        // Isso é mais seguro contra race conditions do que SELECT + INSERT/UPDATE
                        // 1. Tenta INSERT primeiro
                        const { error: insertError } = await db
                            .from('clients')
                            .insert(clientData);

                        if (!insertError) {
                            // INSERT bem-sucedido
                            syncSuccess = true;
                        } else {
                            // Se INSERT falhou, pode ser duplicata ou outro erro
                            // Verifica se é erro de duplicata (constraint violation ou registro já existe)
                            const errorMsg = (insertError.message || insertError.code || '').toLowerCase();
                            const isDuplicateError = errorMsg.includes('duplicate') ||
                                                     errorMsg.includes('unique') ||
                                                     errorMsg.includes('already exists') ||
                                                     errorMsg.includes('23505'); // PostgreSQL unique_violation code

                            if (isDuplicateError) {
                                // 2. Fallback: Tenta UPDATE se INSERT falhou por duplicata
                                const { error: updateError } = await db
                                    .from('clients')
                                    .update({
                                        bairro: clientData.bairro,
                                        city: clientData.city,
                                        zipcode: clientData.zipcode,
                                        latitude: clientData.latitude,
                                        longitude: clientData.longitude
                                    })
                                    .eq('address', pendingClient.address);

                                if (!updateError) {
                                    syncSuccess = true;
                                } else {
                                    console.error('[SYNC] Erro no UPDATE após INSERT falhar:', updateError);
                                }
                            } else {
                                // Outro tipo de erro no INSERT
                                console.error('[SYNC] Erro no INSERT:', insertError);
                            }
                        }

                        if (syncSuccess) {
                            // Remove do pendingClients
                            if (pendingClient.localId) {
                                await deleteSyncedFromOfflineDB('pendingClients', pendingClient.localId);
                            }
                            syncedAddresses.push(pendingClient.address);
                        }

                        // Cede controle para não travar UI
                        await yieldToMain();

                    } catch (clientErr) {
                        console.error('[SYNC] Erro ao sincronizar cliente:', pendingClient.address, clientErr);
                        // Mantém pendente para próxima tentativa
                    }
                }
            } catch (err) {
                console.error('[SYNC] Erro ao obter clientes pendentes:', err);
            }
            return syncedAddresses;
        }

        // Sync pending planilha data to Supabase
        // CORREÇÃO: Processa individualmente para tratar duplicatas e erros parciais
        // Retorna array de endereços que foram sincronizados com sucesso
        async function syncPendingPlanilha() {
            const syncedAddresses = [];
            try {
                const pendingPlanilha = await getPendingFromOfflineDB('pendingPlanilha');
                if (pendingPlanilha.length === 0) return syncedAddresses;

                // CORREÇÃO: Processa cada item individualmente para melhor tratamento de erros
                for (let i = 0; i < pendingPlanilha.length; i++) {
                    const item = pendingPlanilha[i];

                    // Validação básica
                    if (!item.destination_address) {
                        console.warn('[SYNC] Item de planilha sem destination_address, removendo:', item);
                        if (item.localId) {
                            await deleteSyncedFromOfflineDB('pendingPlanilha', item.localId);
                        }
                        continue;
                    }

                    try {
                        const planilhaData = {
                            destination_address: item.destination_address,
                            latitude: item.latitude,
                            longitude: item.longitude,
                            sequence: item.sequence,
                            stop: item.stop,
                            delivery_status: item.delivery_status || 'pending',
                            spx_tn: item.spx_tn,
                            bairro: item.bairro,
                            city: item.city
                        };

                        // CORREÇÃO: Estratégia INSERT-first com fallback para UPDATE
                        const { error: insertError } = await db
                            .from('planilha')
                            .insert(planilhaData);

                        let syncSuccess = false;

                        if (!insertError) {
                            syncSuccess = true;
                        } else {
                            // Verifica se é erro de duplicata
                            const errorMsg = (insertError.message || insertError.code || '').toLowerCase();
                            const isDuplicateError = errorMsg.includes('duplicate') ||
                                                     errorMsg.includes('unique') ||
                                                     errorMsg.includes('already exists') ||
                                                     errorMsg.includes('23505');

                            if (isDuplicateError) {
                                // Fallback: UPDATE se já existe
                                const { error: updateError } = await db
                                    .from('planilha')
                                    .update({
                                        latitude: planilhaData.latitude,
                                        longitude: planilhaData.longitude,
                                        sequence: planilhaData.sequence,
                                        stop: planilhaData.stop,
                                        delivery_status: planilhaData.delivery_status,
                                        spx_tn: planilhaData.spx_tn,
                                        bairro: planilhaData.bairro,
                                        city: planilhaData.city
                                    })
                                    .eq('destination_address', item.destination_address);

                                if (!updateError) {
                                    syncSuccess = true;
                                } else {
                                    console.error('[SYNC] Erro no UPDATE de planilha:', updateError);
                                }
                            } else {
                                console.error('[SYNC] Erro no INSERT de planilha:', insertError);
                            }
                        }

                        if (syncSuccess) {
                            await deleteSyncedFromOfflineDB('pendingPlanilha', item.localId);
                            syncedAddresses.push(item.destination_address);
                        }

                    } catch (itemErr) {
                        console.error('[SYNC] Erro ao sincronizar item de planilha:', item.destination_address, itemErr);
                    }

                    // Cede controle a cada 5 itens
                    if (i > 0 && i % 5 === 0) {
                        await yieldToMain();
                    }
                }
            } catch (err) {
                console.error('[SYNC] Erro ao obter planilha pendente:', err);
            }
            return syncedAddresses;
        }

        // Sync pending delivery status updates to Supabase - BATCH OPTIMIZED
        // CORREÇÃO: Trata sincronização parcial corretamente e valida item.ids
        // Agrupa por status para fazer menos chamadas ao banco
        // Retorna objeto com IDs sincronizados por status: { delivered: [ids], pending: [ids], ... }
        async function syncPendingDeliveryStatus() {
            const syncedStatusChanges = {};
            try {
                const pendingStatus = await getPendingFromOfflineDB('pendingDeliveryStatus');
                if (pendingStatus.length === 0) return syncedStatusChanges;

                // BATCH: Agrupa todos os IDs por status
                // CORREÇÃO: Também rastreia quais localIds correspondem a quais IDs
                const statusGroups = new Map(); // status -> { idToLocalId: Map, allLocalIds: [] }

                for (const item of pendingStatus) {
                    // CORREÇÃO: Valida item.ids antes de usar spread
                    if (!item.ids || !Array.isArray(item.ids) || item.ids.length === 0) {
                        console.warn('[SYNC] Item de status inválido (sem ids), removendo:', item);
                        // Remove item inválido da fila
                        if (item.localId) {
                            await deleteSyncedFromOfflineDB('pendingDeliveryStatus', item.localId);
                        }
                        continue;
                    }

                    if (!item.status) {
                        console.warn('[SYNC] Item de status sem status definido, removendo:', item);
                        if (item.localId) {
                            await deleteSyncedFromOfflineDB('pendingDeliveryStatus', item.localId);
                        }
                        continue;
                    }

                    if (!statusGroups.has(item.status)) {
                        statusGroups.set(item.status, {
                            ids: [],
                            localIds: [],
                            // CORREÇÃO: Mapeia cada ID para seu localId de origem
                            idToLocalIdMap: new Map()
                        });
                    }
                    const group = statusGroups.get(item.status);

                    // Adiciona IDs e mapeia para o localId de origem
                    for (const id of item.ids) {
                        group.ids.push(id);
                        // Guarda referência de qual localId este ID veio
                        if (!group.idToLocalIdMap.has(item.localId)) {
                            group.idToLocalIdMap.set(item.localId, []);
                        }
                        group.idToLocalIdMap.get(item.localId).push(id);
                    }
                    group.localIds.push(item.localId);
                }

                // BATCH: Uma chamada por status (ao invés de uma por item)
                let groupIndex = 0;
                for (const [status, group] of statusGroups) {
                    // Cede controle entre grupos
                    if (groupIndex > 0) {
                        await yieldToMain();
                    }
                    groupIndex++;

                    try {
                        // Divide IDs em chunks para evitar cláusula IN muito grande
                        const idChunks = chunkArray(group.ids, BATCH_IDS_SIZE);
                        const successfulIds = []; // CORREÇÃO: Rastreia quais IDs foram sincronizados
                        const failedChunks = [];

                        for (let i = 0; i < idChunks.length; i++) {
                            const idChunk = idChunks[i];
                            try {
                                const { error } = await db
                                    .from('planilha')
                                    .update({ delivery_status: status })
                                    .in('id', idChunk);

                                if (error) {
                                    console.error('[SYNC] Erro ao atualizar status chunk', i, ':', error);
                                    failedChunks.push(i);
                                } else {
                                    // CORREÇÃO: Marca estes IDs como sincronizados
                                    successfulIds.push(...idChunk);
                                }
                            } catch (chunkErr) {
                                console.error('[SYNC] Exceção no chunk', i, ':', chunkErr);
                                failedChunks.push(i);
                            }
                        }

                        // CORREÇÃO: Processa resultado parcial
                        if (successfulIds.length > 0) {
                            // Adiciona IDs sincronizados ao resultado
                            if (!syncedStatusChanges[status]) {
                                syncedStatusChanges[status] = [];
                            }
                            syncedStatusChanges[status].push(...successfulIds);

                            // CORREÇÃO: Só deleta localIds cujos TODOS os IDs foram sincronizados
                            const successfulIdSet = new Set(successfulIds);
                            for (const localId of group.localIds) {
                                const idsFromThisLocal = group.idToLocalIdMap.get(localId) || [];
                                const allIdsSynced = idsFromThisLocal.every(id => successfulIdSet.has(id));

                                if (allIdsSynced && idsFromThisLocal.length > 0) {
                                    await deleteSyncedFromOfflineDB('pendingDeliveryStatus', localId);
                                }
                            }
                        }

                        // Log de resultado
                        if (failedChunks.length > 0) {
                            console.warn('[SYNC] Sincronização parcial de status', status,
                                         '- Sucesso:', successfulIds.length,
                                         '- Falhas em chunks:', failedChunks.length);
                        }
                    } catch (err) {
                        console.error('[SYNC] Erro na sincronização do status', status, ':', err);
                    }
                }
            } catch (err) {
                console.error('[SYNC] Erro ao obter status pendentes:', err);
            }
            return syncedStatusChanges;
        }

        // Sync pending similarity overrides to Supabase - BATCH OPTIMIZED
        // CORREÇÃO: Adiciona validação de item.ids e logs de erro
        // Agrupa overrides com mesmos parâmetros para fazer menos chamadas
        // Retorna true se houve alterações sincronizadas
        async function syncPendingSimilarityOverrides() {
            let hadChanges = false;
            try {
                const pendingOverrides = await getPendingFromOfflineDB('pendingSimilarityOverrides');
                if (pendingOverrides.length === 0) return hadChanges;

                // BATCH: Agrupa por parâmetros de similarity (disabled + coords)
                const overrideGroups = new Map(); // key -> { ids: [], localIds: [], params: {} }

                for (const item of pendingOverrides) {
                    // CORREÇÃO: Valida item.ids antes de usar spread
                    if (!item.ids || !Array.isArray(item.ids) || item.ids.length === 0) {
                        console.warn('[SYNC] Override inválido (sem ids), removendo:', item);
                        if (item.localId) {
                            await deleteSyncedFromOfflineDB('pendingSimilarityOverrides', item.localId);
                        }
                        continue;
                    }

                    // Cria chave única para agrupamento baseada nos parâmetros
                    const key = `${item.similarity_disabled}_${item.similarity_original_lat}_${item.similarity_original_lng}`;

                    if (!overrideGroups.has(key)) {
                        overrideGroups.set(key, {
                            ids: [],
                            localIds: [],
                            params: {
                                similarity_disabled: item.similarity_disabled,
                                similarity_original_lat: item.similarity_original_lat,
                                similarity_original_lng: item.similarity_original_lng
                            }
                        });
                    }
                    const group = overrideGroups.get(key);
                    group.ids.push(...item.ids);
                    group.localIds.push(item.localId);
                }

                // BATCH: Uma chamada por grupo de parâmetros
                let groupIndex = 0;
                for (const [key, group] of overrideGroups) {
                    // Cede controle entre grupos
                    if (groupIndex > 0) {
                        await yieldToMain();
                    }
                    groupIndex++;

                    try {
                        // Divide IDs em chunks
                        const idChunks = chunkArray(group.ids, BATCH_IDS_SIZE);
                        let allSuccess = true;

                        for (const idChunk of idChunks) {
                            const { error } = await db
                                .from('planilha')
                                .update(group.params)
                                .in('id', idChunk);

                            if (error) {
                                console.error('[SYNC] Erro ao sincronizar similarity override:', error);
                                allSuccess = false;
                                break;
                            }
                        }

                        if (allSuccess) {
                            for (const localId of group.localIds) {
                                await deleteSyncedFromOfflineDB('pendingSimilarityOverrides', localId);
                            }
                            hadChanges = true;
                        }
                    } catch (err) {
                        console.error('[SYNC] Erro na sincronização do grupo de similarity:', key, err);
                    }
                }
            } catch (err) {
                console.error('[SYNC] Erro ao obter overrides pendentes:', err);
            }
            return hadChanges;
        }

        // Sync pending deletes to Supabase
        // CORREÇÃO: Filtra IDs temporários que nunca existiram no Supabase
        async function syncPendingDeletes() {
            const deletedIds = [];
            try {
                const pendingDeletes = await getPendingFromOfflineDB('pendingDeletes');
                if (pendingDeletes.length === 0) return deletedIds;

                for (const item of pendingDeletes) {
                    try {
                        // CORREÇÃO: Valida clientId
                        if (!item.clientId) {
                            console.warn('[SYNC] Item de delete sem clientId, removendo:', item);
                            if (item.localId) {
                                await deleteSyncedFromOfflineDB('pendingDeletes', item.localId);
                            }
                            continue;
                        }

                        // CORREÇÃO: Verifica se é um ID temporário (criado offline, nunca sincronizado)
                        // IDs temporários começam com 'new_', 'pending_', 'temp_' ou são strings não-numéricas
                        const clientIdStr = String(item.clientId);
                        const isTemporaryId = clientIdStr.startsWith('new_') ||
                                              clientIdStr.startsWith('pending_') ||
                                              clientIdStr.startsWith('temp_') ||
                                              (isNaN(Number(item.clientId)) && !clientIdStr.includes('-')); // UUID tem hífens

                        if (isTemporaryId) {
                            // ID temporário - nunca existiu no Supabase, apenas remove da fila
                            console.log('[SYNC] ID temporário detectado, removendo da fila sem chamar Supabase:', item.clientId);
                            await deleteSyncedFromOfflineDB('pendingDeletes', item.localId);
                            deletedIds.push(item.clientId);
                            continue;
                        }

                        const { error } = await db
                            .from('clients')
                            .delete()
                            .eq('id', item.clientId);

                        if (error) {
                            // Verifica se é erro de "não encontrado" ou similar
                            const errorMsg = (error.message || error.code || '').toLowerCase();
                            const isNotFoundError = errorMsg.includes('not found') ||
                                                    errorMsg.includes('no rows') ||
                                                    errorMsg.includes('does not exist');

                            if (isNotFoundError) {
                                // Registro já não existe - considera como sucesso
                                console.log('[SYNC] Cliente já deletado ou não existe:', item.clientId);
                            } else {
                                // Outro erro - mantém na fila para retry
                                console.error('[SYNC] Erro ao deletar cliente:', item.clientId, error);
                                continue;
                            }
                        }

                        // Remove da fila de pendentes
                        await deleteSyncedFromOfflineDB('pendingDeletes', item.localId);
                        deletedIds.push(item.clientId);

                    } catch (err) {
                        console.error('[SYNC] Erro ao sincronizar exclusão:', item.clientId, err);
                    }
                }
            } catch (err) {
                console.error('[SYNC] Erro ao obter exclusões pendentes:', err);
            }
            return deletedIds;
        }

        // Main sync function - syncs all pending data
        // Retorna objeto com o que foi sincronizado para atualização incremental
        async function syncAllPendingData() {
            const syncResult = {
                syncedClientAddresses: [],
                syncedPlanilhaAddresses: [],
                syncedStatusChanges: {},
                syncedSimilarityChanges: false,
                syncedDeletedIds: [],
                hadChanges: false
            };

            if (!isOnline || isSyncing) return syncResult;

            isSyncing = true;

            // BLOQUEIO: Ativa flag para impedir que syncs do servidor sobrescrevam dados locais
            // Isso é crucial para evitar piscada quando dispositivo volta online
            isSyncingPendingData = true;
            // Também marca timestamp para proteção adicional
            lastRouteMarkersSave = Date.now();

            updateOfflineIndicator();

            try {
                // PERFORMANCE: Usa longYield entre syncs para não travar o mapa durante interação
                const clientAddresses = await syncPendingClients();
                syncResult.syncedClientAddresses = clientAddresses || [];
                await longYield();

                const planilhaAddresses = await syncPendingPlanilha();
                syncResult.syncedPlanilhaAddresses = planilhaAddresses || [];
                await longYield();

                const statusChanges = await syncPendingDeliveryStatus();
                syncResult.syncedStatusChanges = statusChanges || {};
                await longYield();

                // Sync similarity overrides
                const similarityChanges = await syncPendingSimilarityOverrides();
                syncResult.syncedSimilarityChanges = similarityChanges || false;
                await longYield();

                // Sync pending deletes
                const deletedIds = await syncPendingDeletes();
                syncResult.syncedDeletedIds = deletedIds || [];
                await longYield();

                // Verifica se houve alguma mudança
                syncResult.hadChanges =
                    syncResult.syncedClientAddresses.length > 0 ||
                    syncResult.syncedPlanilhaAddresses.length > 0 ||
                    Object.keys(syncResult.syncedStatusChanges).length > 0 ||
                    syncResult.syncedSimilarityChanges ||
                    syncResult.syncedDeletedIds.length > 0;

                // IMPORTANTE: Se houve mudanças de status OU similarity, atualiza o route_markers_cache no Supabase
                // Isso garante que outros dispositivos recebam as alterações via polling de versão
                const hasStatusOrSimilarityChanges = Object.keys(syncResult.syncedStatusChanges).length > 0 || syncResult.syncedSimilarityChanges;
                if (hasStatusOrSimilarityChanges && map && map.getSource('route-stops')) {
                    try {
                        const source = map.getSource('route-stops');
                        if (source && source._data) {
                            const currentGeojson = source._data;
                            const features = currentGeojson.features || [];
                            const stats = {
                                total: features.filter(f => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                registered: features.filter(f => f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                unregistered: features.filter(f => !f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                pending: features.reduce((sum, f) => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered' ? sum + (f.properties.packageCount || 1) : sum, 0),
                                delivered: features.reduce((sum, f) => f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered' ? sum + (f.properties.packageCount || 1) : sum, 0)
                            };
                            // Salva no Supabase com nova versão para outros dispositivos detectarem
                            await _doSaveRouteMarkersToSupabase(currentGeojson, stats);
                            console.log('☁️ route_markers_cache atualizado após sync de status offline');
                        }
                    } catch (cacheErr) {
                        console.log('⚠️ Erro ao atualizar route_markers_cache após sync:', cacheErr);
                    }
                }

                // Update pending count
                updateOfflineIndicator();

                // Log de sucesso
                if (syncResult.hadChanges) {
                    console.log('[SYNC] Sincronização concluída com sucesso:',
                        'Clientes:', syncResult.syncedClientAddresses.length,
                        'Planilha:', syncResult.syncedPlanilhaAddresses.length,
                        'Status:', Object.keys(syncResult.syncedStatusChanges).length,
                        'Deletes:', syncResult.syncedDeletedIds.length
                    );
                }

            } catch (error) {
                // CORREÇÃO: Log de erro para debug
                console.error('[SYNC] Erro durante sincronização geral:', error);
            } finally {
                isSyncing = false;
                // DESBLOQUEIO: Libera syncs do servidor após terminar de enviar dados offline
                isSyncingPendingData = false;
                // Atualiza timestamp novamente para garantir proteção por mais 2s
                lastRouteMarkersSave = Date.now();
                updateOfflineIndicator();
            }

            return syncResult;
        }

        // PERFORMANCE: Atualiza apenas os marcadores de rota que tiveram status alterado
        // Em vez de recarregar todos os marcadores, só atualiza as cores/dados dos afetados
        function updateRouteMarkersStatus(statusChanges) {
            if (!map || !map.getSource || !map.getSource('route-stops')) return;

            try {
                const source = map.getSource('route-stops');
                const currentData = source._data;
                if (!currentData || !currentData.features) return;

                // Cria mapa de ID -> novo status
                const idToStatus = {};
                for (const [status, ids] of Object.entries(statusChanges)) {
                    for (const id of ids) {
                        idToStatus[id] = status;
                    }
                }

                // Se não há alterações, retorna
                if (Object.keys(idToStatus).length === 0) return;

                // Atualiza apenas os features afetados
                let updated = false;
                const updatedFeatures = currentData.features.map(feature => {
                    const featureId = feature.properties.id;
                    if (idToStatus[featureId] !== undefined) {
                        updated = true;
                        // Cria novo objeto com status atualizado
                        return {
                            ...feature,
                            properties: {
                                ...feature.properties,
                                delivery_status: idToStatus[featureId],
                                color: idToStatus[featureId] === 'delivered' ? '#10B981' :
                                       idToStatus[featureId] === 'cancelled' ? '#EF4444' : '#F59E0B'
                            }
                        };
                    }
                    return feature;
                });

                // Só atualiza o mapa se houve mudanças reais
                if (updated) {
                    const newGeojson = {
                        type: 'FeatureCollection',
                        features: updatedFeatures
                    };
                    source.setData(newGeojson);

                    // Also update the cached route markers
                    try {
                        const statsToSave = {
                            total: updatedFeatures.filter(f => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                            registered: updatedFeatures.filter(f => f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                            unregistered: updatedFeatures.filter(f => !f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                            pending: updatedFeatures.reduce((sum, f) => {
                                if (f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered') {
                                    return sum + (f.properties.packageCount || 1);
                                }
                                return sum;
                            }, 0),
                            delivered: updatedFeatures.reduce((sum, f) => {
                                if (f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered') {
                                    return sum + (f.properties.packageCount || 1);
                                }
                                return sum;
                            }, 0)
                        };
                        saveRouteMarkersToCache(newGeojson, statsToSave);
                    } catch (cacheErr) {
                        // Silently fail - cache update is not critical
                    }
                }
            } catch (err) {
                // Erro ao atualizar marcadores - falha silenciosa
            }
        }

        // PERFORMANCE: Adiciona novos clientes ao cache e marcadores sem recarregar tudo
        async function addSyncedClientsToCache(syncedAddresses) {
            if (!syncedAddresses || syncedAddresses.length === 0) return;

            try {
                // Busca apenas os clientes recém-sincronizados do Supabase
                const { data: newClients, error } = await db
                    .from('clients')
                    .select('id, address, bairro, city, zipcode, latitude, longitude')
                    .in('address', syncedAddresses);

                if (error || !newClients || newClients.length === 0) return;

                // Atualiza o cache em memória (substitui registros com ID temporário)
                if (clientesCache.data) {
                    for (const newClient of newClients) {
                        const existingIdx = clientesCache.data.findIndex(c => c.address === newClient.address);
                        if (existingIdx !== -1) {
                            // Atualiza registro existente com dados do Supabase (ID real)
                            clientesCache.data[existingIdx] = { ...clientesCache.data[existingIdx], ...newClient };
                        } else {
                            // Adiciona novo
                            clientesCache.data.unshift(newClient);
                        }
                    }
                    clientesCache.timestamp = Date.now();
                }

                // Atualiza allClientes (substitui registros com ID temporário)
                if (allClientes) {
                    for (const newClient of newClients) {
                        const existingIdx = allClientes.findIndex(c => c.address === newClient.address);
                        if (existingIdx !== -1) {
                            // Atualiza registro existente com dados do Supabase (ID real)
                            allClientes[existingIdx] = { ...allClientes[existingIdx], ...newClient };
                        } else {
                            // Adiciona novo
                            allClientes.unshift(newClient);
                        }
                    }
                }

                // Atualiza o IndexedDB cache (substitui registros com ID temporário)
                const cachedClients = await getAllFromOfflineDB('cachedClients');
                if (cachedClients) {
                    let updated = false;
                    for (const newClient of newClients) {
                        const existingIdx = cachedClients.findIndex(c => c.address === newClient.address);
                        if (existingIdx !== -1) {
                            cachedClients[existingIdx] = { ...cachedClients[existingIdx], ...newClient };
                            updated = true;
                        } else {
                            cachedClients.unshift(newClient);
                            updated = true;
                        }
                    }
                    if (updated) {
                        await saveCacheToDB('cachedClients', cachedClients);
                    }
                }

                // Atualiza marcadores de clientes se estiverem visíveis
                if (markersVisible && map && map.getSource && map.getSource('clientes')) {
                    const source = map.getSource('clientes');
                    const currentData = source._data;
                    if (currentData && currentData.features) {
                        // Adiciona novos features
                        const existingIds = new Set(currentData.features.map(f => f.properties.id));
                        const newFeatures = newClients
                            .filter(c => c.latitude && c.longitude && !existingIds.has(c.id))
                            .map(cliente => ({
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [cliente.longitude, cliente.latitude]
                                },
                                properties: {
                                    id: cliente.id,
                                    address: cliente.address,
                                    latitude: cliente.latitude,
                                    longitude: cliente.longitude
                                }
                            }));

                        if (newFeatures.length > 0) {
                            source.setData({
                                type: 'FeatureCollection',
                                features: [...currentData.features, ...newFeatures]
                            });
                        }
                    }
                }

                // Re-renderiza a lista de clientes na UI
                if (allClientes && allClientes.length > 0) {
                    renderClientes(allClientes);
                }

                // IMPORTANTE: Atualiza marcadores de rota (vermelho → verde) para clientes sincronizados
                if (map && map.getSource && map.getSource('route-stops')) {
                    for (const client of newClients) {
                        if (client.latitude && client.longitude) {
                            await updateRouteMarkerForNewClient(client);
                        }
                    }
                }
            } catch (err) {
                // Erro ao adicionar clientes - falha silenciosa
            }
        }

        // PERFORMANCE: Adiciona novos itens de planilha ao cache sem recarregar tudo
        async function addSyncedPlanilhaToCache(syncedAddresses) {
            if (!syncedAddresses || syncedAddresses.length === 0) return;

            try {
                // Busca apenas os itens recém-sincronizados do Supabase
                const { data: newItems, error } = await db
                    .from('planilha')
                    .select('id, sequence, destination_address, bairro, city, zipcode, latitude, longitude, spx_tn, stop, delivery_status')
                    .in('destination_address', syncedAddresses);

                if (error || !newItems || newItems.length === 0) return;

                // Atualiza o IndexedDB cache incrementalmente
                const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                if (cachedPlanilha) {
                    const existingAddresses = new Set(cachedPlanilha.map(c => c.destination_address));
                    const toAdd = newItems.filter(c => !existingAddresses.has(c.destination_address));
                    if (toAdd.length > 0) {
                        await saveCacheToDB('cachedPlanilha', [...cachedPlanilha, ...toAdd]);
                    }
                }

                // Se os marcadores de rota estiverem visíveis, atualiza incrementalmente
                if (routeMarkersVisible && map && map.getSource && map.getSource('route-stops')) {
                    // Só adicionamos os que já têm coordenadas
                    const source = map.getSource('route-stops');
                    const currentData = source._data;
                    if (currentData && currentData.features) {
                        const existingAddresses = new Set(
                            currentData.features.map(f => f.properties.destination_address)
                        );
                        const newFeatures = newItems
                            .filter(item => item.latitude && item.longitude &&
                                   !existingAddresses.has(item.destination_address))
                            .map(item => ({
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [item.longitude, item.latitude]
                                },
                                properties: {
                                    id: item.id,
                                    destination_address: item.destination_address,
                                    sequence: item.sequence,
                                    stop: item.stop,
                                    delivery_status: item.delivery_status || 'pending',
                                    bairro: item.bairro,
                                    city: item.city,
                                    spx_tn: item.spx_tn,
                                    color: item.delivery_status === 'delivered' ? '#10B981' :
                                           item.delivery_status === 'cancelled' ? '#EF4444' : '#F59E0B'
                                }
                            }));

                        if (newFeatures.length > 0) {
                            source.setData({
                                type: 'FeatureCollection',
                                features: [...currentData.features, ...newFeatures]
                            });
                        }
                    }
                }
            } catch (err) {
                // Erro ao adicionar planilha - falha silenciosa
            }
        }

        // Função para sincronização manual (click no indicador offline)
        // Faz sync e atualização incremental dos dados
        async function manualSync() {
            if (!isOnline || isSyncing) return;

            try {
                // Sincroniza e obtém o que foi alterado
                const syncResult = await syncAllPendingData();

                // Se houve mudanças, faz atualização incremental
                if (syncResult.hadChanges) {
                    // Atualiza clientes sincronizados
                    if (syncResult.syncedClientAddresses.length > 0) {
                        await addSyncedClientsToCache(syncResult.syncedClientAddresses);
                    }

                    // Atualiza planilha sincronizada
                    if (syncResult.syncedPlanilhaAddresses.length > 0) {
                        await addSyncedPlanilhaToCache(syncResult.syncedPlanilhaAddresses);
                    }

                    // Atualiza status dos marcadores
                    if (Object.keys(syncResult.syncedStatusChanges).length > 0) {
                        updateRouteMarkersStatus(syncResult.syncedStatusChanges);
                    }
                }
            } catch (err) {
                // Sync falhou silenciosamente
            }
        }

        // Update offline indicator UI
        async function updateOfflineIndicator() {
            const indicator = document.getElementById('offlineIndicator');
            const badge = document.getElementById('offlineBadge');

            if (!indicator) return;

            try {
                const pendingClients = await countPendingItems('pendingClients');
                const pendingPlanilha = await countPendingItems('pendingPlanilha');
                const pendingStatus = await countPendingItems('pendingDeliveryStatus');
                const pendingDeletes = await countPendingItems('pendingDeletes');
                const totalPending = pendingClients + pendingPlanilha + pendingStatus + pendingDeletes;

                if (!isOnline) {
                    indicator.classList.add('offline');
                    indicator.classList.remove('syncing');
                    indicator.title = `Offline - ${totalPending} item(s) pendente(s)`;
                } else if (isSyncing) {
                    indicator.classList.remove('offline');
                    indicator.classList.add('syncing');
                    indicator.title = 'Sincronizando...';
                } else {
                    indicator.classList.remove('offline', 'syncing');
                    indicator.title = totalPending > 0 ? `${totalPending} item(s) para sincronizar` : 'Online';
                }

                if (badge) {
                    badge.textContent = totalPending;
                    badge.style.display = totalPending > 0 ? 'flex' : 'none';
                }
            } catch (err) {
                // Erro ao atualizar indicador
            }
        }

        // Listen for online/offline events
        window.addEventListener('online', () => {
            isOnline = true;
            updateOfflineIndicator();

            // BLOQUEIO IMEDIATO: Marca timestamp para impedir syncs do servidor
            // de sobrescreverem dados locais antes de enviarmos os pendentes
            if (typeof lastRouteMarkersSave !== 'undefined') {
                lastRouteMarkersSave = Date.now();
            }

            // PERFORMANCE: Sincronização otimizada - só atualiza o que mudou
            // Não baixa tudo novamente, não recarrega todos os marcadores
            const performOnlineSync = async () => {
                try {
                    // Step 1: Verifica se há dados pendentes antes de sincronizar
                    const pendingClients = await countPendingItems('pendingClients');
                    const pendingPlanilha = await countPendingItems('pendingPlanilha');
                    const pendingStatus = await countPendingItems('pendingDeliveryStatus');
                    const hasPendingData = pendingClients > 0 || pendingPlanilha > 0 || pendingStatus > 0;

                    // Step 2: Só sincroniza se houver dados pendentes
                    // syncAllPendingData agora retorna o que foi sincronizado
                    let syncResult = { hadChanges: false };
                    if (hasPendingData) {
                        syncResult = await syncAllPendingData();
                        await longYield();
                    }

                    // Step 3: Atualização INCREMENTAL baseada no que foi sincronizado
                    // NÃO baixa tudo do servidor - só adiciona os novos itens ao cache local

                    if (syncResult.hadChanges) {
                        // Aguarda mapa parar de ser movido antes de atualizar
                        const waitForIdle = () => new Promise(resolve => {
                            const check = () => {
                                if (!isMapInteracting) {
                                    resolve();
                                } else {
                                    setTimeout(check, 200);
                                }
                            };
                            setTimeout(check, 50);
                        });

                        // Step 3a: Atualiza clientes sincronizados (apenas os novos)
                        if (syncResult.syncedClientAddresses.length > 0) {
                            await waitForIdle();
                            await addSyncedClientsToCache(syncResult.syncedClientAddresses);
                            await longYield();
                        }

                        // Step 3b: Atualiza planilha sincronizada (apenas os novos)
                        if (syncResult.syncedPlanilhaAddresses.length > 0) {
                            await waitForIdle();
                            await addSyncedPlanilhaToCache(syncResult.syncedPlanilhaAddresses);
                            await longYield();
                        }

                        // Step 3c: Atualiza status dos marcadores (apenas muda cores, não recarrega)
                        if (Object.keys(syncResult.syncedStatusChanges).length > 0) {
                            await waitForIdle();
                            updateRouteMarkersStatus(syncResult.syncedStatusChanges);
                        }
                    }

                    // Step 4: Sincroniza marcadores de rota com Supabase
                    // Faz merge inteligente entre alterações locais e remotas
                    if (map && map.getSource('route-stops')) {
                        try {
                            const cachedMarkers = await getCachedRouteMarkers();
                            const supabaseMarkers = await loadRouteMarkersFromSupabase();

                            if (cachedMarkers && cachedMarkers.geojson && supabaseMarkers && supabaseMarkers.geojson) {
                                // Merge: combina alterações locais com remotas
                                const mergedGeojson = mergeRouteMarkersGeojson(cachedMarkers.geojson, supabaseMarkers.geojson);

                                // Recalcula stats
                                const features = mergedGeojson.features;
                                const mergedStats = {
                                    total: features.filter(f => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                    registered: features.filter(f => f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                    unregistered: features.filter(f => !f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                                    pending: features.reduce((sum, f) => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered' ? sum + (f.properties.packageCount || 1) : sum, 0),
                                    delivered: features.reduce((sum, f) => f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered' ? sum + (f.properties.packageCount || 1) : sum, 0)
                                };

                                // Salva o merge no Supabase e local
                                await _doSaveRouteMarkersToSupabase(mergedGeojson, mergedStats);
                                await saveRouteMarkersToCache(mergedGeojson, mergedStats, true);

                                // Atualiza o mapa
                                map.getSource('route-stops').setData(mergedGeojson);
                                updateFixedStatsPanel(mergedStats);
                                console.log('✅ Marcadores sincronizados (merge offline/online)');
                            } else if (cachedMarkers && cachedMarkers.geojson) {
                                // Só tem local, envia para Supabase
                                await _doSaveRouteMarkersToSupabase(cachedMarkers.geojson, cachedMarkers.stats);
                            } else if (supabaseMarkers && supabaseMarkers.geojson) {
                                // Só tem remoto, baixa para local
                                await saveRouteMarkersToCache(supabaseMarkers.geojson, supabaseMarkers.stats, true);
                                map.getSource('route-stops').setData(supabaseMarkers.geojson);
                                updateFixedStatsPanel(supabaseMarkers.stats);
                            }
                            await longYield();
                        } catch (e) {
                            console.log('⚠️ Erro ao sincronizar marcadores de rota:', e);
                        }
                    }

                    // Step 5: Inicia refresh periódico (para manter cache atualizado ao longo do tempo)
                    startPeriodicCacheRefresh();

                    // Step 6: Verifica se ainda há pendentes (retry automático)
                    setTimeout(async () => {
                        if (!isOnline) return;
                        const stillPending = await countPendingItems('pendingClients');
                        if (stillPending > 0) {
                            console.log('[SYNC] Ainda há', stillPending, 'clientes pendentes, tentando novamente...');
                            await syncAllPendingData();
                        }
                    }, 10000); // Retry após 10 segundos

                } catch (err) {
                    console.error('[SYNC] Erro na sincronização:', err);
                    // Sync failed, retry after delay
                    setTimeout(async () => {
                        if (isOnline && !isSyncing) {
                            try {
                                await syncAllPendingData();
                            } catch (retryErr) {
                                console.error('[SYNC] Retry também falhou:', retryErr);
                            }
                        }
                    }, 5000);
                    startPeriodicCacheRefresh();
                }
            };

            // Aguarda 1.5s antes de iniciar sync para não competir com reconexão
            setTimeout(() => {
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => performOnlineSync(), { timeout: 5000 });
                } else {
                    performOnlineSync();
                }
            }, 1500);
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateOfflineIndicator();
            // Stop periodic refresh when offline (to save resources)
            stopPeriodicCacheRefresh();
        });

        // Get all data from IndexedDB store (for offline reading)
        function getAllFromOfflineDB(storeName) {
            return new Promise((resolve, reject) => {
                if (!offlineDB) {
                    // Tenta reinicializar IndexedDB se não estiver disponível
                    initOfflineDB().then(() => {
                        if (offlineDB) {
                            getAllFromOfflineDB(storeName).then(resolve).catch(() => resolve([]));
                        } else {
                            resolve([]); // Retorna array vazio em vez de rejeitar
                        }
                    }).catch(() => resolve([]));
                    return;
                }

                try {
                    const transaction = offlineDB.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };

                    request.onerror = () => {
                        resolve([]); // Retorna array vazio em vez de rejeitar
                    };
                } catch (err) {
                    resolve([]); // Retorna array vazio em caso de exceção
                }
            });
        }

        // Busca um registro no cache usando um índice específico
        function getFromCacheByIndex(storeName, indexName, value) {
            return new Promise((resolve, reject) => {
                if (!offlineDB) {
                    // Tenta buscar usando getAllFromOfflineDB como fallback
                    getAllFromOfflineDB(storeName).then(allData => {
                        const found = allData.find(item =>
                            item[indexName] && item[indexName].toString() === value.toString()
                        );
                        resolve(found || null);
                    }).catch(() => resolve(null));
                    return;
                }

                try {
                    const transaction = offlineDB.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);

                    // Verifica se o índice existe
                    if (store.indexNames.contains(indexName)) {
                        const index = store.index(indexName);
                        const request = index.get(value);

                        request.onsuccess = () => {
                            resolve(request.result || null);
                        };

                        request.onerror = () => {
                            // Fallback: busca manual
                            getAllFromOfflineDB(storeName).then(allData => {
                                const found = allData.find(item =>
                                    item[indexName] && item[indexName].toString() === value.toString()
                                );
                                resolve(found || null);
                            }).catch(() => resolve(null));
                        };
                    } else {
                        // Índice não existe, faz busca manual
                        getAllFromOfflineDB(storeName).then(allData => {
                            const found = allData.find(item =>
                                item[indexName] && item[indexName].toString() === value.toString()
                            );
                            resolve(found || null);
                        }).catch(() => resolve(null));
                    }
                } catch (err) {
                    // Fallback em caso de erro
                    getAllFromOfflineDB(storeName).then(allData => {
                        const found = allData.find(item =>
                            item[indexName] && item[indexName].toString() === value.toString()
                        );
                        resolve(found || null);
                    }).catch(() => resolve(null));
                }
            });
        }

        // ============================================
        // CACHE METADATA - Incremental Sync Optimization
        // ============================================

        // Get cache metadata for a specific store
        function getCacheMetadata(storeName) {
            return new Promise((resolve) => {
                if (!offlineDB) {
                    resolve(null);
                    return;
                }

                try {
                    const transaction = offlineDB.transaction(['cacheMetadata'], 'readonly');
                    const store = transaction.objectStore('cacheMetadata');
                    const request = store.get(storeName);

                    request.onsuccess = () => {
                        resolve(request.result || null);
                    };

                    request.onerror = () => {
                        resolve(null);
                    };
                } catch (e) {
                    resolve(null);
                }
            });
        }

        // Save cache metadata for a specific store
        function saveCacheMetadata(storeName, metadata) {
            return new Promise((resolve) => {
                if (!offlineDB) {
                    resolve();
                    return;
                }

                try {
                    const transaction = offlineDB.transaction(['cacheMetadata'], 'readwrite');
                    const store = transaction.objectStore('cacheMetadata');

                    const data = {
                        storeName: storeName,
                        lastSync: Date.now(),
                        count: metadata.count || 0,
                        maxId: metadata.maxId || 0,
                        ...metadata
                    };

                    const request = store.put(data);
                    request.onsuccess = () => resolve();
                    request.onerror = () => resolve();
                } catch (e) {
                    resolve();
                }
            });
        }

        // Get count from Supabase table (fast query)
        async function getSupabaseCount(tableName) {
            try {
                const { count, error } = await db
                    .from(tableName)
                    .select('*', { count: 'exact', head: true });

                if (error) return null;
                return count;
            } catch (e) {
                return null;
            }
        }

        // Get max ID from Supabase table (for incremental sync)
        async function getSupabaseMaxId(tableName) {
            try {
                const { data, error } = await db
                    .from(tableName)
                    .select('id')
                    .order('id', { ascending: false })
                    .limit(1);

                if (error || !data || data.length === 0) return null;
                return data[0].id;
            } catch (e) {
                return null;
            }
        }

        // Check if cache needs refresh (returns: 'full', 'incremental', or 'none')
        async function checkCacheStatus(storeName, tableName) {
            try {
                const metadata = await getCacheMetadata(storeName);
                const currentCount = await getSupabaseCount(tableName);

                if (currentCount === null) {
                    // Supabase unavailable, use cache
                    return { action: 'none', reason: 'offline' };
                }

                if (!metadata) {
                    // No metadata, needs full refresh
                    return { action: 'full', reason: 'no_metadata', serverCount: currentCount };
                }

                const timeSinceLastSync = Date.now() - (metadata.lastSync || 0);
                const FULL_REFRESH_INTERVAL = 30 * 60 * 1000; // 30 minutos para full refresh

                // Se passou muito tempo, força full refresh para pegar updates
                if (timeSinceLastSync > FULL_REFRESH_INTERVAL) {
                    return { action: 'full', reason: 'stale', serverCount: currentCount };
                }

                // Se count é igual e cache recente, não precisa atualizar
                if (currentCount === metadata.count) {
                    return { action: 'none', reason: 'up_to_date', serverCount: currentCount };
                }

                // Count diferente - verifica se só adicionou (incremental) ou precisa full
                if (currentCount > metadata.count) {
                    // Mais registros no servidor - pode ser incremental
                    return {
                        action: 'incremental',
                        reason: 'new_records',
                        serverCount: currentCount,
                        cachedMaxId: metadata.maxId || 0,
                        newRecordsCount: currentCount - metadata.count
                    };
                } else {
                    // Menos registros (deletados) - precisa full refresh
                    return { action: 'full', reason: 'records_deleted', serverCount: currentCount };
                }
            } catch (e) {
                return { action: 'full', reason: 'error' };
            }
        }

        // Merge new records into existing cache (without clearing)
        async function mergeToCacheDB(storeName, newRecords) {
            if (!offlineDB || !newRecords || newRecords.length === 0) return;

            return new Promise((resolve, reject) => {
                try {
                    const transaction = offlineDB.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);

                    let completed = 0;
                    newRecords.forEach(item => {
                        const putRequest = store.put(item);
                        putRequest.onsuccess = () => {
                            completed++;
                            if (completed === newRecords.length) resolve();
                        };
                        putRequest.onerror = () => {
                            completed++;
                            if (completed === newRecords.length) resolve();
                        };
                    });
                } catch (error) {
                    reject(error);
                }
            });
        }

        // Save cache to IndexedDB (replaces all data in cache)
        // Also updates cache metadata for incremental sync optimization
        async function saveCacheToDB(storeName, dataArray) {
            if (!offlineDB) return;

            return new Promise((resolve, reject) => {
                try {
                    const transaction = offlineDB.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);

                    // Clear old cache first
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => {
                        // Add all new data using put (replaces if exists)
                        let completed = 0;
                        if (dataArray.length === 0) {
                            resolve();
                            return;
                        }

                        dataArray.forEach(item => {
                            // Use put instead of add to handle duplicates
                            const putRequest = store.put(item);
                            putRequest.onsuccess = () => {
                                completed++;
                                if (completed === dataArray.length) {
                                    // Após salvar todos, atualiza metadados do cache
                                    updateCacheMetadataAfterSave(storeName, dataArray);
                                    resolve();
                                }
                            };
                            putRequest.onerror = () => {
                                completed++;
                                if (completed === dataArray.length) {
                                    resolve();
                                }
                            };
                        });
                    };
                    clearRequest.onerror = () => reject(clearRequest.error);

                } catch (error) {
                    reject(error);
                }
            });
        }

        // Helper: Atualiza metadados após save completo
        async function updateCacheMetadataAfterSave(storeName, dataArray) {
            if (!dataArray || dataArray.length === 0) return;

            try {
                // Encontra o maior ID nos dados salvos
                const maxId = Math.max(...dataArray.filter(item => item.id).map(item => item.id));

                await saveCacheMetadata(storeName, {
                    count: dataArray.length,
                    maxId: maxId || 0
                });
            } catch (e) {
                // Silently fail - não é crítico
            }
        }

        // Save route markers GeoJSON to cache (for persistence across page reloads)
        // Also saves to Supabase for cross-device sync when online (unless skipSupabase is true)
        async function saveRouteMarkersToCache(geojson, stats, skipSupabase = false) {
            if (!offlineDB) return;

            // Save to local IndexedDB
            await new Promise((resolve, reject) => {
                try {
                    const transaction = offlineDB.transaction(['cachedRouteMarkers'], 'readwrite');
                    const store = transaction.objectStore('cachedRouteMarkers');

                    // Clear old cache first
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => {
                        // Save GeoJSON with metadata
                        const data = {
                            id: 'route-markers-data',
                            geojson: geojson,
                            stats: stats,
                            savedAt: new Date().toISOString()
                        };

                        const putRequest = store.put(data);
                        putRequest.onsuccess = () => resolve();
                        putRequest.onerror = () => reject(putRequest.error);
                    };
                    clearRequest.onerror = () => reject(clearRequest.error);

                } catch (error) {
                    reject(error);
                }
            });

            // Also save to Supabase for cross-device sync (non-blocking)
            // Skip if data came from Supabase to avoid infinite loop
            if (isOnline && !skipSupabase) {
                saveRouteMarkersToSupabase(geojson, stats).catch(() => {});
            }
        }

        // Load cached route markers
        async function getCachedRouteMarkers() {
            if (!offlineDB) return null;

            return new Promise((resolve, reject) => {
                try {
                    const transaction = offlineDB.transaction(['cachedRouteMarkers'], 'readonly');
                    const store = transaction.objectStore('cachedRouteMarkers');
                    const request = store.get('route-markers-data');

                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);

                } catch (error) {
                    reject(error);
                }
            });
        }

        // Clear route markers cache (called when new spreadsheet is uploaded)
        async function clearRouteMarkersCache() {
            if (!offlineDB) return;

            return new Promise((resolve, reject) => {
                try {
                    const transaction = offlineDB.transaction(['cachedRouteMarkers'], 'readwrite');
                    const store = transaction.objectStore('cachedRouteMarkers');
                    const request = store.clear();

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);

                } catch (error) {
                    reject(error);
                }
            });
        }

        // ============================================
        // SUPABASE ROUTE MARKERS SYNC
        // Permite sincronização entre dispositivos
        // ============================================

        // Sistema de debounce e fila para evitar conflitos em atualizações rápidas
        let supabaseSaveTimeout = null;
        let pendingSupabaseSave = null;
        let isSavingToSupabase = false;
        const SUPABASE_SAVE_DEBOUNCE = 300; // Agrupa alterações em 300ms

        // Função interna que realmente salva no Supabase
        async function _doSaveRouteMarkersToSupabase(geojson, stats) {
            if (!isOnline || !window.db) return false;
            if (isSavingToSupabase) {
                // Já está salvando, agenda para depois
                pendingSupabaseSave = { geojson, stats };
                return true;
            }

            isSavingToSupabase = true;

            try {
                // Marca timestamp para evitar re-sincronização própria
                if (typeof lastRouteMarkersSave !== 'undefined') {
                    lastRouteMarkersSave = Date.now();
                }

                // Busca a versão atual e incrementa
                let newVersion = 1;
                try {
                    const { data: currentData } = await window.db
                        .from('route_markers_cache')
                        .select('version')
                        .eq('id', 'current')
                        .maybeSingle();

                    if (currentData && currentData.version) {
                        newVersion = currentData.version + 1;
                    }
                } catch (e) {
                    // Se falhar, usa versão 1
                }

                // Atualiza a versão local também
                if (typeof currentMarkersVersion !== 'undefined') {
                    currentMarkersVersion = newVersion;
                }

                const { error } = await window.db
                    .from('route_markers_cache')
                    .upsert({
                        id: 'current',
                        geojson: geojson,
                        stats: stats,
                        version: newVersion,
                        updated_at: new Date().toISOString()
                    }, { onConflict: 'id' });

                if (error) {
                    console.log('⚠️ Erro ao salvar marcadores no Supabase:', error.message);
                    return false;
                }

                console.log(`☁️ Marcadores salvos no Supabase (v${newVersion})`);
                return true;
            } catch (err) {
                console.log('⚠️ Erro ao salvar marcadores no Supabase:', err);
                return false;
            } finally {
                isSavingToSupabase = false;

                // Se houver save pendente, executa
                if (pendingSupabaseSave) {
                    const pending = pendingSupabaseSave;
                    pendingSupabaseSave = null;
                    setTimeout(() => {
                        _doSaveRouteMarkersToSupabase(pending.geojson, pending.stats);
                    }, 100);
                }
            }
        }

        // Save route markers GeoJSON to Supabase (com debounce para atualizações rápidas)
        function saveRouteMarkersToSupabase(geojson, stats) {
            if (!isOnline || !window.db) return Promise.resolve(false);

            // Cancela timeout anterior (debounce)
            if (supabaseSaveTimeout) {
                clearTimeout(supabaseSaveTimeout);
            }

            // Agenda o save após o debounce
            return new Promise((resolve) => {
                supabaseSaveTimeout = setTimeout(() => {
                    _doSaveRouteMarkersToSupabase(geojson, stats).then(resolve);
                }, SUPABASE_SAVE_DEBOUNCE);
            });
        }

        // Load route markers GeoJSON from Supabase (for cross-device sync)
        async function loadRouteMarkersFromSupabase() {
            if (!isOnline || !window.db) return null;

            try {
                const { data, error } = await window.db
                    .from('route_markers_cache')
                    .select('geojson, stats, updated_at, version')
                    .eq('id', 'current')
                    .maybeSingle();

                if (error) {
                    console.log('⚠️ Erro ao carregar marcadores do Supabase:', error.message);
                    return null;
                }

                if (data && data.geojson && data.geojson.features && data.geojson.features.length > 0) {
                    return {
                        geojson: data.geojson,
                        stats: data.stats,
                        savedAt: data.updated_at,
                        version: data.version || 0
                    };
                }

                return null;
            } catch (err) {
                console.log('⚠️ Erro ao carregar marcadores do Supabase:', err);
                return null;
            }
        }

        // Clear route markers from Supabase (called when new spreadsheet is uploaded)
        async function clearRouteMarkersFromSupabase() {
            if (!isOnline || !window.db) return;

            try {
                await window.db
                    .from('route_markers_cache')
                    .delete()
                    .eq('id', 'current');
                console.log('☁️ Cache de marcadores limpo no Supabase');
            } catch (err) {
                // Silently fail
            }
        }

        // Merge route markers from local cache and Supabase
        // Prioridade: status "delivered" ou "not_delivered" tem prioridade sobre "pending"
        // Alterações de posição (similaridade) do local têm prioridade
        function mergeRouteMarkersGeojson(localGeojson, remoteGeojson) {
            if (!localGeojson || !localGeojson.features) return remoteGeojson;
            if (!remoteGeojson || !remoteGeojson.features) return localGeojson;

            // Cria mapa de features remotas por IDs
            const remoteMap = new Map();
            remoteGeojson.features.forEach(f => {
                if (f.properties && f.properties.ids) {
                    remoteMap.set(f.properties.ids, f);
                }
            });

            // Mescla features: prioriza alterações de status entregue e posição local
            const mergedFeatures = localGeojson.features.map(localFeature => {
                const ids = localFeature.properties?.ids;
                const remoteFeature = ids ? remoteMap.get(ids) : null;

                if (!remoteFeature) {
                    return localFeature; // Só existe local
                }

                // Cria cópia para merge
                const merged = JSON.parse(JSON.stringify(localFeature));
                const localStatus = localFeature.properties?.deliveryStatus || 'pending';
                const remoteStatus = remoteFeature.properties?.deliveryStatus || 'pending';

                // Prioridade de status: delivered/not_delivered > pending
                if (localStatus === 'pending' && (remoteStatus === 'delivered' || remoteStatus === 'not_delivered')) {
                    // Remoto tem status mais "avançado", usa o remoto
                    merged.properties.deliveryStatus = remoteStatus;
                    merged.properties.icon = remoteFeature.properties.icon;
                } else if ((localStatus === 'delivered' || localStatus === 'not_delivered') && remoteStatus === 'pending') {
                    // Local tem status mais "avançado", mantém local
                } else {
                    // Ambos têm mesmo "nível", prioriza local (alteração mais recente)
                }

                // Mantém coordenadas locais (alterações de similaridade)
                // já estão no localFeature

                // Remove do mapa remoto para identificar novos
                remoteMap.delete(ids);

                return merged;
            });

            // Adiciona features que só existem no remoto (novos marcadores)
            remoteMap.forEach(remoteFeature => {
                mergedFeatures.push(remoteFeature);
            });

            return {
                type: 'FeatureCollection',
                features: mergedFeatures
            };
        }

        // Sync route markers from Supabase (for cross-device real-time updates)
        // Usa sistema de versão para detectar mudanças
        // NOTA: lastRouteMarkersSave e isSyncingPendingData são declarados no topo do OFFLINE SYSTEM
        let currentMarkersVersion = 0; // Versão local dos marcadores
        let isSyncingMarkers = false; // Flag para evitar sincronizações simultâneas
        const ROUTE_MARKERS_SYNC_INTERVAL = 400; // 400ms (quase tempo real)

        async function syncRouteMarkersFromSupabase() {
            if (!isOnline || !window.db || !map) return;
            if (isSyncingMarkers) return; // Evita sincronizações simultâneas

            // BLOQUEIO: Não busca dados do servidor enquanto está enviando dados offline
            // Isso evita sobrescrever alterações locais com dados antigos do servidor
            if (isSyncingPendingData) return;

            // Evita sincronizar logo após um save local (é nossa própria alteração)
            // Aumentado para 2000ms para evitar piscadas em redes lentas
            if (Date.now() - lastRouteMarkersSave < 2000) return;

            try {
                const source = map.getSource('route-stops');
                if (!source) return; // Marcadores ainda não carregados

                isSyncingMarkers = true;

                const supabaseData = await loadRouteMarkersFromSupabase();
                if (!supabaseData || !supabaseData.geojson) {
                    isSyncingMarkers = false;
                    return;
                }

                // Verifica se a versão do Supabase é maior que a local
                const supabaseVersion = supabaseData.version || 0;
                if (supabaseVersion <= currentMarkersVersion) {
                    isSyncingMarkers = false;
                    return; // Versão local já está atualizada
                }

                console.log(`🔄 Atualizando marcadores do Supabase (v${supabaseVersion})...`);

                // MERGE INTELIGENTE: Preserva propriedades locais importantes que podem não estar no servidor
                // Isso evita perder matchedClientAddress e outras props durante sincronização
                const localData = source._data;
                if (localData && localData.features) {
                    const localFeaturesMap = new Map();
                    localData.features.forEach(f => {
                        if (f.properties && f.properties.ids) {
                            localFeaturesMap.set(f.properties.ids, f.properties);
                        }
                    });

                    // Merge: preserva propriedades locais que podem ter sido perdidas no servidor
                    supabaseData.geojson.features.forEach(feature => {
                        const localProps = localFeaturesMap.get(feature.properties.ids);
                        if (localProps) {
                            // Preserva matchedClientAddress se o remoto não tem mas o local tem
                            if (!feature.properties.matchedClientAddress && localProps.matchedClientAddress) {
                                feature.properties.matchedClientAddress = localProps.matchedClientAddress;
                            }
                            // Preserva originalMatchedClientAddress para reativação
                            if (!feature.properties.originalMatchedClientAddress && localProps.originalMatchedClientAddress) {
                                feature.properties.originalMatchedClientAddress = localProps.originalMatchedClientAddress;
                            }
                            // Preserva originalCoordinates para reativação
                            if (!feature.properties.originalCoordinates && localProps.originalCoordinates) {
                                feature.properties.originalCoordinates = localProps.originalCoordinates;
                            }
                            // Preserva previousCoordinates
                            if (!feature.properties.previousCoordinates && localProps.previousCoordinates) {
                                feature.properties.previousCoordinates = localProps.previousCoordinates;
                            }
                        }
                    });
                }

                // Salva no cache local (skipSupabase=true para evitar loop)
                await saveRouteMarkersToCache(supabaseData.geojson, supabaseData.stats, true);

                // Atualiza os ícones necessários
                const iconConfigs = new Set();
                supabaseData.geojson.features.forEach(feature => {
                    const icon = feature.properties.icon;
                    if (icon) iconConfigs.add(icon);
                });

                const iconPromises = Array.from(iconConfigs).map(iconName => {
                    return new Promise((resolve) => {
                        if (map.hasImage(iconName)) {
                            resolve();
                            return;
                        }

                        const parts = iconName.replace('pin-', '').split('-');
                        let color, count;
                        if (parts.length === 2 && parts[0] === 'gray' && parts[1] === 'x') {
                            color = 'gray-x';
                            count = parseInt(iconName.split('-').pop());
                        } else if (parts[0] === 'gray' && parts.length === 3) {
                            color = 'gray-x';
                            count = parseInt(parts[2]);
                        } else {
                            count = parseInt(parts.pop());
                            color = parts.join('-');
                        }

                        const { dataUrl, pixelRatio } = generatePinIcon(count, color);
                        const img = new Image();
                        img.onload = () => {
                            if (!map.hasImage(iconName)) {
                                map.addImage(iconName, img, { pixelRatio: pixelRatio });
                            }
                            resolve();
                        };
                        img.onerror = () => resolve();
                        img.src = dataUrl;
                    });
                });

                await Promise.all(iconPromises);

                // PROTEÇÃO ADICIONAL: Verifica novamente se houve alteração local durante a execução assíncrona
                // Isso evita sobrescrever uma alteração do usuário que ocorreu enquanto buscávamos dados do servidor
                if (Date.now() - lastRouteMarkersSave < 2000) {
                    console.log('⏸️ Sync de marcadores cancelado: alteração local detectada durante execução');
                    isSyncingMarkers = false;
                    return;
                }

                // Atualiza o mapa com os dados do Supabase
                source.setData(supabaseData.geojson);
                updateFixedStatsPanel(supabaseData.stats);

                // Atualiza a versão local
                currentMarkersVersion = supabaseVersion;
                console.log(`✅ Marcadores sincronizados do Supabase (v${supabaseVersion})`);

            } catch (err) {
                console.log('⚠️ Erro ao sincronizar marcadores:', err);
            } finally {
                isSyncingMarkers = false;
            }
        }

        // Sincroniza marcadores quando a aba ganha foco
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && isOnline) {
                // Pequeno delay para evitar múltiplas chamadas
                setTimeout(() => {
                    syncRouteMarkersFromSupabase();
                    syncDeliveryStatusFromSupabase();
                }, 500);
            }
        });

        // Sincronização periódica de marcadores de rota
        // Executa ambos os syncs a cada 400ms para máxima responsividade
        let isSyncingStatus = false; // Flag para evitar syncs simultâneos de status

        setInterval(() => {
            if (isOnline && map && map.getSource('route-stops')) {
                // Sync de GeoJSON completo (versão) - rápido, só baixa se versão mudou
                syncRouteMarkersFromSupabase();

                // Sync de status individual - busca diretamente da tabela planilha
                // Isso pega alterações que foram sincronizadas mas ainda não refletiram no route_markers_cache
                if (!isSyncingStatus) {
                    isSyncingStatus = true;
                    syncDeliveryStatusFromSupabase().finally(() => {
                        isSyncingStatus = false;
                    });
                }
            }
        }, ROUTE_MARKERS_SYNC_INTERVAL);

        // Update route markers cache with current geojson data
        function updateRouteMarkersCache(geojsonData) {
            if (!offlineDB || !geojsonData || !geojsonData.features) return;

            // MARCA TIMESTAMP IMEDIATAMENTE para evitar race condition com sync
            // Isso previne a "piscada" de cores nos marcadores
            lastRouteMarkersSave = Date.now();

            try {
                const features = geojsonData.features;
                const statsToSave = {
                    total: features.filter(f => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                    registered: features.filter(f => f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                    unregistered: features.filter(f => !f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                    pending: features.reduce((sum, f) => {
                        if (f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered') {
                            return sum + (f.properties.packageCount || 1);
                        }
                        return sum;
                    }, 0),
                    delivered: features.reduce((sum, f) => {
                        if (f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered') {
                            return sum + (f.properties.packageCount || 1);
                        }
                        return sum;
                    }, 0)
                };
                saveRouteMarkersToCache(geojsonData, statsToSave);
            } catch (err) {
                // Silently fail - cache update is not critical
            }
        }

        // Initialize offline system
        initOfflineDB().then(async () => {
            updateOfflineIndicator();

            if (isOnline) {
                // PERFORMANCE: Só executa sync se houver dados pendentes
                // Evita operações desnecessárias na inicialização
                setTimeout(async () => {
                    try {
                        const pendingClients = await countPendingItems('pendingClients');
                        const pendingPlanilha = await countPendingItems('pendingPlanilha');
                        const pendingStatus = await countPendingItems('pendingDeliveryStatus');

                        // Só sincroniza se houver dados pendentes
                        if (pendingClients > 0 || pendingPlanilha > 0 || pendingStatus > 0) {
                            syncAllPendingData();
                        }
                    } catch (e) {
                        // Silencioso
                    }
                }, 5000);

                // Start periodic cache refresh when online (já tem delay interno de 8s)
                startPeriodicCacheRefresh();
            }
        }).catch(() => {
            // Falha ao inicializar sistema offline (silencioso)
        });

        // ============================================
        // PERIODIC CACHE REFRESH SYSTEM
        // ============================================

        let cacheRefreshInterval = null;
        let lastCacheRefresh = 0;
        let lastClientsLoad = 0; // Timestamp do último load de clients
        const CACHE_REFRESH_INTERVAL = 5 * 60 * 1000; // 5 minutos
        const SKIP_CLIENTS_IF_RECENT = 60 * 1000; // Pula clients se carregado há menos de 1 minuto

        // Refresh all caches with fresh data from Supabase
        // PERFORMANCE: Usa cache incremental - só busca dados novos quando possível
        async function refreshAllCaches(skipClients = false) {
            if (!isOnline || !offlineDB) return;

            // Função interna que faz o refresh real
            const doRefresh = async () => {
                try {
                    // Pula clients se foi carregado recentemente por loadClientes()
                    const shouldSkipClients = skipClients || (Date.now() - lastClientsLoad < SKIP_CLIENTS_IF_RECENT);

                    if (!shouldSkipClients) {
                        await refreshClientsCache();
                    }

                    // Pequeno delay entre requisições
                    await new Promise(r => setTimeout(r, 200));

                    // Refresh planilha cache
                    await refreshPlanilhaCache();

                    lastCacheRefresh = Date.now();
                } catch (err) {
                    // Cache refresh failed silently
                }
            };

            // Usa requestIdleCallback para executar quando o browser estiver idle
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => doRefresh(), { timeout: 10000 });
            } else {
                doRefresh();
            }
        }

        // INCREMENTAL CACHE: Refresh clients cache de forma inteligente
        async function refreshClientsCache() {
            try {
                // Verifica status do cache
                const status = await checkCacheStatus('cachedClients', 'clients');

                if (status.action === 'none') {
                    // Cache está atualizado, não precisa fazer nada
                    return;
                }

                if (status.action === 'incremental' && status.cachedMaxId > 0) {
                    // INCREMENTAL: Busca apenas registros novos (ID maior que o máximo em cache)
                    const { data: newRecords, error } = await db
                        .from('clients')
                        .select('id, address, bairro, city, zipcode, latitude, longitude')
                        .not('latitude', 'is', null)
                        .not('longitude', 'is', null)
                        .gt('id', status.cachedMaxId)
                        .order('id', { ascending: true });

                    if (!error && newRecords && newRecords.length > 0) {
                        // Merge novos registros ao cache existente
                        await mergeToCacheDB('cachedClients', newRecords);

                        // Atualiza metadados
                        const newMaxId = Math.max(...newRecords.map(r => r.id));
                        await saveCacheMetadata('cachedClients', {
                            count: status.serverCount,
                            maxId: newMaxId
                        });
                    } else if (!error) {
                        // Nenhum registro novo, apenas atualiza timestamp
                        await saveCacheMetadata('cachedClients', {
                            count: status.serverCount,
                            maxId: status.cachedMaxId
                        });
                    }
                } else {
                    // FULL REFRESH: Busca todos os registros
                    let allFreshClients = [];
                    let freshFrom = 0;
                    const freshPageSize = 1000;
                    let hasMoreFresh = true;
                    let maxId = 0;

                    while (hasMoreFresh) {
                        const { data: freshPage, error: freshPageError } = await db
                            .from('clients')
                            .select('id, address, bairro, city, zipcode, latitude, longitude')
                            .not('latitude', 'is', null)
                            .not('longitude', 'is', null)
                            .range(freshFrom, freshFrom + freshPageSize - 1);

                        if (freshPageError) break;

                        if (freshPage && freshPage.length > 0) {
                            allFreshClients = allFreshClients.concat(freshPage);
                            freshFrom += freshPageSize;
                            // Track max ID
                            const pageMaxId = Math.max(...freshPage.map(r => r.id));
                            if (pageMaxId > maxId) maxId = pageMaxId;

                            if (freshPage.length < freshPageSize) hasMoreFresh = false;
                        } else {
                            hasMoreFresh = false;
                        }
                    }

                    if (allFreshClients.length > 0) {
                        await saveCacheToDB('cachedClients', allFreshClients);
                        // Salva metadados para próximo refresh incremental
                        await saveCacheMetadata('cachedClients', {
                            count: allFreshClients.length,
                            maxId: maxId
                        });
                    }
                }
            } catch (err) {
                // Erro no refresh de clients (silencioso)
            }
        }

        // INCREMENTAL CACHE: Refresh planilha cache de forma inteligente
        async function refreshPlanilhaCache() {
            try {
                // Verifica status do cache
                const status = await checkCacheStatus('cachedPlanilha', 'planilha');

                if (status.action === 'none') {
                    // Cache está atualizado, não precisa fazer nada
                    return;
                }

                if (status.action === 'incremental' && status.cachedMaxId > 0) {
                    // INCREMENTAL: Busca apenas registros novos
                    const { data: newRecords, error } = await db
                        .from('planilha')
                        .select('id, sequence, destination_address, bairro, city, zipcode, latitude, longitude, spx_tn, stop, delivery_status')
                        .not('destination_address', 'is', null)
                        .gt('id', status.cachedMaxId)
                        .order('id', { ascending: true });

                    if (!error && newRecords && newRecords.length > 0) {
                        // Merge novos registros ao cache existente
                        await mergeToCacheDB('cachedPlanilha', newRecords);

                        // Atualiza metadados
                        const newMaxId = Math.max(...newRecords.map(r => r.id));
                        await saveCacheMetadata('cachedPlanilha', {
                            count: status.serverCount,
                            maxId: newMaxId
                        });
                    } else if (!error) {
                        // Nenhum registro novo, apenas atualiza timestamp
                        await saveCacheMetadata('cachedPlanilha', {
                            count: status.serverCount,
                            maxId: status.cachedMaxId
                        });
                    }
                } else {
                    // FULL REFRESH: Busca todos os registros
                    const { data: freshPlanilha, error: planilhaError } = await db
                        .from('planilha')
                        .select('id, sequence, destination_address, bairro, city, zipcode, latitude, longitude, spx_tn, stop, delivery_status')
                        .not('destination_address', 'is', null)
                        .order('sequence', { ascending: true });

                    if (!planilhaError && freshPlanilha && freshPlanilha.length > 0) {
                        await saveCacheToDB('cachedPlanilha', freshPlanilha);
                        // Salva metadados para próximo refresh incremental
                        const maxId = Math.max(...freshPlanilha.map(r => r.id));
                        await saveCacheMetadata('cachedPlanilha', {
                            count: freshPlanilha.length,
                            maxId: maxId
                        });
                    }
                }
            } catch (err) {
                // Erro no refresh de planilha (silencioso)
            }
        }

        // Start periodic cache refresh
        function startPeriodicCacheRefresh() {
            if (cacheRefreshInterval) {
                clearInterval(cacheRefreshInterval);
            }

            // PERFORMANCE: No refresh inicial, pula clients pois loadClientes() já carregou
            // Apenas carrega planilha para cache offline
            setTimeout(() => {
                if (isOnline) refreshAllCaches(true); // true = skipClients
            }, 8000);

            // Refresh periódico a cada 5 minutos (carrega tudo)
            cacheRefreshInterval = setInterval(() => {
                if (isOnline) {
                    refreshAllCaches(false);
                }
            }, CACHE_REFRESH_INTERVAL);
        }

        // Stop periodic cache refresh
        function stopPeriodicCacheRefresh() {
            if (cacheRefreshInterval) {
                clearInterval(cacheRefreshInterval);
                cacheRefreshInterval = null;
            }
        }

        // ============================================
        // END OFFLINE SYSTEM
        // ============================================

        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.body.classList.add('dark');
            } else {
                document.body.classList.remove('dark');
            }
        });

        // Mapbox initialization
        mapboxgl.accessToken = 'pk.eyJ1IjoiZGFuaWxvYWZrIiwiYSI6ImNtajdra3l0aTA1MXUzZXB2bzByZjVjMXUifQ.RyPdNBII88Qk9xE3j8Rijw';

        let map;
        let mapFullyInitialized = false; // Flag para indicar que inicialização completa terminou
        const locationError = document.getElementById('locationError');
        const errorMessage = document.getElementById('errorMessage');
        const retryBtn = document.getElementById('retryBtn');
        let markersVisible = false;
        let allClientes = [];

        // In-memory cache (sessionStorage not available in iframe)
        let clientesCache = {
            data: null,
            timestamp: 0
        };

        // Initialize map with given coordinates
        function initMapWithCoords(lat, lng, zoom = 14) {
            locationError.classList.remove('show');

            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [lng, lat],
                zoom: zoom,
                // Performance optimizations
                fadeDuration: 0,                    // Remove fade animation dos tiles (mais rápido)
                trackResize: true,                  // Mantém responsivo
                renderWorldCopies: false,           // PERFORMANCE: Desativa cópias do mundo (menos renderização)
                maxTileCacheSize: 150,              // Cache maior = menos recarregamento
                collectResourceTiming: false,       // Desativa coleta de métricas
                crossSourceCollisions: false,       // Menos cálculos de colisão
                localIdeographFontFamily: false,    // Usa fontes do servidor
                pitchWithRotate: false,             // Desativa pitch com rotação (mais leve)
                dragRotate: false,                  // Desativa rotação com drag (mais leve)
                touchPitch: false,                  // Desativa pitch com touch
                antialias: false,                   // PERFORMANCE: Desativa antialiasing (mais rápido)
                refreshExpiredTiles: false,         // PERFORMANCE: Não recarrega tiles expirados automaticamente
                maxParallelImageRequests: 8,        // PERFORMANCE: Limita requisições paralelas
            });

            // PERFORMANCE: Desativa collision detection durante interações
            let interactionTimeout = null;

            // Otimizações de performance durante interações
            map.on('movestart', () => {
                // PERFORMANCE: Marca que o mapa está sendo movido
                // Isso faz a sincronização pausar/desacelerar
                isMapInteracting = true;

                // Reduz qualidade durante movimento
                map.getCanvas().style.imageRendering = 'optimizeSpeed';

                // Limpa timeout anterior se existir
                if (interactionTimeout) {
                    clearTimeout(interactionTimeout);
                    interactionTimeout = null;
                }
            });

            map.on('moveend', () => {
                // PERFORMANCE: Aguarda um pouco antes de restaurar qualidade e liberar sync
                interactionTimeout = setTimeout(() => {
                    map.getCanvas().style.imageRendering = 'auto';
                    isMapInteracting = false; // Libera sincronização
                    interactionTimeout = null;
                }, 200);
            });

            // Bloqueia o "double-tap drag zoom" mas permite arrastar o mapa
            let lastTap = 0;
            let blockingDragZoom = false;
            const mapContainer = map.getContainer();

            // PERFORMANCE: Event listeners otimizados com passive: true quando possível
            mapContainer.addEventListener('touchstart', function(e) {
                const now = Date.now();
                const timeSinceLastTap = now - lastTap;

                if (e.touches.length >= 2) {
                    blockingDragZoom = false;
                    map.touchZoomRotate.enable();
                } else if (timeSinceLastTap < 600 && timeSinceLastTap > 0 && e.touches.length === 1) {
                    blockingDragZoom = true;
                    map.touchZoomRotate.disable();
                }
                lastTap = now;
            }, { passive: true, capture: true }); // PERFORMANCE: Mudado para passive: true

            mapContainer.addEventListener('touchmove', function(e) {
                if (e.touches.length >= 2 && blockingDragZoom) {
                    blockingDragZoom = false;
                    map.touchZoomRotate.enable();
                }
            }, { passive: true, capture: true });

            mapContainer.addEventListener('touchend', function(e) {
                if (e.touches.length === 0) {
                    blockingDragZoom = false;
                    map.touchZoomRotate.enable();
                }
            }, { passive: true, capture: true });

            // Add map controls
            initializeMapControls();

            // Esconde loader quando o mapa carregar
            map.on('load', () => {
                updateLoader('ready', 'Pronto!');
                setTimeout(hideLoader, 300);
            });

            // PERFORMANCE: Todas as operações pesadas são adiadas para depois do mapa ficar idle
            let initialSetupDone = false;

            map.on('idle', () => {
                if (initialSetupDone) return;
                initialSetupDone = true;

                // Setup click handler imediatamente (é leve)
                setupMapClickHandler();

                // Dispara geolocateControl após delay mínimo para mostrar a bola azul
                // O mapa já está na posição correta do GPS (obtido antes de inicializar)
                // Com maximumAge: 5000, o geolocateControl reutiliza a posição GPS recente
                if (geolocateControl) {
                    // Delay mínimo de 100ms - mapa já está estável com idle event
                    setTimeout(() => {
                        if (geolocateControl) geolocateControl.trigger();
                    }, 100);
                }

                // PERFORMANCE: Adia ajustes de layers para não competir com renderização
                setTimeout(() => {
                    const roadLayers = [
                        'road-street',
                        'road-minor',
                        'road-residential',
                        'road-local'
                    ];

                    roadLayers.forEach(layerId => {
                        if (map && map.getLayer(layerId)) {
                            try {
                                map.setLayerZoomRange(layerId, 10, 24);
                            } catch (e) {}
                        }
                    });

                    // Marca inicialização como completa após ajustes de layers
                    mapFullyInitialized = true;
                }, 3000);

                // PERFORMANCE: Carrega clientes após 4s para não competir com mapa
                // Usa requestIdleCallback para garantir que não causa lag
                setTimeout(() => {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => loadClientes(), { timeout: 2000 });
                    } else {
                        loadClientes();
                    }
                }, 4000);

                // PERSISTENCE & CROSS-DEVICE SYNC: Carrega marcadores de rota
                // 1. Tenta cache local primeiro (mais rápido)
                // 2. Se não houver cache local, tenta carregar do Supabase (sync entre dispositivos)
                // 3. Se não houver em nenhum lugar, usuário precisa clicar em "Paradas da Rota"
                setTimeout(async () => {
                    try {
                        // Tenta cache local primeiro
                        let loaded = await loadCachedRouteMarkers();
                        if (loaded) {
                            console.log('📍 Marcadores de rota carregados do cache local');
                            // Se online, sincroniza status de entrega em background
                            if (isOnline) {
                                setTimeout(() => syncDeliveryStatusFromSupabase(), 1000);
                            }
                        } else if (isOnline) {
                            // Não há cache local - tenta carregar do Supabase (outro dispositivo pode ter gerado)
                            console.log('📍 Cache local vazio, tentando carregar do Supabase...');
                            const supabaseData = await loadRouteMarkersFromSupabase();
                            if (supabaseData && supabaseData.geojson) {
                                // Salva no cache local para próximas vezes (skipSupabase=true para evitar loop)
                                await saveRouteMarkersToCache(supabaseData.geojson, supabaseData.stats, true);
                                // Carrega os marcadores no mapa
                                loaded = await loadCachedRouteMarkers();
                                if (loaded) {
                                    console.log('📍 Marcadores sincronizados do Supabase para este dispositivo');
                                    // Sincroniza status de entrega
                                    setTimeout(() => syncDeliveryStatusFromSupabase(), 1000);
                                }
                            }
                        }
                    } catch (e) {
                        console.log('⚠️ Erro ao carregar marcadores:', e);
                    }
                }, 2000);
            });

            // Fallback: esconde loader após 5 segundos
            setTimeout(() => {
                if (appLoader && !appLoader.classList.contains('hidden')) {
                    hideLoader();
                }
            }, 5000);
        }

        function getUserLocationAndInitMap() {
            // Default location (Ilha do Mosqueiro, Belém, PA, Brazil)
            const defaultLat = -1.0850;
            const defaultLng = -48.4580;

            // PERFORMANCE: Inicializa mapa IMEDIATAMENTE com localização padrão
            // O GeolocateControl (com maximumAge: 5000) cuida de centralizar na posição real
            // Isso elimina a espera de "Obtendo localização..."
            updateLoader('gps', 'Carregando mapa...');
            console.log('📍 Inicializando mapa imediatamente (GPS será atualizado pelo GeolocateControl)');
            initMapWithCoords(defaultLat, defaultLng, 12);
        }

        let geolocateControl = null;

        // ============================================
        // GEOLOCATE CONTROL - Estado e Configurações
        // ============================================
        const GeolocateState = {
            isTracking: false,           // Se está em modo de rastreamento ativo
            isWaitingForLocation: false, // Aguardando primeira posição
            lastPosition: null,          // Última posição conhecida
            lastUpdate: 0,               // Timestamp da última atualização
            accuracy: null,              // Precisão em metros
            heading: null,               // Direção em graus
            speed: null,                 // Velocidade em m/s
            trackingMode: 'off',         // 'off' | 'tracking' | 'tracking_compass'
            errorCount: 0,               // Contador de erros consecutivos

            // Atualiza estado com nova posição
            updatePosition(coords) {
                this.lastPosition = {
                    lng: coords.longitude,
                    lat: coords.latitude
                };
                this.accuracy = coords.accuracy;
                this.heading = coords.heading;
                this.speed = coords.speed;
                this.lastUpdate = Date.now();
                this.errorCount = 0; // Reset contador de erros
            },

            // Retorna se a posição é recente (menos de 10s)
            hasRecentPosition() {
                return this.lastPosition && (Date.now() - this.lastUpdate < 10000);
            },

            // Reset completo do estado
            reset() {
                this.isTracking = false;
                this.isWaitingForLocation = false;
                this.trackingMode = 'off';
            }
        };

        function initializeMapControls() {
            // Controle de Navegação (zoom + bússola)
            map.addControl(new mapboxgl.NavigationControl({
                showCompass: true,
                showZoom: true,
                visualizePitch: true  // Mostra pitch no botão de bússola
            }), 'top-right');

            // Controle de Escala (canto inferior esquerdo)
            map.addControl(new mapboxgl.ScaleControl({
                maxWidth: 100,
                unit: 'metric'
            }), 'bottom-left');

            // ============================================
            // GEOLOCATE CONTROL - Configuração Completa
            // ============================================
            geolocateControl = new mapboxgl.GeolocateControl({
                // Opções de posição do GPS (Web Geolocation API)
                positionOptions: {
                    enableHighAccuracy: true,  // GPS de alta precisão
                    maximumAge: 5000,          // Aceita posição em cache de até 5s (usa GPS inicial rápido)
                    timeout: 6000              // 6 segundos de timeout
                },

                // Rastreamento contínuo da posição do usuário
                trackUserLocation: true,

                // Mostra indicador de direção (heading) no marcador
                showUserHeading: true,

                // Mostra círculo de precisão (accuracy circle)
                showAccuracyCircle: true,

                // Opções de ajuste de bounds quando centraliza no usuário
                fitBoundsOptions: {
                    maxZoom: 17,      // Zoom máximo ao centralizar
                    linear: false,    // Usa easing suave
                    duration: 1000,   // Animação de 1 segundo
                    padding: 50       // Padding das bordas
                }
            });

            map.addControl(geolocateControl, 'top-right');

            // ============================================
            // EVENTOS DO GEOLOCATE CONTROL (API Mapbox)
            // ============================================

            /**
             * Evento: geolocate
             * Disparado cada vez que uma nova posição é obtida
             */
            geolocateControl.on('geolocate', (e) => {
                GeolocateState.updatePosition(e.coords);

                // Log para debug (pode ser removido em produção)
                console.log('📍 Posição atualizada:', {
                    lat: e.coords.latitude.toFixed(6),
                    lng: e.coords.longitude.toFixed(6),
                    accuracy: Math.round(e.coords.accuracy) + 'm',
                    heading: e.coords.heading ? Math.round(e.coords.heading) + '°' : 'N/A',
                    speed: e.coords.speed ? (e.coords.speed * 3.6).toFixed(1) + ' km/h' : 'parado'
                });
            });

            /**
             * Evento: trackuserlocationstart
             * Disparado quando o rastreamento é iniciado
             */
            geolocateControl.on('trackuserlocationstart', () => {
                GeolocateState.isTracking = true;
                GeolocateState.isWaitingForLocation = true;
                GeolocateState.trackingMode = 'tracking';
                console.log('🔵 Rastreamento iniciado');
            });

            /**
             * Evento: trackuserlocationend
             * Disparado quando o rastreamento é encerrado
             */
            geolocateControl.on('trackuserlocationend', () => {
                GeolocateState.isTracking = false;
                GeolocateState.trackingMode = 'off';
                console.log('⚪ Rastreamento encerrado');
            });

            /**
             * Evento: userlocationfocus
             * Disparado quando o mapa centraliza no usuário (clique no botão)
             */
            geolocateControl.on('userlocationfocus', () => {
                GeolocateState.isWaitingForLocation = false;
                console.log('🎯 Centralizado no usuário');
            });

            /**
             * Evento: userlocationlostfocus
             * Disparado quando o usuário arrasta o mapa (perde foco)
             */
            geolocateControl.on('userlocationlostfocus', () => {
                // Mapa foi movido pelo usuário, tracking continua mas câmera não segue
                console.log('👆 Usuário moveu o mapa (foco perdido)');
            });

            /**
             * Evento: error
             * Disparado quando há erro de geolocalização
             */
            geolocateControl.on('error', (e) => {
                GeolocateState.errorCount++;
                GeolocateState.isWaitingForLocation = false;

                const errorMessages = {
                    1: 'Permissão de localização negada',
                    2: 'Posição indisponível',
                    3: 'Timeout ao obter localização'
                };

                const errorMsg = errorMessages[e.code] || 'Erro desconhecido';
                console.warn('⚠️ Erro GPS:', errorMsg, `(tentativa ${GeolocateState.errorCount})`);

                // Se muitos erros consecutivos, notifica o usuário
                if (GeolocateState.errorCount >= 3) {
                    ErrorHandler.handle(
                        new Error(errorMsg),
                        { action: 'geolocate', code: e.code },
                        { silent: false, userMessage: errorMsg }
                    );
                }
            });

            /**
             * Evento: outofmaxbounds
             * Disparado quando o usuário está fora dos bounds máximos do mapa
             */
            geolocateControl.on('outofmaxbounds', () => {
                console.warn('⚠️ Usuário fora dos limites do mapa');
            });

            // ============================================
            // VISIBILITY API - Refresh ao retomar
            // ============================================
            let lastGpsRefresh = 0;

            function handleGpsRefresh() {
                const now = Date.now();
                if (now - lastGpsRefresh < 1000) return; // Debounce 1s
                lastGpsRefresh = now;

                if (!geolocateControl) return;

                // Só dispara refresh se estava em modo tracking
                if (GeolocateState.isTracking) {
                    console.log('🔄 Atualizando GPS após retorno...');

                    // Pequeno delay para garantir que a tela está ativa
                    setTimeout(() => {
                        if (GeolocateState.isTracking) {
                            geolocateControl.trigger();
                        }
                    }, 300);
                }
            }

            // Evento de visibilidade (tela ligou/desligou)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    handleGpsRefresh();
                }
            });

            // Evento de foco (app voltou ao primeiro plano)
            window.addEventListener('focus', handleGpsRefresh);

            // Evento de resume (específico para PWAs)
            window.addEventListener('resume', handleGpsRefresh);

            // ============================================
            // INTERAÇÃO COM O MAPA
            // ============================================

            // Quando usuário interage com o mapa, o GeolocateControl
            // automaticamente muda para modo "tracking without camera follow"
            // (marcador visível mas câmera não segue)

            // Duplo clique no botão de geolocate alterna entre:
            // 1. Tracking (câmera segue posição)
            // 2. Tracking + Compass (câmera segue posição E rotação)
            // Isso é nativo do Mapbox quando showUserHeading: true
        }

        retryBtn.addEventListener('click', getUserLocationAndInitMap);
        getUserLocationAndInitMap();

        // Sidebar functionality
        const menuBtn = document.getElementById('menuBtn');
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('overlay');
        const closeBtn = document.getElementById('closeBtn');
        const clienteList = document.getElementById('clienteList');
        const emptyState = document.getElementById('emptyState');
        const loadingState = document.getElementById('loadingState');
        const clienteCount = document.getElementById('clienteCount');
        const toggleMarkersBtn = document.getElementById('toggleMarkersBtn');
        const searchInput = document.getElementById('searchInput');

        function toggleSidebar() {
            menuBtn.classList.toggle('active');
            sidebar.classList.toggle('active');
            overlay.classList.toggle('active');
        }

        function closeSidebar() {
            menuBtn.classList.remove('active');
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
        }

        menuBtn.addEventListener('click', toggleSidebar);
        overlay.addEventListener('click', closeSidebar);
        closeBtn.addEventListener('click', closeSidebar);

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sidebar.classList.contains('active')) {
                closeSidebar();
            }
        });

        // Toggle markers functionality
        toggleMarkersBtn.addEventListener('click', () => {
            markersVisible = !markersVisible;
            toggleMarkersBtn.classList.toggle('active', markersVisible);

            if (markersVisible) {
                addMarkersToMap(allClientes);
            } else {
                removeMarkersFromMap();
            }
        });

        // Load clientes from Supabase with persistent caching
        async function loadClientes() {
            loadingState.style.display = 'block';
            emptyState.style.display = 'none';
            clienteList.style.display = 'none';

            try {
                // Use in-memory cache if less than 5 minutes old
                if (clientesCache.data && Date.now() - clientesCache.timestamp < 300000) {
                    allClientes = clientesCache.data;
                    renderClientes(clientesCache.data);
                    if (markersVisible) {
                        addMarkersToMap(clientesCache.data);
                    }
                }

                // Try to fetch fresh data if online
                if (isOnline) {
                    // Busca todos os clientes usando paginação (Supabase limita a 1000 por padrão)
                    let allData = [];
                    let from = 0;
                    const pageSize = 1000;
                    let hasMore = true;

                    while (hasMore) {
                        const { data: pageData, error: pageError } = await db
                            .from('clients')
                            .select('*')
                            .order('id', { ascending: false })
                            .range(from, from + pageSize - 1);

                        if (pageError) {
                            break;
                        }

                        if (pageData && pageData.length > 0) {
                            allData = allData.concat(pageData);
                            from += pageSize;
                            // Se retornou menos que pageSize, não há mais dados
                            if (pageData.length < pageSize) {
                                hasMore = false;
                            }
                        } else {
                            hasMore = false;
                        }
                    }

                    const data = allData;
                    const error = allData.length === 0 ? null : null;

                    if (!error && data) {
                        // Update in-memory cache
                        clientesCache = {
                            data: data || [],
                            timestamp: Date.now()
                        };

                        // Marca timestamp para evitar refresh duplicado
                        lastClientsLoad = Date.now();

                        // Save to IndexedDB cache for offline use
                        await saveCacheToDB('cachedClients', data);

                        allClientes = data || [];
                        renderClientes(data);

                        // Only add markers if they are currently visible
                        if (markersVisible) {
                            addMarkersToMap(data);
                        }
                        return;
                    }
                }

                // If offline or fetch failed, use IndexedDB cache
                const cachedClients = await getAllFromOfflineDB('cachedClients');

                if (cachedClients && cachedClients.length > 0) {
                    allClientes = cachedClients;
                    renderClientes(cachedClients);
                    if (markersVisible) {
                        addMarkersToMap(cachedClients);
                    }
                    clienteCount.textContent = `${cachedClients.length} cliente${cachedClients.length > 1 ? 's' : ''} (offline)`;
                } else if (clientesCache.data) {
                    // Fallback to in-memory cache if available
                    allClientes = clientesCache.data;
                    renderClientes(clientesCache.data);
                    clienteCount.textContent = `${clientesCache.data.length} cliente${clientesCache.data.length > 1 ? 's' : ''} (cache)`;
                } else {
                    clienteCount.textContent = 'Nenhum cliente';
                }
            } catch (error) {
                // Erro ao carregar clientes - usa ErrorHandler
                ErrorHandler.handle(error, { action: 'loadClientes' }, { silent: true });
                clienteCount.textContent = 'Erro ao carregar';

                // Try IndexedDB cache as fallback
                try {
                    const cachedClients = await getAllFromOfflineDB('cachedClients');
                    if (cachedClients && cachedClients.length > 0) {
                        allClientes = cachedClients;
                        renderClientes(cachedClients);
                        clienteCount.textContent = `${cachedClients.length} cliente${cachedClients.length > 1 ? 's' : ''} (offline)`;
                    }
                } catch (cacheError) {
                    ErrorHandler.handle(cacheError, { action: 'loadClientes.cache' }, { silent: true });
                }
            }
        }

        // Search functionality with debounce - OPTIMIZED
        // Usa função debounce utilitária para melhor manutenção
        function handleSearchInput(e) {
            const searchTerm = e.target.value.toLowerCase().trim();

            if (searchTerm === '') {
                renderClientes(allClientes);
            } else {
                // Permite pesquisa por ID (ex: #123 ou apenas 123)
                const idSearch = searchTerm.replace('#', '');
                const isIdSearch = /^\d+$/.test(idSearch);

                const filtered = allClientes.filter(cliente => {
                    // Pesquisa por ID
                    if (isIdSearch && cliente.id && cliente.id.toString() === idSearch) {
                        return true;
                    }
                    // Pesquisa por endereço, bairro ou CEP
                    return cliente.address.toLowerCase().includes(searchTerm) ||
                        (cliente.bairro && cliente.bairro.toLowerCase().includes(searchTerm)) ||
                        (cliente.zipcode && cliente.zipcode.toLowerCase().includes(searchTerm)) ||
                        (cliente.id && cliente.id.toString().includes(idSearch));
                });
                renderClientes(filtered);
            }
        }

        // DEBOUNCE: Aguarda 200ms após o usuário parar de digitar
        const debouncedSearch = debounce(handleSearchInput, 200);
        searchInput.addEventListener('input', debouncedSearch);

        // ============================================
        // VIRTUAL SCROLLING SYSTEM
        // ============================================
        // Renderiza apenas os itens visíveis na viewport para performance com grandes listas

        const clienteListViewport = document.getElementById('clienteListViewport');
        const clienteListSpacer = document.getElementById('clienteListSpacer');
        const sidebarContent = document.getElementById('sidebarContent');

        // Configurações do Virtual Scroller
        const ITEM_HEIGHT = 100; // Altura estimada de cada item em pixels (incluindo gap)
        const BUFFER_SIZE = 5;   // Itens extras renderizados acima/abaixo da viewport
        const GAP_SIZE = 12;     // Gap entre itens

        // Estado do Virtual Scroller
        let virtualScrollerData = { clientes: [], calculated: { positions: [], totalHeight: 0 } };
        let virtualScrollerActive = false;
        let lastScrollTop = 0;
        let renderScheduled = false;

        /**
         * Calcula altura de um item baseado no conteúdo
         * Itens com bairro/cep são mais altos
         */
        function getItemHeight(cliente) {
            const hasExtraInfo = cliente.bairro || cliente.zipcode;
            // Base: header(~32px) + coords(~20px) + padding(28px) + border(4px) + margin(12px)
            // Com info extra: +24px
            return hasExtraInfo ? 108 : 84;
        }

        /**
         * Pré-calcula posições de todos os itens
         * Retorna array de { top, height } para cada item
         */
        function calculateItemPositions(clientes) {
            const positions = [];
            let currentTop = 0;

            for (let i = 0; i < clientes.length; i++) {
                const height = getItemHeight(clientes[i]);
                positions.push({ top: currentTop, height });
                currentTop += height + GAP_SIZE;
            }

            return { positions, totalHeight: currentTop - GAP_SIZE };
        }

        /**
         * Encontra índices dos itens visíveis dado um scrollTop
         */
        function findVisibleRange(scrollTop, viewportHeight, positions) {
            if (positions.length === 0) return { start: 0, end: 0 };

            // Busca binária para encontrar primeiro item visível
            let start = 0;
            let end = positions.length - 1;

            while (start < end) {
                const mid = Math.floor((start + end) / 2);
                if (positions[mid].top + positions[mid].height < scrollTop) {
                    start = mid + 1;
                } else {
                    end = mid;
                }
            }

            const firstVisible = Math.max(0, start - BUFFER_SIZE);

            // Encontra último item visível
            const bottomEdge = scrollTop + viewportHeight;
            let lastVisible = firstVisible;

            for (let i = firstVisible; i < positions.length; i++) {
                if (positions[i].top > bottomEdge + (BUFFER_SIZE * ITEM_HEIGHT)) {
                    break;
                }
                lastVisible = i;
            }

            return {
                start: firstVisible,
                end: Math.min(positions.length - 1, lastVisible + BUFFER_SIZE)
            };
        }

        /**
         * Gera HTML de um item de cliente
         */
        function renderClienteItem(cliente, position) {
            const escapeHtml = (text) => {
                if (!text) return '';
                return text.replace(/[&<>"']/g, (m) => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
                }[m]));
            };

            return `
                <div class="cliente-item"
                     data-id="${cliente.id}"
                     data-lat="${cliente.latitude || 0}"
                     data-lng="${cliente.longitude || 0}"
                     data-address="${escapeHtml(cliente.address)}"
                     style="top: ${position.top}px; height: ${position.height}px;">
                    <div class="cliente-item-header">
                        <span class="cliente-item-id">#${cliente.id}</span>
                        <div class="cliente-item-title">${escapeHtml(cliente.address)}</div>
                        <div class="cliente-item-actions">
                            <button class="cliente-item-btn delete" title="Excluir">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    ${cliente.bairro || cliente.zipcode ? `<div class="cliente-item-info">${cliente.bairro ? `<span class="cliente-item-bairro">🏘️ ${escapeHtml(cliente.bairro)}</span>` : ''}${cliente.zipcode ? `<span class="cliente-item-cep">📮 ${escapeHtml(cliente.zipcode)}</span>` : ''}</div>` : ''}
                    <div class="cliente-item-coords">📍 ${cliente.latitude ? cliente.latitude.toFixed(6) : '0.000000'}, ${cliente.longitude ? cliente.longitude.toFixed(6) : '0.000000'}</div>
                </div>
            `;
        }

        /**
         * Renderiza os itens visíveis no viewport
         */
        function renderVisibleItems() {
            if (!virtualScrollerActive || !virtualScrollerData.clientes || virtualScrollerData.clientes.length === 0) return;

            const scrollTop = sidebarContent.scrollTop;
            let viewportHeight = sidebarContent.clientHeight;

            // Se viewport não está visível, usa altura padrão para renderizar alguns itens
            if (viewportHeight === 0) {
                viewportHeight = 600; // Altura padrão para sidebar
            }

            // Pula se scroll não mudou significativamente (menos que meio item)
            // MAS sempre renderiza se viewport está vazio
            if (Math.abs(scrollTop - lastScrollTop) < ITEM_HEIGHT / 2 && clienteListViewport.children.length > 0) {
                return;
            }
            lastScrollTop = scrollTop;

            const { positions } = virtualScrollerData.calculated;
            const { start, end } = findVisibleRange(scrollTop, viewportHeight, positions);

            // Gera HTML dos itens visíveis
            let html = '';
            for (let i = start; i <= end && i < virtualScrollerData.clientes.length; i++) {
                html += renderClienteItem(virtualScrollerData.clientes[i], positions[i]);
            }

            clienteListViewport.innerHTML = html;
        }

        /**
         * Handler de scroll com throttle para performance
         */
        const handleVirtualScroll = throttle(() => {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderVisibleItems();
                    renderScheduled = false;
                });
            }
        }, 16); // ~60fps

        // Adiciona listener de scroll no sidebar content
        sidebarContent.addEventListener('scroll', handleVirtualScroll, { passive: true });

        /**
         * Inicializa ou atualiza o Virtual Scroller com novos dados
         */
        function initVirtualScroller(clientes) {
            // Calcula posições de todos os itens
            const calculated = calculateItemPositions(clientes);

            // Armazena dados
            virtualScrollerData = {
                clientes,
                calculated
            };

            // Ajusta altura do spacer para manter scroll correto
            clienteListSpacer.style.height = calculated.totalHeight + 'px';

            // Reseta scroll se necessário
            if (sidebarContent.scrollTop > calculated.totalHeight) {
                sidebarContent.scrollTop = 0;
            }

            // Limpa viewport e força re-render (importante para add/delete)
            clienteListViewport.innerHTML = '';
            lastScrollTop = -999; // Força re-render com valor que não pode igualar scrollTop

            // Ativa e renderiza
            virtualScrollerActive = true;
            renderVisibleItems();
        }

        /**
         * Desativa o Virtual Scroller
         */
        function destroyVirtualScroller() {
            virtualScrollerActive = false;
            virtualScrollerData = { clientes: [], calculated: { positions: [], totalHeight: 0 } };
            clienteListViewport.innerHTML = '';
            clienteListSpacer.style.height = '0';
        }

        // Render clientes list - VERSÃO COM VIRTUAL SCROLLING
        function renderClientes(clientes) {
            loadingState.style.display = 'none';

            if (!clientes || clientes.length === 0) {
                emptyState.style.display = 'flex';
                clienteList.style.display = 'none';
                clienteCount.textContent = searchInput.value ? 'Nenhum resultado' : 'Nenhum cliente';
                destroyVirtualScroller();
                return;
            }

            const total = clientes.length;
            const totalGeral = allClientes.length;

            if (searchInput.value) {
                clienteCount.textContent = `${total} de ${totalGeral} cliente${totalGeral > 1 ? 's' : ''}`;
            } else {
                clienteCount.textContent = `${total} cliente${total > 1 ? 's' : ''}`;
            }

            emptyState.style.display = 'none';
            clienteList.style.display = 'flex';

            // Usa Virtual Scrolling para listas grandes (>20 itens) ou sempre para consistência
            initVirtualScroller(clientes);
        }

        /**
         * Força re-render do Virtual Scroller (útil após resize)
         */
        function refreshVirtualScroller() {
            if (virtualScrollerActive && virtualScrollerData.clientes) {
                lastScrollTop = -1;
                renderVisibleItems();
            }
        }

        // Re-render quando sidebar é aberto (viewport pode ter mudado)
        const originalOpenSidebar = typeof openSidebar === 'function' ? openSidebar : null;

        // Temporary marker for "View on map"
        let viewMarker = null;
        let viewPopup = null;

        function removeViewMarker() {
            if (viewPopup) {
                ResourceRegistry.removePopup(viewPopup);
                viewPopup = null;
            }
            if (viewMarker) {
                ResourceRegistry.removeMarker(viewMarker);
                viewMarker = null;
            }
        }

        // Global map click handler for closing popup (keep marker)
        function setupMapClickHandler() {
            map.on('click', (e) => {
                // Don't close if clicking on marker or popup
                if (e.originalEvent.target.closest('.view-marker') ||
                    e.originalEvent.target.closest('.mapboxgl-popup')) {
                    return;
                }
                // Just close popup, keep marker
                if (viewMarker) {
                    const popup = viewMarker.getPopup();
                    if (popup && popup.isOpen()) {
                        viewMarker.togglePopup();
                    }
                }
            });
        }

        // Global click handler for popup close button (using capture phase for reliability)
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('mapboxgl-popup-close-button') && viewMarker) {
                e.preventDefault();
                e.stopPropagation();
                removeViewMarker();
            }
        }, true);

        function showViewMarker(lat, lng, address) {
            // Remove existing marker if any
            removeViewMarker();

            // Create marker element
            const markerEl = document.createElement('div');
            markerEl.className = 'view-marker';
            markerEl.innerHTML = `
                <div class="view-marker-pin"></div>
                <div class="view-marker-pulse"></div>
            `;

            // Create popup with red X button positioned outside above
            viewPopup = ResourceRegistry.registerPopup(new mapboxgl.Popup({
                offset: 25,
                closeButton: false,
                closeOnClick: false
            }).setHTML(`
                <button class="view-popup-close-btn" id="view-popup-close-btn" title="Remover marcador">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
                <div style="font-size: 13px; font-weight: 500;">${address}</div>
            `));

            // Create marker with popup attached
            viewMarker = ResourceRegistry.registerMarker(new mapboxgl.Marker({
                element: markerEl,
                anchor: 'bottom'
            })
                .setLngLat([lng, lat])
                .setPopup(viewPopup)
                .addTo(map));

            // Show popup after map finishes flying
            map.once('moveend', () => {
                if (viewMarker) {
                    viewMarker.togglePopup();
                    // Add click handler for close button after popup is shown
                    setTimeout(() => {
                        const closeBtn = document.getElementById('view-popup-close-btn');
                        if (closeBtn) {
                            closeBtn.addEventListener('click', () => {
                                removeViewMarker();
                            });
                        }
                    }, 100);
                }
            });
        }

        // Event delegation for cliente list actions
        clienteList.addEventListener('click', (e) => {
            const item = e.target.closest('.cliente-item');
            if (!item) return;

            // ID pode ser número (Supabase) ou string "new_xxx"/"pending_xxx" (offline)
            const rawId = item.dataset.id;
            const isOfflineId = rawId.startsWith('new_') || rawId.startsWith('pending_');
            const id = isOfflineId ? rawId : parseInt(rawId);
            const lat = parseFloat(item.dataset.lat);
            const lng = parseFloat(item.dataset.lng);
            const address = item.dataset.address;

            // Check if clicked on delete button
            const btn = e.target.closest('.cliente-item-btn');

            if (btn && btn.classList.contains('delete')) {
                showDeleteConfirm(id, address);
            } else if (!btn) {
                // Clicked on the item itself - show on map
                showViewMarker(lat, lng, address);
                map.flyTo({
                    center: [lng, lat],
                    zoom: 16,
                    duration: 2000
                });
                closeSidebar();
            }
        });

        // Delete confirmation modal
        function showDeleteConfirm(id, address) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modal.innerHTML = `
                <div style="background: var(--surface-light); padding: 24px; border-radius: 16px; box-shadow: var(--shadow); max-width: 400px; width: 90%; margin: 0 16px;">
                    <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 16px; color: var(--text-light);">Confirmar exclusão</h3>
                    <p style="font-size: 14px; color: var(--text-muted-light); margin-bottom: 8px;">Tem certeza que deseja excluir este cliente?</p>
                    <p style="font-size: 14px; font-weight: 600; color: var(--text-light);">${address}</p>
                    <div style="display: flex; gap: 12px; margin-top: 24px; justify-content: flex-end;">
                        <button id="confirmCancel" style="padding: 10px 20px; border: 2px solid var(--border-light); background: transparent; border-radius: 10px; font-family: inherit; font-size: 14px; font-weight: 600; cursor: pointer; color: var(--text-light); transition: all 0.2s ease;">Cancelar</button>
                        <button id="confirmDelete" style="padding: 10px 20px; border: none; background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); border-radius: 10px; font-family: inherit; font-size: 14px; font-weight: 600; cursor: pointer; color: white; transition: all 0.2s ease;">Excluir</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            modal.querySelector('#confirmCancel').addEventListener('click', () => modal.remove());
            modal.querySelector('#confirmDelete').addEventListener('click', async () => {
                modal.remove();
                await deleteCliente(id, address);
            });
        }

        // Delete cliente - com ErrorHandler
        async function deleteCliente(id, address) {
            try {
                // Verifica se é um cliente criado offline (ID temporário: "new_xxx" ou "pending_xxx")
                const isOfflineClient = typeof id === 'string' && (id.startsWith('new_') || id.startsWith('pending_'));

                if (!isOnline) {
                    // OFFLINE: Salva exclusão pendente ou remove do pendingClients
                    if (isOfflineClient) {
                        // Cliente criado offline - remove diretamente do pendingClients
                        await removeOfflineClientById(id, address);
                    } else {
                        // Cliente do Supabase - salva exclusão para sincronizar depois
                        await saveToOfflineDB('pendingDeletes', {
                            clientId: id,
                            deletedAt: new Date().toISOString(),
                            synced: false
                        });
                    }

                    showQuickSuccess();
                    await removeSingleClientFromUI(id);
                    updateOfflineIndicator();
                    return;
                }

                // ONLINE
                if (isOfflineClient) {
                    // Cliente offline que ainda não foi sincronizado - apenas remove localmente
                    await removeOfflineClientById(id, address);
                    showQuickSuccess();
                    await removeSingleClientFromUI(id);
                    return;
                }

                // Cliente do Supabase - exclui normalmente
                const { error } = await db
                    .from('clients')
                    .delete()
                    .eq('id', id);

                if (error) throw error;

                showQuickSuccess();

                // PERFORMANCE: Remove incrementalmente em vez de recarregar tudo
                await removeSingleClientFromUI(id);
            } catch (error) {
                ErrorHandler.handle(error, { action: 'deleteCliente', id }, {
                    customMessage: 'Erro ao excluir cliente. Tente novamente.'
                });
            }
        }

        // Remove cliente criado offline do pendingClients
        async function removeOfflineClientById(offlineId, clientAddress) {
            if (!offlineDB) return false;

            try {
                const pendingClients = await getAllFromOfflineDB('pendingClients');
                if (!pendingClients || pendingClients.length === 0) return false;

                // Converte para string para comparação consistente
                const offlineIdStr = String(offlineId);

                // Extrai timestamp se for "new_xxxxx" ou "pending_xxxxx"
                let timestamp = offlineIdStr;
                if (offlineIdStr.startsWith('new_')) {
                    timestamp = offlineIdStr.substring(4);
                } else if (offlineIdStr.startsWith('pending_')) {
                    timestamp = offlineIdStr.substring(8);
                }

                // Encontra o cliente pelo ID temporário OU pelo endereço
                for (const client of pendingClients) {
                    const clientTempId = client.id ? String(client.id) : '';

                    // Extrai timestamp do ID do cliente
                    let clientTimestamp = '';
                    if (clientTempId.startsWith('new_')) {
                        clientTimestamp = clientTempId.substring(4);
                    } else if (clientTempId.startsWith('pending_')) {
                        clientTimestamp = clientTempId.substring(8);
                    }

                    // Match por múltiplas formas (incluindo endereço como fallback)
                    const matches =
                        clientTempId === offlineIdStr ||
                        String(client.localId) === offlineIdStr ||
                        String(client.localId) === timestamp ||
                        clientTimestamp === timestamp ||
                        (clientAddress && client.address === clientAddress);

                    if (matches) {
                        // Usa delete direto no IndexedDB
                        await new Promise((resolve, reject) => {
                            const transaction = offlineDB.transaction(['pendingClients'], 'readwrite');
                            const store = transaction.objectStore('pendingClients');
                            const request = store.delete(client.localId);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                        return true;
                    }
                }
                return false;
            } catch (error) {
                console.error('Erro ao remover cliente offline:', error);
                return false;
            }
        }

        // PERFORMANCE: Adiciona um único cliente à UI e caches sem recarregar tudo
        async function addSingleClientToUI(clientData, isUpdate = false) {
            try {
                // 1. Buscar o ID do cliente do Supabase (tanto para insert quanto update)
                let clientWithId = { ...clientData };
                try {
                    const { data: clientRecord } = await db
                        .from('clients')
                        .select('id')
                        .eq('address', clientData.address)
                        .limit(1);

                    if (clientRecord && clientRecord.length > 0) {
                        clientWithId.id = clientRecord[0].id;
                    } else if (!isUpdate) {
                        clientWithId.id = 'new_' + Date.now();
                    }
                } catch (e) {
                    if (!isUpdate) {
                        clientWithId.id = 'new_' + Date.now();
                    }
                }

                // 2. Atualizar cache em memória (clientesCache)
                // SEMPRE verifica se já existe para evitar duplicação
                if (clientesCache.data) {
                    const existingCacheIdx = clientesCache.data.findIndex(c => c.address === clientData.address);
                    if (existingCacheIdx !== -1) {
                        // Atualiza registro existente
                        clientesCache.data[existingCacheIdx] = { ...clientesCache.data[existingCacheIdx], ...clientWithId };
                    } else if (!isUpdate) {
                        // Adiciona novo apenas se não for update e não existir
                        clientesCache.data.unshift(clientWithId);
                    }
                    clientesCache.timestamp = Date.now();
                }

                // 3. Atualizar allClientes
                // SEMPRE verifica se já existe para evitar duplicação
                if (allClientes) {
                    const existingIdx = allClientes.findIndex(c => c.address === clientData.address);
                    if (existingIdx !== -1) {
                        // Atualiza registro existente
                        allClientes[existingIdx] = { ...allClientes[existingIdx], ...clientWithId };
                    } else if (!isUpdate) {
                        // Adiciona novo apenas se não for update e não existir
                        allClientes.unshift(clientWithId);
                    }
                }

                // 4. Atualizar IndexedDB cache
                try {
                    const cachedClients = await getAllFromOfflineDB('cachedClients');
                    if (cachedClients) {
                        const existingIdx = cachedClients.findIndex(c => c.address === clientData.address);
                        if (existingIdx !== -1) {
                            cachedClients[existingIdx] = { ...cachedClients[existingIdx], ...clientWithId };
                        } else if (!isUpdate) {
                            cachedClients.unshift(clientWithId);
                        }
                        await saveCacheToDB('cachedClients', cachedClients);
                    }
                } catch (cacheErr) {}

                // 5. Re-renderizar lista de clientes (operação leve, apenas DOM)
                if (allClientes && allClientes.length > 0) {
                    renderClientes(allClientes);
                }

                // 6. Atualizar marcadores de clientes no mapa se visíveis
                if (markersVisible && map && map.getSource && map.getSource('clientes') && clientWithId.latitude && clientWithId.longitude) {
                    const source = map.getSource('clientes');
                    const currentData = source._data;
                    if (currentData && currentData.features) {
                        if (isUpdate) {
                            // Atualiza feature existente - usa comparação normalizada para maior robustez
                            const normalizedClientAddr = normalizeAddressForComparison(clientData.address);
                            const updatedFeatures = currentData.features.map(f => {
                                const normalizedFeatureAddr = normalizeAddressForComparison(f.properties.address);
                                if (normalizedFeatureAddr === normalizedClientAddr) {
                                    return {
                                        ...f,
                                        geometry: {
                                            type: 'Point',
                                            coordinates: [clientWithId.longitude, clientWithId.latitude]
                                        },
                                        properties: {
                                            ...f.properties,
                                            latitude: clientWithId.latitude,
                                            longitude: clientWithId.longitude
                                        }
                                    };
                                }
                                return f;
                            });
                            source.setData({ type: 'FeatureCollection', features: updatedFeatures });
                        } else {
                            // Adiciona novo feature
                            const newFeature = {
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: [clientWithId.longitude, clientWithId.latitude]
                                },
                                properties: {
                                    id: clientWithId.id,
                                    address: clientWithId.address,
                                    latitude: clientWithId.latitude,
                                    longitude: clientWithId.longitude
                                }
                            };
                            source.setData({
                                type: 'FeatureCollection',
                                features: [...currentData.features, newFeature]
                            });
                        }
                    }
                }

                // 7. Atualizar marcadores de rota se visíveis (mudar cor de vermelho para verde/roxo)
                if (map && map.getSource && map.getSource('route-stops')) {
                    await updateRouteMarkerForNewClient(clientData);
                }

            } catch (err) {
                // Erro na atualização incremental - fallback silencioso
            }
        }

        // PERFORMANCE: Atualiza um marcador de rota específico quando um cliente é cadastrado
        // Se o marcador não existia (item sem coordenadas), adiciona um novo marcador verde
        async function updateRouteMarkerForNewClient(clientData) {
            try {
                const source = map.getSource('route-stops');
                if (!source || !source._data) return;

                const currentData = source._data;
                const features = currentData.features || [];

                const normalizedNewAddr = normalizeAddressForComparison(clientData.address);

                // Extrai componentes do endereço cadastrado para comparação semântica
                const newAddrComponents = extractAddressComponentsSimple(clientData.address);

                let updated = false;
                let foundExisting = false;
                const iconsToGenerate = new Set(); // Coleta ícones que precisam ser gerados

                // Primeira passada: identifica matches e coleta ícones necessários
                const updatedFeatures = features.map(feature => {
                    const props = feature.properties;
                    const featureAddr = props.address || '';
                    const normalizedFeatureAddr = normalizeAddressForComparison(featureAddr);

                    // STEP 1: Comparação exata primeiro
                    let isMatch = normalizedFeatureAddr === normalizedNewAddr;

                    // STEP 2: Comparação por componentes (rua + número)
                    if (!isMatch && newAddrComponents.primary && newAddrComponents.number) {
                        const featureComponents = extractAddressComponentsSimple(featureAddr);
                        if (featureComponents.primary === newAddrComponents.primary &&
                            featureComponents.number === newAddrComponents.number) {
                            isMatch = true;
                        }
                    }

                    // STEP 3: Verifica em allAddresses
                    if (!isMatch && props.allAddresses) {
                        const allAddrs = props.allAddresses.split('|||');
                        isMatch = allAddrs.some(addr => {
                            if (normalizeAddressForComparison(addr) === normalizedNewAddr) return true;
                            if (newAddrComponents.primary && newAddrComponents.number) {
                                const addrComponents = extractAddressComponentsSimple(addr);
                                return addrComponents.primary === newAddrComponents.primary &&
                                       addrComponents.number === newAddrComponents.number;
                            }
                            return false;
                        });
                    }

                    if (isMatch) {
                        foundExisting = true;
                        // Atualiza tanto marcadores não registrados (vermelho) quanto marcadores de similaridade (roxo)
                        if (!props.isRegistered || props.matchType === 'similarity') {
                            updated = true;
                            const packageCount = props.packageCount || 1;
                            const newIconId = `pin-green-${packageCount}`;
                            iconsToGenerate.add(newIconId);

                            // Salva dados originais para permitir reversão após exclusão do cliente
                            const previousMatchType = props.matchType || null;
                            const previousMatchedClientAddress = props.matchedClientAddress || '';
                            const previousCoordinates = feature.geometry.coordinates;
                            const previousIsRegistered = props.isRegistered || false;

                            return {
                                ...feature,
                                geometry: {
                                    type: 'Point',
                                    coordinates: [clientData.longitude, clientData.latitude]
                                },
                                properties: {
                                    ...props,
                                    isRegistered: true,
                                    matchType: 'exact',
                                    icon: newIconId,
                                    latitude: clientData.latitude,
                                    longitude: clientData.longitude,
                                    // Salva estado anterior para reversão
                                    previousMatchType: previousMatchType,
                                    previousMatchedClientAddress: previousMatchedClientAddress,
                                    previousCoordinates: JSON.stringify(previousCoordinates),
                                    previousIsRegistered: previousIsRegistered
                                }
                            };
                        }
                    }
                    return feature;
                });

                // Se não encontrou marcador existente, verifica no cache da planilha
                if (!foundExisting && clientData.latitude && clientData.longitude) {
                    try {
                        const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedPlanilha && cachedPlanilha.length > 0) {
                            const matchingItems = cachedPlanilha.filter(item => {
                                if (!item.destination_address) return false;
                                const normalizedItemAddr = normalizeAddressForComparison(item.destination_address);
                                if (normalizedItemAddr === normalizedNewAddr) return true;
                                if (newAddrComponents.primary && newAddrComponents.number) {
                                    const itemComponents = extractAddressComponentsSimple(item.destination_address);
                                    return itemComponents.primary === newAddrComponents.primary &&
                                           itemComponents.number === newAddrComponents.number;
                                }
                                return false;
                            });

                            if (matchingItems.length > 0) {
                                const packageCount = matchingItems.length;
                                const sequences = matchingItems.map(i => i.sequence).filter(s => s).join(', ');
                                const stops = matchingItems.map(i => i.stop).filter(s => s).join(', ');
                                const ids = matchingItems.map(i => i.id).join(',');
                                const iconId = `pin-green-${Math.min(packageCount, 9)}`;
                                iconsToGenerate.add(iconId);

                                const newFeature = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: [clientData.longitude, clientData.latitude]
                                    },
                                    properties: {
                                        packageCount: packageCount,
                                        allStops: stops,
                                        icon: iconId,
                                        address: clientData.address,
                                        allAddresses: clientData.address,
                                        addressSequencePairs: JSON.stringify(matchingItems.map(i => ({
                                            address: i.destination_address,
                                            sequence: i.sequence
                                        }))),
                                        sequences: sequences,
                                        isRegistered: true,
                                        matchType: 'exact',
                                        matchedClientAddress: '',
                                        wasDeactivated: false,
                                        originalMatchType: null,
                                        originalMatchedClientAddress: '',
                                        originalCoordinates: null,
                                        ids: ids,
                                        deliveryStatus: matchingItems[0].delivery_status || 'pending',
                                        bairro: clientData.bairro || matchingItems[0].bairro || '',
                                        zipcode: clientData.zipcode || matchingItems[0].zipcode || '',
                                        latitude: clientData.latitude,
                                        longitude: clientData.longitude
                                    }
                                };

                                updatedFeatures.push(newFeature);
                                updated = true;
                            }
                        }
                    } catch (planilhaErr) {
                        // Erro ao buscar planilha, continua sem adicionar novo marcador
                    }
                }

                if (updated) {
                    // IMPORTANTE: Gera todos os ícones ANTES de atualizar o mapa
                    const iconPromises = Array.from(iconsToGenerate).map(iconId => {
                        return new Promise((resolve) => {
                            if (map.hasImage(iconId)) {
                                resolve();
                                return;
                            }
                            try {
                                const parts = iconId.replace('pin-', '').split('-');
                                const count = parseInt(parts.pop());
                                const color = parts.join('-') || 'green';
                                const { dataUrl, pixelRatio } = generatePinIcon(count, color);
                                const img = new Image();
                                img.onload = () => {
                                    if (!map.hasImage(iconId)) {
                                        map.addImage(iconId, img, { pixelRatio: pixelRatio });
                                    }
                                    resolve();
                                };
                                img.onerror = () => resolve();
                                img.src = dataUrl;
                            } catch (e) {
                                resolve();
                            }
                        });
                    });

                    // Aguarda todos os ícones serem gerados
                    await Promise.all(iconPromises);

                    const newGeojson = {
                        type: 'FeatureCollection',
                        features: updatedFeatures
                    };

                    // Atualiza o mapa
                    source.setData(newGeojson);

                    // Atualiza estatísticas na UI
                    const stats = updateRouteStatsAfterRegistration();

                    // Salva o cache atualizado para persistir após F5
                    try {
                        await saveRouteMarkersToCache(newGeojson, stats);
                    } catch (cacheErr) {
                        // Cache save failed, but visual update succeeded
                    }

                    // Atualiza o fixed stats panel
                    updateFixedStatsPanel(stats);
                }
            } catch (err) {
                console.error('Erro ao atualizar marcador de rota:', err);
            }
        }

        // PERFORMANCE: Atualiza estatísticas de rota após cadastro
        // Retorna objeto com estatísticas para salvar no cache
        function updateRouteStatsAfterRegistration() {
            try {
                const source = map.getSource('route-stops');
                if (!source || !source._data) return null;

                const features = source._data.features || [];

                // Calcula novas estatísticas
                const activeFeatures = features.filter(f =>
                    f.properties.deliveryStatus !== 'delivered' &&
                    f.properties.deliveryStatus !== 'not_delivered'
                );

                const registered = activeFeatures.filter(f => f.properties.isRegistered).length;
                const unregistered = activeFeatures.filter(f => !f.properties.isRegistered).length;
                const total = activeFeatures.length;

                // Calcula pacotes pendentes e entregues
                const pending = activeFeatures.reduce((sum, f) => sum + (f.properties.packageCount || 1), 0);
                const delivered = features
                    .filter(f => f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered')
                    .reduce((sum, f) => sum + (f.properties.packageCount || 1), 0);

                // Atualiza UI
                const statsEl = document.querySelector('.route-stats');
                if (statsEl) {
                    const registeredEl = statsEl.querySelector('.stat-registered');
                    const unregisteredEl = statsEl.querySelector('.stat-unregistered');
                    const totalEl = statsEl.querySelector('.stat-total');

                    if (registeredEl) registeredEl.textContent = registered;
                    if (unregisteredEl) unregisteredEl.textContent = unregistered;
                    if (totalEl) totalEl.textContent = total;
                }

                // Retorna estatísticas para o cache
                return {
                    total: total,
                    registered: registered,
                    unregistered: unregistered,
                    pending: pending,
                    delivered: delivered
                };
            } catch (err) {
                return null;
            }
        }

        // PERFORMANCE: Remove um único cliente da UI e caches sem recarregar tudo
        async function removeSingleClientFromUI(clientId) {
            try {
                // Converte para string para comparação consistente
                const clientIdStr = String(clientId);

                // 0. Encontrar o cliente antes de remover (para atualizar marcador de rota)
                let removedClient = null;
                if (clientesCache.data) {
                    removedClient = clientesCache.data.find(c => String(c.id) === clientIdStr);
                }
                if (!removedClient && allClientes) {
                    removedClient = allClientes.find(c => String(c.id) === clientIdStr);
                }

                // 1. Remover do cache em memória
                if (clientesCache.data) {
                    clientesCache.data = clientesCache.data.filter(c => String(c.id) !== clientIdStr);
                    clientesCache.timestamp = Date.now();
                }

                // 2. Remover de allClientes
                if (allClientes) {
                    allClientes = allClientes.filter(c => String(c.id) !== clientIdStr);
                }

                // 3. Remover do IndexedDB cache
                try {
                    const cachedClients = await getAllFromOfflineDB('cachedClients');
                    if (cachedClients) {
                        const filtered = cachedClients.filter(c => String(c.id) !== clientIdStr);
                        await saveCacheToDB('cachedClients', filtered);
                    }
                } catch (cacheErr) {}

                // 4. Re-renderizar lista de clientes
                if (allClientes && allClientes.length > 0) {
                    renderClientes(allClientes);
                } else {
                    // Mostrar estado vazio
                    loadingState.style.display = 'none';
                    emptyState.style.display = 'block';
                    clienteList.style.display = 'none';
                    clienteCount.textContent = 'Nenhum cliente';
                }

                // 5. Remover marcador do mapa se visível (marcadores azuis de clientes)
                if (markersVisible && map && map.getSource && map.getSource('clientes')) {
                    const source = map.getSource('clientes');
                    const currentData = source._data;
                    if (currentData && currentData.features) {
                        const filteredFeatures = currentData.features.filter(f =>
                            String(f.properties.id) !== clientIdStr
                        );
                        source.setData({
                            type: 'FeatureCollection',
                            features: filteredFeatures
                        });
                    }
                }

                // 6. Atualizar marcador de rota (reverter para estado original)
                if (removedClient && removedClient.address && map && map.getSource && map.getSource('route-stops')) {
                    await revertRouteMarkerAfterClientDeletion(removedClient);
                }

            } catch (err) {
                // Erro na remoção incremental - fallback para reload completo
                await loadClientes();
            }
        }

        // PERFORMANCE: Reverte um marcador de rota ao estado original após exclusão de cliente
        async function revertRouteMarkerAfterClientDeletion(deletedClient) {
            try {
                const source = map.getSource('route-stops');
                if (!source || !source._data) return;

                const currentData = source._data;
                const features = currentData.features || [];

                const normalizedDeletedAddr = normalizeAddressForComparison(deletedClient.address);
                let updated = false;
                const iconsToGenerate = new Set();

                // Buscar dados originais da planilha para ver se tinha coordenadas
                let planilhaItem = null;
                try {
                    const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                    if (cachedPlanilha && cachedPlanilha.length > 0) {
                        planilhaItem = cachedPlanilha.find(item => {
                            if (!item.destination_address) return false;
                            const normalizedItemAddr = normalizeAddressForComparison(item.destination_address);
                            return normalizedItemAddr === normalizedDeletedAddr;
                        });
                    }
                } catch (e) {}

                // Verificar se a planilha original tinha coordenadas
                const hadOriginalCoords = planilhaItem && planilhaItem.latitude && planilhaItem.longitude;

                const updatedFeatures = features.map(feature => {
                    const props = feature.properties;
                    const featureAddr = props.address || '';
                    const normalizedFeatureAddr = normalizeAddressForComparison(featureAddr);

                    let isMatch = normalizedFeatureAddr === normalizedDeletedAddr;
                    if (!isMatch && props.allAddresses) {
                        const allAddrs = props.allAddresses.split('|||');
                        isMatch = allAddrs.some(addr =>
                            normalizeAddressForComparison(addr) === normalizedDeletedAddr
                        );
                    }

                    if (isMatch && props.isRegistered) {
                        updated = true;
                        const packageCount = props.packageCount || 1;

                        // PRIORIDADE 1: Verificar se tinha estado anterior salvo (similaridade/roxo)
                        if (props.previousMatchType === 'similarity' && props.previousCoordinates) {
                            try {
                                const previousCoords = JSON.parse(props.previousCoordinates);
                                const newIconId = `pin-purple-${packageCount}`;
                                iconsToGenerate.add(newIconId);

                                return {
                                    ...feature,
                                    geometry: {
                                        type: 'Point',
                                        coordinates: previousCoords
                                    },
                                    properties: {
                                        ...props,
                                        isRegistered: true,
                                        matchType: 'similarity',
                                        matchedClientAddress: props.previousMatchedClientAddress || '',
                                        icon: newIconId,
                                        latitude: previousCoords[1],
                                        longitude: previousCoords[0],
                                        // Limpa dados salvos
                                        previousMatchType: null,
                                        previousMatchedClientAddress: null,
                                        previousCoordinates: null,
                                        previousIsRegistered: null
                                    }
                                };
                            } catch (parseErr) {
                                // Falha ao parsear coordenadas, continua para próxima verificação
                            }
                        }

                        // PRIORIDADE 2: Tinha coordenadas originais da planilha - volta para vermelho
                        if (hadOriginalCoords) {
                            const newIconId = `pin-red-${packageCount}`;
                            iconsToGenerate.add(newIconId);

                            return {
                                ...feature,
                                geometry: {
                                    type: 'Point',
                                    coordinates: [planilhaItem.longitude, planilhaItem.latitude]
                                },
                                properties: {
                                    ...props,
                                    isRegistered: false,
                                    matchType: null,
                                    icon: newIconId,
                                    latitude: planilhaItem.latitude,
                                    longitude: planilhaItem.longitude,
                                    // Limpa dados salvos
                                    previousMatchType: null,
                                    previousMatchedClientAddress: null,
                                    previousCoordinates: null,
                                    previousIsRegistered: null
                                }
                            };
                        }

                        // PRIORIDADE 3: Verifica se tinha coordenadas anteriores (vermelho)
                        if (props.previousCoordinates && !props.previousIsRegistered) {
                            try {
                                const previousCoords = JSON.parse(props.previousCoordinates);
                                const newIconId = `pin-red-${packageCount}`;
                                iconsToGenerate.add(newIconId);

                                return {
                                    ...feature,
                                    geometry: {
                                        type: 'Point',
                                        coordinates: previousCoords
                                    },
                                    properties: {
                                        ...props,
                                        isRegistered: false,
                                        matchType: null,
                                        icon: newIconId,
                                        latitude: previousCoords[1],
                                        longitude: previousCoords[0],
                                        // Limpa dados salvos
                                        previousMatchType: null,
                                        previousMatchedClientAddress: null,
                                        previousCoordinates: null,
                                        previousIsRegistered: null
                                    }
                                };
                            } catch (parseErr) {
                                // Falha ao parsear coordenadas
                            }
                        }

                        // Não tinha coordenadas originais - marca para remoção
                        return null;
                    }
                    return feature;
                }).filter(f => f !== null); // Remove marcadores que não tinham coords originais

                if (updated) {
                    // Gera ícones necessários antes de atualizar o mapa
                    const iconPromises = Array.from(iconsToGenerate).map(iconId => {
                        return new Promise((resolve) => {
                            if (map.hasImage(iconId)) {
                                resolve();
                                return;
                            }
                            try {
                                const parts = iconId.replace('pin-', '').split('-');
                                const count = parseInt(parts.pop());
                                const color = parts.join('-') || 'red';
                                const { dataUrl, pixelRatio } = generatePinIcon(count, color);
                                const img = new Image();
                                img.onload = () => {
                                    if (!map.hasImage(iconId)) {
                                        map.addImage(iconId, img, { pixelRatio: pixelRatio });
                                    }
                                    resolve();
                                };
                                img.onerror = () => resolve();
                                img.src = dataUrl;
                            } catch (e) {
                                resolve();
                            }
                        });
                    });

                    await Promise.all(iconPromises);

                    const newGeojson = {
                        type: 'FeatureCollection',
                        features: updatedFeatures
                    };

                    // Atualiza o mapa
                    source.setData(newGeojson);

                    // Atualiza estatísticas
                    const stats = updateRouteStatsAfterRegistration();

                    // Salva cache atualizado
                    try {
                        await saveRouteMarkersToCache(newGeojson, stats);
                    } catch (cacheErr) {}

                    // Atualiza o fixed stats panel
                    updateFixedStatsPanel(stats);
                }
            } catch (err) {
                // Erro ao reverter marcador - falha silenciosa
                console.error('Erro ao reverter marcador de rota:', err);
            }
        }

        // Show error modal
        function showErrorModal(message) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            modal.innerHTML = `
                <div style="background: var(--surface-light); padding: 24px; border-radius: 16px; box-shadow: var(--shadow); max-width: 400px; width: 90%; margin: 0 16px;">
                    <h3 style="font-size: 18px; font-weight: 700; margin-bottom: 16px; color: var(--text-light);">Erro</h3>
                    <p style="font-size: 14px; color: var(--text-muted-light); line-height: 1.6;">${message}</p>
                    <div style="display: flex; justify-content: flex-end; margin-top: 24px;">
                        <button id="errorOk" style="padding: 10px 20px; border: none; background: var(--primary); border-radius: 10px; font-family: inherit; font-size: 14px; font-weight: 600; cursor: pointer; color: white; transition: all 0.2s ease;">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.querySelector('#errorOk').addEventListener('click', () => {
                modal.remove();
            });
        }

        // Remove markers from map
        function removeMarkersFromMap() {
            if (!map || !map.getSource('clientes')) {
                return;
            }

            if (map.getLayer('clusters')) map.removeLayer('clusters');
            if (map.getLayer('cluster-count')) map.removeLayer('cluster-count');
            if (map.getLayer('unclustered-point')) map.removeLayer('unclustered-point');
            if (map.getSource('clientes')) map.removeSource('clientes');
        }

        // Add markers to map with clustering
        function addMarkersToMap(clientes) {
            if (!map || !map.loaded()) {
                return;
            }

            // Remove existing markers first
            removeMarkersFromMap();

            // Filter out clientes without coordinates
            const validClientes = clientes.filter(c => c.latitude && c.longitude);

            // Convert to GeoJSON
            const geojson = {
                type: 'FeatureCollection',
                features: validClientes.map(cliente => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [cliente.longitude, cliente.latitude]
                    },
                    properties: {
                        id: cliente.id,
                        address: cliente.address,
                        latitude: cliente.latitude,
                        longitude: cliente.longitude
                    }
                }))
            };

            // Add source with clustering
            map.addSource('clientes', {
                type: 'geojson',
                data: geojson,
                cluster: true,
                clusterMaxZoom: 14,
                clusterRadius: 50
            });

            // Cluster circles
            map.addLayer({
                id: 'clusters',
                type: 'circle',
                source: 'clientes',
                filter: ['has', 'point_count'],
                paint: {
                    'circle-color': [
                        'step',
                        ['get', 'point_count'],
                        '#0ea5e9',
                        10,
                        '#0284c7',
                        30,
                        '#0369a1'
                    ],
                    'circle-radius': [
                        'step',
                        ['get', 'point_count'],
                        20,
                        10,
                        30,
                        30,
                        40
                    ]
                }
            });

            // Cluster count
            map.addLayer({
                id: 'cluster-count',
                type: 'symbol',
                source: 'clientes',
                filter: ['has', 'point_count'],
                layout: {
                    'text-field': '{point_count_abbreviated}',
                    'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-size': 12
                },
                paint: {
                    'text-color': '#ffffff'
                }
            });

            // Individual points
            map.addLayer({
                id: 'unclustered-point',
                type: 'circle',
                source: 'clientes',
                filter: ['!', ['has', 'point_count']],
                paint: {
                    'circle-color': '#0ea5e9',
                    'circle-radius': 8,
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#fff'
                }
            });

            // Remove old event listeners if they exist
            map.off('click', 'clusters');
            map.off('click', 'unclustered-point');
            map.off('mouseenter', 'clusters');
            map.off('mouseleave', 'clusters');
            map.off('mouseenter', 'unclustered-point');
            map.off('mouseleave', 'unclustered-point');

            // Click on cluster to zoom
            map.on('click', 'clusters', (e) => {
                const features = map.queryRenderedFeatures(e.point, {
                    layers: ['clusters']
                });
                const clusterId = features[0].properties.cluster_id;
                map.getSource('clientes').getClusterExpansionZoom(
                    clusterId,
                    (err, zoom) => {
                        if (err) return;
                        map.easeTo({
                            center: features[0].geometry.coordinates,
                            zoom: zoom
                        });
                    }
                );
            });

            // Show popup on individual point click
            map.on('click', 'unclustered-point', (e) => {
                const coordinates = e.features[0].geometry.coordinates.slice();
                const { address, latitude, longitude } = e.features[0].properties;

                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(`<strong>${address}</strong><br><small>${parseFloat(latitude).toFixed(6)}, ${parseFloat(longitude).toFixed(6)}</small>`)
                    .addTo(map);
            });

            // Change cursor on hover
            map.on('mouseenter', 'clusters', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'clusters', () => {
                map.getCanvas().style.cursor = '';
            });
            map.on('mouseenter', 'unclustered-point', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'unclustered-point', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // ========================================
        // Route Markers Functionality (Native Mapbox Layers with custom pin icon)
        // ========================================
        const routeMarkersBtn = document.getElementById('routeMarkersBtn');
        let routeMarkersVisible = false;
        let routePopup = null;
        let routeClickHandlerAdded = false; // Flag para evitar duplicação de handlers

        // MEMORY MANAGEMENT: Função auxiliar para limpar routePopup de forma segura
        function closeRoutePopup() {
            if (routePopup) {
                ResourceRegistry.removePopup(routePopup);
                routePopup = null;
            }
        }

        // Função centralizada para configurar handlers de click nos marcadores de rota
        // Esta função é chamada APENAS UMA VEZ para evitar duplicação de handlers
        function setupRouteMarkerClickHandlers() {
            if (!map.getLayer('route-stops-pins')) return;

            // Handler de click no marcador
            map.on('click', 'route-stops-pins', handleRouteMarkerClick);

            // Cursor pointer no hover
            map.on('mouseenter', 'route-stops-pins', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'route-stops-pins', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // Handler de click no marcador de rota - cria o popup com todas as funcionalidades
        function handleRouteMarkerClick(e) {
            const feature = e.features[0];
            const coords = feature.geometry.coordinates.slice();
            const props = feature.properties;

            const sequencesArr = props.sequences ? props.sequences.split(', ') : [];
            const ordersHtml = sequencesArr.map(seq =>
                `<span class="route-popup-order">${seq}</span>`
            ).join('');

            // Check if there are multiple addresses in this stop
            const addressSequencePairs = props.addressSequencePairs ? JSON.parse(props.addressSequencePairs) : [];
            const hasMultipleAddresses = addressSequencePairs.length > 1;

            // Build bairro and CEP info display
            const bairroDisplay = props.bairro ? `<span style="font-size: 10px; color: #8b5cf6; font-weight: 500; padding: 2px 6px; background: rgba(139, 92, 246, 0.1); border-radius: 4px;">🏘️ ${props.bairro}</span>` : '';
            const cepDisplay = props.zipcode ? `<span style="font-size: 10px; color: #0ea5e9; font-weight: 500; padding: 2px 6px; background: rgba(14, 165, 233, 0.1); border-radius: 4px;">📮 ${props.zipcode}</span>` : '';
            const locationInfo = (bairroDisplay || cepDisplay) ? `<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; margin-bottom: 8px;">${bairroDisplay}${cepDisplay}</div>` : '';

            // Build address display with matched client address for similarity matches
            let addressDisplay = '';

            // Se for match por similaridade, mostrar endereço do cliente cadastrado acima (clicável para desativar similaridade)
            const similarityHeader = (props.matchType === 'similarity' && props.matchedClientAddress)
                ? `<div class="similarity-matched-address" data-ids="${props.ids}" style="font-size: 12px; font-weight: 600; color: #8b5cf6; margin-bottom: 4px; padding: 6px 8px; background: rgba(139, 92, 246, 0.1); border-radius: 6px; border-left: 3px solid #8b5cf6; cursor: pointer; transition: all 0.2s ease;"
                        onmouseover="this.style.background='rgba(139, 92, 246, 0.2)'; this.style.borderLeftWidth='4px';"
                        onmouseout="this.style.background='rgba(139, 92, 246, 0.1)'; this.style.borderLeftWidth='3px';">
                       📍 ${props.matchedClientAddress}
                       <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para usar coordenadas da planilha</div>
                   </div>
                   <div style="font-size: 10px; color: #64748b; margin-bottom: 8px; font-weight: 500;">
                       ↓ Endereço da planilha:
                   </div>`
                : '';

            // Se for marcador vermelho que foi desativado, mostrar opção de reativar similaridade
            const reactivateSimilarityHeader = (props.wasDeactivated && props.originalMatchedClientAddress)
                ? `<div class="reactivate-similarity-address" data-ids="${props.ids}" style="font-size: 11px; font-weight: 600; color: #ef4444; margin-bottom: 8px; padding: 6px 8px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid #ef4444; cursor: pointer; transition: all 0.2s ease;"
                        onmouseover="this.style.background='rgba(139, 92, 246, 0.15)'; this.style.borderLeftColor='#8b5cf6';"
                        onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderLeftColor='#ef4444';">
                       🔄 Voltar para: ${props.originalMatchedClientAddress}
                       <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para reativar similaridade</div>
                   </div>`
                : '';

            if (hasMultipleAddresses) {
                addressDisplay = `
                    ${similarityHeader}
                    ${reactivateSimilarityHeader}
                    <div style="font-size: 11px; color: #8b5cf6; font-weight: 600; margin-bottom: 4px;">📦 ${addressSequencePairs.length} pacotes nesta parada:</div>
                    ${locationInfo}
                    <div style="font-size: 11px; line-height: 1.5; max-height: 120px; overflow-y: auto; margin-bottom: 8px;">
                        ${addressSequencePairs.map(pair => `<div style="margin-bottom: 3px;"><span style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 2px 6px; border-radius: 4px; font-weight: 600; margin-right: 4px; font-size: 10px;">${pair.sequence}</span> ${pair.address}</div>`).join('')}
                    </div>
                `;
            } else if (addressSequencePairs.length === 1) {
                addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${addressSequencePairs[0].address}</div>${locationInfo}`;
            } else {
                addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${props.address}</div>${locationInfo}`;
            }

            // Determine current status for button styling
            const currentStatus = props.deliveryStatus || 'pending';
            const isDelivered = currentStatus === 'delivered';
            const isNotDelivered = currentStatus === 'not_delivered';

            closeRoutePopup();

            // Only show order section at bottom if single address (multiple addresses show order inline)
            const orderSection = hasMultipleAddresses ? '' : `
                <div style="display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 6px;">
                    <span style="font-size: 11px; color: #64748b;">Ordem:</span>
                    <div class="route-popup-orders">${ordersHtml || '<span style="color: #94a3b8;">Sem ordem</span>'}</div>
                </div>
            `;

            // Responsive maxWidth for popup - aumentado para acomodar 3 botões
            const isMobile = window.innerWidth <= 480;
            const popupMaxWidth = isMobile ? '280px' : '320px';

            routePopup = ResourceRegistry.registerPopup(new mapboxgl.Popup({
                offset: [0, -50],
                closeButton: true,
                closeOnClick: true,
                maxWidth: popupMaxWidth
            })
                .setLngLat(coords)
                .setHTML(`
                    <div class="route-popup-content">
                        ${addressDisplay}
                        ${orderSection}
                        <div class="route-popup-actions">
                            <button class="route-popup-btn ${isDelivered ? 'active' : ''}" data-action="delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
                                <span class="btn-text">${isDelivered ? 'Desfazer' : 'Entregue'}</span>
                            </button>
                            <button class="route-popup-btn not-delivered ${isNotDelivered ? 'active' : ''}" data-action="not_delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                                <span class="btn-text">${isNotDelivered ? 'Desfazer' : 'Não entreg'}</span>
                            </button>
                            <button class="route-popup-btn navigate" data-lng="${coords[0]}" data-lat="${coords[1]}" data-address="${props.address}" data-order="${sequencesArr.join(', ') || '-'}" data-ids="${props.ids}">
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>
                                Navegar
                            </button>
                        </div>
                    </div>
                `)
                .addTo(map));

            // Add click handlers for delivery buttons
            const popupContent = routePopup.getElement();
            popupContent.querySelectorAll('.route-popup-btn:not(.navigate)').forEach(btn => {
                btn.addEventListener('click', async (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();

                    const action = btn.dataset.action;
                    const ids = btn.dataset.ids.split(',').map(id => parseInt(id));

                    let statusToSave = null;

                    if (btn.classList.contains('active')) {
                        statusToSave = 'pending';
                    } else {
                        statusToSave = action;
                    }

                    // OPTIMISTIC UPDATE - Atualiza UI imediatamente
                    closeRoutePopup();

                    // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                    lastRouteMarkersSave = Date.now();

                    // Atualiza a propriedade do marcador localmente
                    const sourceData = map.getSource('route-stops')._data;
                    const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);
                    if (markerFeature) {
                        markerFeature.properties.deliveryStatus = statusToSave;

                        // Atualiza o ícone baseado no novo status e tipo de match
                        let newColor;
                        if (statusToSave === 'delivered') {
                            newColor = 'gray';
                        } else if (statusToSave === 'not_delivered') {
                            newColor = 'gray-x';
                        } else if (props.isRegistered) {
                            newColor = props.matchType === 'exact' ? 'green' : 'purple';
                        } else {
                            newColor = 'red';
                        }

                        const newIconName = `pin-${newColor}-${props.packageCount}`;
                        markerFeature.properties.icon = newIconName;

                        // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE para atualizar as propriedades
                        // O ícone será carregado em background e re-renderizado quando pronto
                        map.getSource('route-stops').setData(sourceData);
                        updateRouteMarkersCache(sourceData);

                        // Carrega ícone em background se não existir
                        if (!map.hasImage(newIconName)) {
                            const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                            const img = new Image();
                            img.onload = () => {
                                if (!map.hasImage(newIconName)) {
                                    map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                }
                                // Re-renderiza para mostrar o ícone correto
                                map.getSource('route-stops').setData(sourceData);
                            };
                            img.src = dataUrl;
                        }
                    }

                    // Update fixed stats panel after status change
                    updateFixedStatsPanel();

                    // Sincroniza em background (não bloqueia a UI)
                    updateDeliveryStatus(ids, statusToSave).catch(() => {});
                });
            });

            // Add click handler for navigate button
            const navBtn = popupContent.querySelector('.route-popup-btn.navigate');
            if (navBtn) {
                navBtn.addEventListener('click', (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();
                    const destLng = parseFloat(navBtn.dataset.lng);
                    const destLat = parseFloat(navBtn.dataset.lat);
                    const destAddress = navBtn.dataset.address;
                    const destOrder = navBtn.dataset.order || '-';
                    const destIds = navBtn.dataset.ids || '';
                    closeRoutePopup();
                    startNavigation(destLng, destLat, destAddress, destOrder, destIds);
                });
            }

            // Handler para desativar similaridade (endereço roxo clicável)
            const similarityAddress = popupContent.querySelector('.similarity-matched-address');
            if (similarityAddress) {
                similarityAddress.addEventListener('click', async (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();

                    const ids = similarityAddress.dataset.ids.split(',').map(id => parseInt(id));

                    // Atualiza UI imediatamente
                    closeRoutePopup();

                    // Busca coordenadas originais da planilha
                    let originalLat = null;
                    let originalLng = null;

                    try {
                        const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedPlanilha && cachedPlanilha.length > 0) {
                            const itemsForThisMarker = cachedPlanilha.filter(item =>
                                ids.includes(item.id) && item.latitude && item.longitude
                            );
                            if (itemsForThisMarker.length > 0) {
                                // Usa a média das coordenadas se houver múltiplos itens
                                originalLat = itemsForThisMarker.reduce((sum, item) => sum + item.latitude, 0) / itemsForThisMarker.length;
                                originalLng = itemsForThisMarker.reduce((sum, item) => sum + item.longitude, 0) / itemsForThisMarker.length;
                            }
                        }
                    } catch (e) {
                        console.error('Erro ao buscar coordenadas da planilha:', e);
                    }

                    // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                    lastRouteMarkersSave = Date.now();

                    // Atualiza o marcador para vermelho (não cadastrado)
                    const sourceData = map.getSource('route-stops')._data;
                    const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);
                    if (markerFeature) {
                        // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                        // porque props pode estar desatualizado após setData() de reativação
                        const currentProps = markerFeature.properties;

                        markerFeature.properties.isRegistered = false;
                        markerFeature.properties.matchType = null;
                        markerFeature.properties.wasDeactivated = true;
                        markerFeature.properties.originalMatchedClientAddress = currentProps.matchedClientAddress;
                        markerFeature.properties.matchedClientAddress = null;

                        // Salva as coordenadas atuais (do cliente) para poder reativar depois
                        markerFeature.properties.originalCoordinates = JSON.stringify(markerFeature.geometry.coordinates);

                        // Move o marcador para as coordenadas da planilha (se disponíveis)
                        if (originalLat && originalLng) {
                            markerFeature.geometry.coordinates = [originalLng, originalLat];
                        }

                        // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                        const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                        let newColor;
                        if (currentDeliveryStatus === 'delivered') {
                            newColor = 'gray';
                        } else if (currentDeliveryStatus === 'not_delivered') {
                            newColor = 'gray-x';
                        } else {
                            newColor = 'red'; // Não cadastrado (similaridade desativada)
                        }
                        const newIconName = `pin-${newColor}-${props.packageCount}`;
                        markerFeature.properties.icon = newIconName;

                        // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                        map.getSource('route-stops').setData(sourceData);
                        updateRouteMarkersCache(sourceData);

                        // Carrega ícone em background se não existir
                        if (!map.hasImage(newIconName)) {
                            const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                            const img = new Image();
                            img.onload = () => {
                                if (!map.hasImage(newIconName)) {
                                    map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                }
                                // Re-renderiza para mostrar o ícone correto
                                map.getSource('route-stops').setData(sourceData);
                            };
                            img.src = dataUrl;
                        }

                        // Anima o mapa para a nova posição
                        if (originalLat && originalLng) {
                            map.flyTo({ center: [originalLng, originalLat], zoom: 16, duration: 1000 });
                        }
                    }

                    updateFixedStatsPanel();

                    // Salva no banco de dados (passa as coordenadas da planilha)
                    updateSimilarityOverride(ids, true, originalLat, originalLng).catch(() => {});
                });
            }

            // Handler para reativar similaridade
            const reactivateAddress = popupContent.querySelector('.reactivate-similarity-address');
            if (reactivateAddress) {
                reactivateAddress.addEventListener('click', async (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();

                    const ids = reactivateAddress.dataset.ids.split(',').map(id => parseInt(id));

                    closeRoutePopup();

                    // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                    lastRouteMarkersSave = Date.now();

                    // Atualiza o marcador para verde/roxo
                    const sourceData = map.getSource('route-stops')._data;
                    const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);
                    if (markerFeature) {
                        // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                        // porque props pode estar desatualizado após setData() de sincronização
                        const currentProps = markerFeature.properties;

                        markerFeature.properties.isRegistered = true;
                        markerFeature.properties.matchType = 'similarity';
                        markerFeature.properties.wasDeactivated = false;
                        markerFeature.properties.matchedClientAddress = currentProps.originalMatchedClientAddress;
                        markerFeature.properties.originalMatchedClientAddress = null;

                        // Restaura as coordenadas do cliente (se disponíveis)
                        let newLng = null;
                        let newLat = null;
                        if (currentProps.originalCoordinates) {
                            try {
                                const originalCoords = JSON.parse(currentProps.originalCoordinates);
                                if (Array.isArray(originalCoords) && originalCoords.length === 2) {
                                    newLng = originalCoords[0];
                                    newLat = originalCoords[1];
                                    markerFeature.geometry.coordinates = [newLng, newLat];
                                }
                            } catch (e) {
                                console.error('Erro ao parsear coordenadas originais:', e);
                            }
                        }
                        markerFeature.properties.originalCoordinates = null;

                        // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                        const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                        let newColor;
                        if (currentDeliveryStatus === 'delivered') {
                            newColor = 'gray';
                        } else if (currentDeliveryStatus === 'not_delivered') {
                            newColor = 'gray-x';
                        } else {
                            newColor = 'purple'; // Similaridade reativada
                        }
                        const newIconName = `pin-${newColor}-${props.packageCount}`;
                        markerFeature.properties.icon = newIconName;

                        // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                        map.getSource('route-stops').setData(sourceData);
                        updateRouteMarkersCache(sourceData);

                        // Carrega ícone em background se não existir
                        if (!map.hasImage(newIconName)) {
                            const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                            const img = new Image();
                            img.onload = () => {
                                if (!map.hasImage(newIconName)) {
                                    map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                }
                                // Re-renderiza para mostrar o ícone correto
                                map.getSource('route-stops').setData(sourceData);
                            };
                            img.src = dataUrl;
                        }

                        // Anima o mapa para a posição do cliente
                        if (newLng && newLat) {
                            map.flyTo({ center: [newLng, newLat], zoom: 16, duration: 1000 });
                        }
                    }

                    updateFixedStatsPanel();

                    // Salva no banco de dados (reativa similaridade)
                    updateSimilarityOverride(ids, false).catch(() => {});
                });
            }
        }

        // Update delivery status in Supabase or offline
        async function updateDeliveryStatus(ids, status) {
            if (!ids || ids.length === 0) {
                // IDs vazios
                return false;
            }


            // If offline, save locally
            if (!isOnline) {
                try {
                    await saveToOfflineDB('pendingDeliveryStatus', {
                        ids: ids,
                        status: status
                    });
                    updateOfflineIndicator();
                    return true;
                } catch (err) {
                    // Erro ao salvar status offline
                    return false;
                }
            }

            // If online, try Supabase
            try {
                const { data, error } = await db
                    .from('planilha')
                    .update({ delivery_status: status })
                    .in('id', ids)
                    .select();

                if (error) {
                    // Erro do Supabase
                    throw error;
                }

                // Update local cache with new status
                try {
                    const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                    if (cachedPlanilha && cachedPlanilha.length > 0) {
                        const updatedPlanilha = cachedPlanilha.map(item => {
                            if (ids.includes(item.id)) {
                                return { ...item, delivery_status: status };
                            }
                            return item;
                        });
                        await saveCacheToDB('cachedPlanilha', updatedPlanilha);
                    }
                } catch (cacheErr) {
                    // Cache update failed, but Supabase update succeeded
                }

                return data && data.length > 0;
            } catch (error) {
                try {
                    await saveToOfflineDB('pendingDeliveryStatus', { ids, status });

                    // Also update local cache when saving offline
                    try {
                        const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedPlanilha && cachedPlanilha.length > 0) {
                            const updatedPlanilha = cachedPlanilha.map(item => {
                                if (ids.includes(item.id)) {
                                    return { ...item, delivery_status: status };
                                }
                                return item;
                            });
                            await saveCacheToDB('cachedPlanilha', updatedPlanilha);
                        }
                    } catch (cacheErr) {}

                    updateOfflineIndicator();
                    return true;
                } catch (offlineErr) {
                    ErrorHandler.handle(error, { action: 'updateDeliveryStatus', ids, status }, {
                        customMessage: 'Erro ao atualizar status de entrega.'
                    });
                    return false;
                }
            }
        }

        // Sync delivery status from Supabase to update local cache and map markers
        // This is called when loading cached markers to ensure cross-device sync
        async function syncDeliveryStatusFromSupabase() {
            if (!isOnline || !map || !map.getSource('route-stops')) return;

            // BLOQUEIO: Não busca dados do servidor enquanto está enviando dados offline
            // Isso evita sobrescrever alterações locais com dados antigos do servidor
            if (isSyncingPendingData) return;

            // PROTEÇÃO CONTRA PISCADA: Se houve uma atualização local recente (< 2s),
            // não sincroniza para evitar race condition com dados antigos do servidor
            // Aumentado para 2000ms para evitar piscadas em redes lentas
            if (Date.now() - lastRouteMarkersSave < 2000) return;

            try {
                // Fetch all delivery statuses from Supabase
                const { data: planilhaData, error } = await db
                    .from('planilha')
                    .select('id, delivery_status, similarity_disabled, similarity_original_lat, similarity_original_lng')
                    .not('destination_address', 'is', null);

                if (error || !planilhaData) return;

                // Create a map of id -> status for quick lookup
                const statusMap = {};
                planilhaData.forEach(item => {
                    statusMap[item.id] = {
                        status: item.delivery_status || 'pending',
                        similarityDisabled: item.similarity_disabled,
                        similarityOriginalLat: item.similarity_original_lat,
                        similarityOriginalLng: item.similarity_original_lng
                    };
                });

                // Update the map markers with synced statuses
                const source = map.getSource('route-stops');
                if (!source || !source._data) return;

                const sourceData = source._data;

                // CORREÇÃO: Primeiro coleta as mudanças pendentes SEM modificar os props
                // Isso evita piscadas quando o sync é cancelado após a verificação de timestamp
                const pendingChanges = [];

                sourceData.features.forEach((feature, featureIndex) => {
                    const props = feature.properties;
                    const idsStr = props.ids;
                    if (!idsStr) return;

                    const ids = idsStr.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
                    if (ids.length === 0) return;

                    // Check if any of the IDs have a different status or similarity in Supabase
                    for (const id of ids) {
                        const syncData = statusMap[id];
                        if (!syncData) continue;

                        // Check delivery status change ONLY
                        // NÃO alteramos propriedades de similarity aqui para não quebrar o popup
                        // A sincronização de similarity é feita via route_markers_cache (GeoJSON completo)
                        if (syncData.status !== props.deliveryStatus) {
                            // Calcula a nova cor baseada no novo status
                            let newColor;
                            if (syncData.status === 'delivered') {
                                newColor = 'gray';
                            } else if (syncData.status === 'not_delivered') {
                                newColor = 'gray-x';
                            } else if (props.isRegistered) {
                                newColor = props.matchType === 'exact' ? 'green' : 'purple';
                            } else {
                                newColor = 'red';
                            }

                            const newIconName = `pin-${newColor}-${props.packageCount}`;

                            // Registra a mudança pendente (será aplicada depois da verificação)
                            pendingChanges.push({
                                featureIndex,
                                newStatus: syncData.status,
                                newIconName,
                                newColor,
                                packageCount: props.packageCount
                            });

                            break; // One ID match is enough to update the marker
                        }
                    }
                });

                if (pendingChanges.length > 0) {
                    // PROTEÇÃO ADICIONAL: Verifica novamente se houve alteração local durante a execução assíncrona
                    // Isso evita sobrescrever uma alteração do usuário que ocorreu enquanto buscávamos dados do servidor
                    if (Date.now() - lastRouteMarkersSave < 2000) {
                        console.log('⏸️ Sync cancelado: alteração local detectada durante execução');
                        return;
                    }

                    // AGORA sim aplica as mudanças (após a verificação de timestamp)
                    pendingChanges.forEach(change => {
                        const feature = sourceData.features[change.featureIndex];
                        if (feature) {
                            feature.properties.deliveryStatus = change.newStatus;
                            feature.properties.icon = change.newIconName;

                            // Ensure icon exists
                            if (!map.hasImage(change.newIconName)) {
                                const { dataUrl, pixelRatio } = generatePinIcon(change.packageCount, change.newColor);
                                const img = new Image();
                                img.onload = () => {
                                    if (!map.hasImage(change.newIconName)) {
                                        map.addImage(change.newIconName, img, { pixelRatio: pixelRatio });
                                    }
                                };
                                img.src = dataUrl;
                            }
                        }
                    });

                    // Update the map with synced data
                    source.setData(sourceData);
                    updateRouteMarkersCache(sourceData);
                    updateFixedStatsPanel();
                    console.log('📍 Marcadores sincronizados do Supabase (status/similarity)');
                }
            } catch (e) {
                console.log('⚠️ Erro ao sincronizar marcadores do Supabase:', e);
            }
        }

        // Update similarity override in Supabase or offline
        async function updateSimilarityOverride(ids, disabled, originalLat = null, originalLng = null) {
            if (!ids || ids.length === 0) {
                return false;
            }

            const updateData = {
                similarity_disabled: disabled,
                similarity_original_lat: disabled ? originalLat : null,
                similarity_original_lng: disabled ? originalLng : null
            };

            // If offline, save locally
            if (!isOnline) {
                try {
                    await saveToOfflineDB('pendingSimilarityOverrides', {
                        ids: ids,
                        ...updateData
                    });
                    updateOfflineIndicator();
                    return true;
                } catch (err) {
                    return false;
                }
            }

            // If online, try Supabase
            try {
                const { data, error } = await db
                    .from('planilha')
                    .update(updateData)
                    .in('id', ids)
                    .select();

                if (error) {
                    throw error;
                }

                // Update local cache
                try {
                    const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                    if (cachedPlanilha && cachedPlanilha.length > 0) {
                        const updatedPlanilha = cachedPlanilha.map(item => {
                            if (ids.includes(item.id)) {
                                return { ...item, ...updateData };
                            }
                            return item;
                        });
                        await saveCacheToDB('cachedPlanilha', updatedPlanilha);
                    }
                } catch (cacheErr) {
                    // Cache update failed, but Supabase update succeeded
                }

                return data && data.length > 0;
            } catch (error) {
                // If Supabase fails, save offline
                try {
                    await saveToOfflineDB('pendingSimilarityOverrides', { ids, ...updateData });

                    // Update local cache when saving offline
                    try {
                        const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedPlanilha && cachedPlanilha.length > 0) {
                            const updatedPlanilha = cachedPlanilha.map(item => {
                                if (ids.includes(item.id)) {
                                    return { ...item, ...updateData };
                                }
                                return item;
                            });
                            await saveCacheToDB('cachedPlanilha', updatedPlanilha);
                        }
                    } catch (cacheErr) {}

                    updateOfflineIndicator();
                    return true;
                } catch (offlineErr) {
                    return false;
                }
            }
        }

        // Generate high-resolution pin icon with number using Canvas (3x for Retina/HiDPI)
        // Colors: red (pending), green (registered), gray (delivered), gray-x (not delivered)
        function generatePinIcon(number, color = 'red') {
            const scale = 3;
            const baseWidth = 30;
            const baseHeight = 50;
            const width = baseWidth * scale;
            const height = baseHeight * scale;

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            ctx.scale(scale, scale);

            // Define colors based on color parameter
            const colors = {
                red: { needle: '#dc2626', light: '#f87171', mid: '#ef4444', dark: '#dc2626' },
                green: { needle: '#16a34a', light: '#4ade80', mid: '#22c55e', dark: '#16a34a' },
                purple: { needle: '#7c3aed', light: '#a78bfa', mid: '#8b5cf6', dark: '#7c3aed' },
                gray: { needle: '#6b7280', light: '#9ca3af', mid: '#6b7280', dark: '#4b5563' },
                'gray-x': { needle: '#6b7280', light: '#9ca3af', mid: '#6b7280', dark: '#4b5563' }
            };
            const colorSet = colors[color] || colors.red;

            // Draw needle
            ctx.fillStyle = colorSet.needle;
            ctx.beginPath();
            ctx.moveTo(15 - 2, 24);
            ctx.lineTo(15 + 2, 24);
            ctx.lineTo(15 + 1.5, 46);
            ctx.lineTo(15 - 1.5, 46);
            ctx.closePath();
            ctx.fill();

            // Draw shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            ctx.beginPath();
            ctx.ellipse(15, 48, 6, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw head circle with gradient
            const gradient = ctx.createLinearGradient(0, 0, 30, 24);
            gradient.addColorStop(0, colorSet.light);
            gradient.addColorStop(0.5, colorSet.mid);
            gradient.addColorStop(1, colorSet.dark);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(15, 12, 11, 0, Math.PI * 2);
            ctx.fill();

            // Draw white border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(15, 12, 11, 0, Math.PI * 2);
            ctx.stroke();

            // Draw number or X
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (color === 'gray-x') {
                // Draw X for not delivered
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(10, 7);
                ctx.lineTo(20, 17);
                ctx.moveTo(20, 7);
                ctx.lineTo(10, 17);
                ctx.stroke();
            } else {
                ctx.fillText(String(number), 15, 12.5);
            }

            return { dataUrl: canvas.toDataURL('image/png'), pixelRatio: scale };
        }

        // Update fixed stats panel with current route data
        function updateFixedStatsPanel(stats = null) {
            const panel = document.getElementById('fixedStatsPanel');
            if (!panel) return;

            // If no stats provided, calculate from current markers
            if (!stats) {
                try {
                    if (map && map.getSource && map.getSource('route-stops')) {
                        const source = map.getSource('route-stops');
                        const data = source._data;

                        if (data && data.features) {
                            let markersCount = 0; // Total de marcadores verdes + vermelhos
                            let registered = 0; // Marcadores verdes (cadastrados)
                            let unregistered = 0; // Marcadores vermelhos (não cadastrados)
                            let pending = 0; // Pacotes pendentes de entrega
                            let delivered = 0; // Entregas realizadas

                            data.features.forEach(feature => {
                                const props = feature.properties;
                                const count = props.packageCount || 1;
                                const isDelivered = props.deliveryStatus === 'delivered' || props.deliveryStatus === 'not_delivered';

                                if (isDelivered) {
                                    // Entregue ou não entregue (cinza)
                                    delivered += count;
                                } else {
                                    // Marcador ativo (verde ou vermelho)
                                    markersCount++;

                                    if (props.isRegistered) {
                                        // Verde - cadastrado
                                        registered++;
                                    } else {
                                        // Vermelho - não cadastrado
                                        unregistered++;
                                    }

                                    // Pendentes = pacotes que faltam entregar
                                    pending += count;
                                }
                            });

                            stats = {
                                total: markersCount, // Verde + vermelho
                                registered: registered, // Verdes
                                unregistered: unregistered, // Vermelhos
                                pending: pending, // Pacotes a entregar
                                delivered: delivered
                            };
                        }
                    }
                } catch (e) {
                    // Silently fail
                }
            }

            if (!stats) return;

            // Show the panel
            panel.classList.add('visible');

            // Update values with animation
            const updateStat = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                    const currentValue = parseInt(el.textContent) || 0;
                    if (currentValue !== value) {
                        el.parentElement.classList.add('updating');
                        el.textContent = value;
                        setTimeout(() => {
                            el.parentElement.classList.remove('updating');
                        }, 300);
                    }
                }
            };

            updateStat('fixedStatTotal', stats.total);
            updateStat('fixedStatRegistered', stats.registered);
            updateStat('fixedStatUnregistered', stats.unregistered);
            updateStat('fixedStatPending', stats.pending);
            updateStat('fixedStatDelivered', stats.delivered);
        }

        // Hide fixed stats panel
        function hideFixedStatsPanel() {
            const panel = document.getElementById('fixedStatsPanel');
            if (panel) {
                panel.classList.remove('visible');
            }
        }

        // Função para renderizar marcadores no mapa
        async function renderRouteMarkersOnMap(geojson, stats, skipFitBounds, routeBtn, updateProgress) {
            try {
                // Gera ícones únicos
                const uniqueIcons = new Set();
                geojson.features.forEach(feature => {
                    const props = feature.properties;
                    let color;
                    if (props.deliveryStatus === 'delivered' || props.deliveryStatus === 'not_delivered' || props.markerType === 'delivered') {
                        color = props.deliveryStatus === 'not_delivered' ? 'gray-x' : 'gray';
                    } else if (props.markerType === 'unregistered' || !props.isRegistered) {
                        color = 'red';
                    } else if (props.markerType === 'similarity' || props.matchType === 'similarity') {
                        color = 'purple';
                    } else {
                        color = 'green';
                    }
                    const count = props.packageCount || 1;
                    const iconName = `pin-${color}-${count}`;
                    feature.properties.icon = iconName;
                    uniqueIcons.add(iconName);
                });

                // Gera ícones de pinos
                const iconPromises = Array.from(uniqueIcons).map(iconName => {
                    return new Promise((resolve) => {
                        if (map.hasImage(iconName)) { resolve(); return; }
                        const parts = iconName.replace('pin-', '').split('-');
                        let color, count;
                        if (parts.length === 2 && parts[0] === 'gray' && parts[1] === 'x') {
                            color = 'gray-x';
                            count = parseInt(iconName.split('-').pop());
                        } else if (parts[0] === 'gray' && parts.length === 3) {
                            color = 'gray-x';
                            count = parseInt(parts[2]);
                        } else {
                            count = parseInt(parts.pop());
                            color = parts.join('-');
                        }
                        const { dataUrl, pixelRatio } = generatePinIcon(count, color);
                        const img = new Image();
                        img.onload = () => {
                            if (!map.hasImage(iconName)) {
                                map.addImage(iconName, img, { pixelRatio: pixelRatio });
                            }
                            resolve();
                        };
                        img.onerror = () => resolve();
                        img.src = dataUrl;
                    });
                });

                await Promise.all(iconPromises);

                // Adiciona ou atualiza source
                if (map.getSource('route-stops')) {
                    map.getSource('route-stops').setData(geojson);
                    map.setLayoutProperty('route-stops-pins', 'visibility', 'visible');
                } else {
                    map.addSource('route-stops', { type: 'geojson', data: geojson });
                    map.addLayer({
                        id: 'route-stops-pins',
                        type: 'symbol',
                        source: 'route-stops',
                        layout: {
                            'icon-image': ['get', 'icon'],
                            'icon-size': 1,
                            'icon-anchor': 'bottom',
                            'icon-allow-overlap': true
                        }
                    });
                }

                // Adiciona handlers de click se ainda não foram adicionados
                if (!routeClickHandlerAdded) {
                    setupRouteMarkerClickHandlers();
                    routeClickHandlerAdded = true;
                }

                // Atualiza progresso
                if (updateProgress) updateProgress(90);

                // Salva no cache para persistência
                await saveRouteMarkersToCache(geojson, stats);

                // Atualiza painel de estatísticas
                updateFixedStatsPanel(stats);

                // Ajusta bounds do mapa
                if (!skipFitBounds && geojson.features.length > 0) {
                    const bounds = new mapboxgl.LngLatBounds();
                    geojson.features.forEach(f => bounds.extend(f.geometry.coordinates));
                    map.fitBounds(bounds, { padding: 50, maxZoom: 15 });
                }

                // Mostra marcadores de rota
                routeMarkersVisible = true;
                if (updateProgress) updateProgress(100);

                // Restaura botão
                if (routeBtn) {
                    routeBtn.classList.remove('loading');
                    routeBtn.style.pointerEvents = 'auto';
                    setTimeout(() => { if (updateProgress) updateProgress(0); }, 500);
                }

            } catch (error) {
                if (routeBtn) {
                    routeBtn.classList.remove('loading');
                    routeBtn.style.pointerEvents = 'auto';
                }
                throw error;
            }
        }

        async function loadRouteMarkers(skipFitBounds = false) {
            try {
                // PERFORMANCE: Mostrar indicador de carregamento com barra de progresso
                const routeBtn = document.getElementById('routeMarkersBtn');
                const progressFill = document.getElementById('routeProgressFill');

                // Função para atualizar o progresso (0-100)
                const updateProgress = (percent) => {
                    if (progressFill) {
                        progressFill.style.height = `${Math.min(100, Math.max(0, percent))}%`;
                    }
                };

                if (routeBtn) {
                    routeBtn.classList.add('loading');
                    routeBtn.style.pointerEvents = 'none';
                    updateProgress(0);
                }

                let data = null;
                let registeredClients = [];

                // Try online first, fallback to offline cache
                if (isOnline) {
                    // Fetch ALL data from planilha table
                    // Coordinates come from registered clients matching
                    const { data: onlineData, error } = await db
                        .from('planilha')
                        .select('id, destination_address, bairro, city, zipcode, latitude, longitude, sequence, stop, delivery_status, similarity_disabled, similarity_original_lat, similarity_original_lng')
                        .not('destination_address', 'is', null);

                    if (!error && onlineData) {
                        data = onlineData;
                        // Update cache with fresh data
                        try {
                            await saveCacheToDB('cachedPlanilha', onlineData);
                        } catch (e) {}
                    }

                    // Fetch active clients from clients table to check registered addresses
                    // Usa paginação para buscar todos os clientes (Supabase limita a 1000 por padrão)
                    let allClientsData = [];
                    let clientsFrom = 0;
                    const clientsPageSize = 1000;
                    let hasMoreClients = true;

                    while (hasMoreClients) {
                        const { data: clientsPage, error: clientsPageError } = await db
                            .from('clients')
                            .select('id, address, bairro, city, zipcode, latitude, longitude')
                            .not('latitude', 'is', null)
                            .not('longitude', 'is', null)
                            .range(clientsFrom, clientsFrom + clientsPageSize - 1);

                        if (clientsPageError) {
                            break;
                        }

                        if (clientsPage && clientsPage.length > 0) {
                            allClientsData = allClientsData.concat(clientsPage);
                            clientsFrom += clientsPageSize;
                            if (clientsPage.length < clientsPageSize) {
                                hasMoreClients = false;
                            }
                        } else {
                            hasMoreClients = false;
                        }
                    }

                    if (allClientsData.length > 0) {
                        registeredClients = allClientsData;
                        // Update cache with fresh data
                        try {
                            await saveCacheToDB('cachedClients', allClientsData);
                        } catch (e) {}
                    }

                    // Also include pending clients (not yet synced) when online
                    // But ONLY add those that don't already exist in Supabase
                    // Supabase data has priority (more reliable coordinates)
                    try {
                        const pendingClients = await getAllFromOfflineDB('pendingClients');
                        if (pendingClients && pendingClients.length > 0) {
                            const validPending = pendingClients.filter(client =>
                                client.latitude && client.longitude
                            );
                            // Only add pending clients that are truly NEW (not in Supabase)
                            validPending.forEach(pending => {
                                const existsInSupabase = registeredClients.some(c =>
                                    c.address === pending.address
                                );
                                // If client exists in Supabase, DON'T add the pending version
                                // Supabase coordinates are considered more reliable
                                if (!existsInSupabase) {
                                    registeredClients.push(pending);
                                }
                            });
                        }
                    } catch (e) {}
                }

                // Progresso: dados carregados (10%)
                updateProgress(10);

                // Fallback to offline cache if no data or offline
                if (!data || data.length === 0) {
                    try {
                        // Try cached planilha data - load ALL entries (we handle missing coords later)
                        const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedPlanilha && cachedPlanilha.length > 0) {
                            data = cachedPlanilha.filter(item => item.destination_address);
                        }

                        // If still no data, try pending planilha
                        if (!data || data.length === 0) {
                            const pendingPlanilha = await getAllFromOfflineDB('pendingPlanilha');
                            if (pendingPlanilha && pendingPlanilha.length > 0) {
                                data = pendingPlanilha.filter(item => item.destination_address);
                            }
                        }
                    } catch (cacheError) {
                        // Cache error, continue with empty data
                    }
                }

                // Fallback to offline cache for clients (only if not already loaded)
                if (registeredClients.length === 0) {
                    try {
                        const cachedClients = await getAllFromOfflineDB('cachedClients');
                        if (cachedClients && cachedClients.length > 0) {
                            registeredClients = cachedClients.filter(client =>
                                client.latitude && client.longitude
                            );
                        }

                        // Also include pending clients (for NEW clients not yet in cache)
                        // Cache data has priority over pending data
                        const pendingClients = await getAllFromOfflineDB('pendingClients');
                        if (pendingClients && pendingClients.length > 0) {
                            const validPending = pendingClients.filter(client =>
                                client.latitude && client.longitude
                            );
                            // Only add pending clients that are NOT in cache
                            // Cache coordinates are considered more reliable (from Supabase)
                            validPending.forEach(pending => {
                                const existsInCache = registeredClients.some(c =>
                                    c.address === pending.address
                                );
                                if (!existsInCache) {
                                    registeredClients.push(pending);
                                }
                            });
                        }
                    } catch (cacheError) {
                        // Cache error, continue with empty clients
                    }
                }

                if (!data || data.length === 0) {
                    // Restaurar botão em caso de nenhum dado
                    if (routeBtn) {
                        routeBtn.classList.remove('loading');
                        routeBtn.style.pointerEvents = 'auto';
                        updateProgress(0);
                    }
                    showErrorModal('Nenhum dado encontrado na planilha. Faça o upload de uma planilha primeiro.');
                    return;
                }

                // Salva os dados originais da planilha globalmente para uso na desativação de similaridade
                window.currentRouteData = data;

                // Progresso: iniciando processamento (20%)
                updateProgress(20);

                // ============================================
                // Processamento na Main Thread
                // ============================================

                // Convert written numbers to digits for comparison
                function convertWrittenNumbers(text) {
                    if (!text) return text;
                    const numberMap = {
                        'zero': '0', 'um': '1', 'uma': '1', 'dois': '2', 'duas': '2', 'tres': '3',
                        'quatro': '4', 'cinco': '5', 'seis': '6', 'sete': '7', 'oito': '8', 'nove': '9',
                        'dez': '10', 'onze': '11', 'doze': '12', 'treze': '13', 'quatorze': '14', 'catorze': '14',
                        'quinze': '15', 'dezesseis': '16', 'dessesseis': '16', 'dezessete': '17', 'dezoito': '18',
                        'dezenove': '19', 'vinte': '20', 'trinta': '30', 'quarenta': '40', 'cinquenta': '50',
                        'sessenta': '60', 'setenta': '70', 'oitenta': '80', 'noventa': '90',
                        'cem': '100', 'primeiro': '1', 'primeira': '1', 'segundo': '2', 'segunda': '2',
                        'terceiro': '3', 'terceira': '3'
                    };
                    let result = text.toLowerCase();
                    // Handle compound numbers like "vinte e um" -> "21"
                    result = result.replace(/vinte\s*e?\s*(um|uma|dois|duas|tres|quatro|cinco|seis|sete|oito|nove)/gi, (match, unit) => {
                        const unitValue = numberMap[unit.toLowerCase()] || unit;
                        return '2' + unitValue;
                    });
                    result = result.replace(/trinta\s*e?\s*(um|uma|dois|duas|tres|quatro|cinco|seis|sete|oito|nove)/gi, (match, unit) => {
                        const unitValue = numberMap[unit.toLowerCase()] || unit;
                        return '3' + unitValue;
                    });
                    // Replace simple written numbers
                    for (const [word, digit] of Object.entries(numberMap)) {
                        const regex = new RegExp(`\\b${word}\\b`, 'gi');
                        result = result.replace(regex, digit);
                    }
                    return result;
                }

                // Normalize address text for comparison
                function normalizeAddress(addr) {
                    if (!addr) return '';

                    // Remove everything after "Bairro:" (client addresses have extra info)
                    let cleanAddr = addr.split(/bairro:/i)[0];

                    // Convert written numbers to digits (Dezesseis -> 16)
                    cleanAddr = convertWrittenNumbers(cleanAddr);

                    return cleanAddr
                        .toLowerCase()
                        .trim()
                        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove accents
                        .replace(/[.,;:\-\/\\()]/g, ' ') // Replace punctuation with space
                        .replace(/\s+/g, ' ') // Multiple spaces to single
                        .replace(/\b(rua|r|av|avenida|travessa|tv|alameda|al|praca|pca|largo|lg|rod|rodovia|est|estrada)\b/gi, '')
                        .replace(/\b(apt|apto|apartamento|bloco|bl|lote|lt|qd|quadra|conj|conjunto)\b/gi, '')
                        .replace(/\b(belem|para|pa)\b/gi, '') // Remove city/state names (removed 'mosqueiro' - it's a street name!)
                        .replace(/\d{5}\s*\-?\s*\d{3}/g, '') // Remove CEP
                        .replace(/\b(doutor|doutora|dr|dra)\b/gi, '') // Remove doctor titles (Doutor = Dr = Dra)
                        .replace(/\b(professor|professora|prof|profa)\b/gi, '') // Remove professor titles
                        .replace(/\b(engenheiro|engenheira|eng)\b/gi, '') // Remove engineer titles
                        .replace(/\b(padre|pe)\b/gi, '') // Remove priest titles
                        .replace(/\b(general|gen|coronel|cel|major|maj|capitao|cap|tenente|ten|sargento|sgt)\b/gi, '') // Remove military titles
                        .replace(/\b(deputado|dep|senador|sen|vereador|ver|prefeito)\b/gi, '') // Remove political titles
                        .replace(/\b(santo|santa|sao|sta|sto)\b/gi, '') // Remove saint titles
                        .replace(/\s+/g, ' ')
                        .trim();
                }

                // Calculate distance between two coordinates in km
                function haversineDistance(lat1, lon1, lat2, lon2) {
                    const R = 6371; // Earth radius in km
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                              Math.sin(dLon/2) * Math.sin(dLon/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    return R * c;
                }

                // Extract house number from address
                function extractHouseNumber(addr) {
                    if (!addr) return null;

                    // First, remove CEP patterns to avoid extracting them as house numbers
                    let cleanAddr = addr
                        .replace(/\d{5}\s*[-]?\s*\d{3}/g, '') // Remove CEP (66910-100)
                        .replace(/\b\d{8}\b/g, ''); // Remove CEP without dash (66910100)

                    // Also remove everything after "Bairro:" as it may contain CEP
                    cleanAddr = cleanAddr.split(/bairro:/i)[0];

                    // IMPORTANTE: Remover números que fazem parte de NOMES de ruas históricas
                    // Exemplos: "Avenida 16 De Novembro", "Rua 7 De Setembro", "Avenida 1 De Maio"
                    // Esses números são parte do NOME da rua, NÃO são números de casa
                    // Isso permite que "Avenida 16 De Novembro 1026" extraia 1026, não 16
                    cleanAddr = cleanAddr.replace(/\b(\d{1,2})\s+de\s+(janeiro|fevereiro|março|marco|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)\b/gi, 'RUA_HISTORICA');

                    // Match patterns like: ", 123", ", 1b", "nº 123", "n 123a", "numero 123"
                    // Captures numbers with optional letter suffix (1b, 61 b, 772A)
                    const patterns = [
                        /[,\s](\d+\s*[a-zA-Z]?)(?:\s|$|,|-)/,    // ", 123" or ", 1b" or " 61 b"
                        /n[º°]?\s*(\d+\s*[a-zA-Z]?)/i,           // "nº 123", "n 1b"
                        /numero\s*(\d+\s*[a-zA-Z]?)/i,           // "numero 123", "numero 1b"
                        /^.*?[a-z]\s+(\d+\s*[a-zA-Z]?)(?:\s|$|,)/i  // "Rua xyz 123" or "Alameda xyz 1b"
                    ];
                    for (const pattern of patterns) {
                        const match = cleanAddr.match(pattern);
                        if (match && match[1]) {
                            // Normalize: remove spaces, lowercase the letter suffix, and remove leading zeros
                            let num = match[1].replace(/\s+/g, '').toLowerCase();
                            // Remove leading zeros but keep at least one digit (e.g., "05" -> "5", "007" -> "7", "0" -> "0")
                            num = num.replace(/^0+(\d)/, '$1');
                            return num;
                        }
                    }
                    return null;
                }

                // Extract address components (main street, secondary street, number)
                function extractAddressComponents(addr) {
                    if (!addr) return { primary: '', secondary: '', number: '', clean: '' };

                    // IMPORTANTE: Extrair o número de casa do endereço ORIGINAL primeiro
                    // Isso garante que números após referências (como "ao lado do X, 69") sejam capturados
                    const houseNumFromOriginal = extractHouseNumber(addr);

                    // Reference patterns that indicate start of complement (not part of address)
                    // Note: "casa" followed by number is part of address (Casa 05), but "casa de" or "casa do" is reference
                    const referencePatterns = [
                        /\b(proximo|próximo|prox\.?|próx\.?)\b/i,
                        /\b(ao lado|em frente|atras|atrás)\b/i,
                        /\b(entre|perto)\b/i,
                        /\b(fundos|frente)\b/i,
                        /\b(referencia|referência|ref\.?)\b/i,
                        /\b(descendo|subindo)\b/i,
                        /\b(esquina|esq\.?)\b/i,
                        /\bpx\.?\b/i  // Px. or Px for "próximo"
                    ];

                    // Remove reference patterns and everything after them
                    let cleanAddr = addr;
                    for (const pattern of referencePatterns) {
                        const match = cleanAddr.match(pattern);
                        if (match) {
                            cleanAddr = cleanAddr.substring(0, match.index).trim();
                        }
                    }

                    // Convert written numbers to digits for better comparison
                    cleanAddr = convertWrittenNumbers(cleanAddr);

                    // Extract house number from cleaned address, fallback to original if not found
                    const houseNumFromClean = extractHouseNumber(cleanAddr);
                    const houseNum = houseNumFromClean || houseNumFromOriginal;

                    // Types of streets (ordered by specificity to avoid false matches)
                    const streetTypes = [
                        { pattern: /\b(passagem|pass\.?)\b/gi, name: 'passagem' },
                        { pattern: /\b(alameda|al\.?)\b/gi, name: 'alameda' },
                        { pattern: /\b(travessa|tv\.?|trav\.?)\b/gi, name: 'travessa' },
                        { pattern: /\b(avenida|av\.?)\b/gi, name: 'avenida' },
                        { pattern: /\b(rodovia|rod\.?)\b/gi, name: 'rodovia' },
                        { pattern: /\b(estrada|est\.?)\b/gi, name: 'estrada' },
                        { pattern: /\b(praça|pça\.?|praca)\b/gi, name: 'praca' },
                        { pattern: /\b(viela)\b/gi, name: 'viela' },
                        { pattern: /\b(beco)\b/gi, name: 'beco' },
                        { pattern: /\b(rua|r\.?)\b/gi, name: 'rua' }
                    ];

                    // Find all street type occurrences with their positions in CLEANED address
                    const matches = [];
                    for (const streetType of streetTypes) {
                        let match;
                        const regex = new RegExp(streetType.pattern);
                        while ((match = regex.exec(cleanAddr)) !== null) {
                            matches.push({
                                type: streetType.name,
                                index: match.index,
                                fullMatch: match[0]
                            });
                        }
                    }

                    // Sort by position in string
                    matches.sort((a, b) => a.index - b.index);

                    // Filtrar matches que aparecem DEPOIS do número da casa e em contexto de complemento
                    // Exemplo: "Rua X, 59, Rua de frente com bar" - o segundo "Rua" é complemento, não logradouro
                    // Logradouros secundários legítimos: Alameda, Passagem, Travessa (não Rua repetida)
                    const filteredMatches = [];
                    if (matches.length > 0) {
                        filteredMatches.push(matches[0]); // Primeiro sempre é o principal

                        for (let i = 1; i < matches.length; i++) {
                            const match = matches[i];

                            // Se o segundo tipo é o MESMO que o primeiro, provavelmente é complemento
                            // Exemplo: "Rua X, 59, Rua de frente" - segundo "Rua" não é logradouro secundário
                            if (match.type === matches[0].type) {
                                continue; // Ignorar, é complemento
                            }

                            // Verificar se aparece depois de uma vírgula seguida de número (indica complemento)
                            // Padrão: ", 123, <tipo>" ou ", 123 <tipo>"
                            const textBefore = cleanAddr.substring(0, match.index);
                            const hasNumberBeforePattern = /,\s*\d+[a-zA-Z]?\s*[,\s]*$/;

                            // Se aparece logo após número + vírgula, E é tipo comum (rua), ignorar
                            if (hasNumberBeforePattern.test(textBefore) && match.type === 'rua') {
                                continue; // Provavelmente é "Casa na rua de trás" ou similar
                            }

                            // Tipos que são legítimos como secundários: alameda, passagem, travessa, viela, beco
                            const legitimateSecondaryTypes = ['alameda', 'passagem', 'travessa', 'viela', 'beco'];
                            if (legitimateSecondaryTypes.includes(match.type)) {
                                // VERIFICAÇÃO EXTRA: Ignorar se faz parte de um padrão de referência
                                // Ex: "alameda frente hospital" não é logradouro secundário
                                // Ex: "alameda em frente" não é logradouro secundário
                                const afterMatch = cleanAddr.substring(match.index + match.fullMatch.length).toLowerCase();
                                const referenceContextPatterns = [
                                    /^\s*(frente|em\s+frente|ao\s+lado|atras|atrás|perto|proximo|próximo)/i,
                                    /^\s*(de\s+frente|da\s+frente)/i
                                ];
                                const isReferenceContext = referenceContextPatterns.some(p => p.test(afterMatch));

                                if (!isReferenceContext) {
                                    filteredMatches.push(match);
                                    break; // Só um secundário
                                }
                                // Se é contexto de referência, ignora e continua
                            }
                        }
                    }

                    let primary = '';
                    let secondary = '';

                    if (filteredMatches.length === 0) {
                        // No street type found, use the whole cleaned address
                        primary = cleanAddr.trim();
                    } else if (filteredMatches.length === 1) {
                        // Only one street type - it's the primary
                        const match = filteredMatches[0];
                        // Extract from street type to number or end
                        const afterType = cleanAddr.substring(match.index);
                        const beforeComma = afterType.split(',')[0];
                        primary = beforeComma.trim();
                    } else {
                        // Multiple street types - first is primary, second is secondary
                        const first = filteredMatches[0];
                        const second = filteredMatches[1];

                        // Primary: from first type to just before second type
                        const primaryText = cleanAddr.substring(first.index, second.index).replace(/[,\s]+$/, '').trim();
                        primary = primaryText;

                        // Secondary: from second type to number or comma
                        const afterSecond = cleanAddr.substring(second.index);
                        const beforeComma = afterSecond.split(',')[0];
                        secondary = beforeComma.trim();
                    }

                    // Identificar o TIPO do logradouro secundário (alameda, passagem, travessa, etc.)
                    let secondaryType = null;
                    if (secondary && filteredMatches.length >= 2) {
                        secondaryType = filteredMatches[1].type; // O segundo match filtrado é o tipo do logradouro secundário
                    }

                    // Create clean identifier: primary + secondary (if exists) + number
                    let clean = normalizeAddress(primary);
                    if (secondary) {
                        clean += ' ' + normalizeAddress(secondary);
                    }
                    if (houseNum) {
                        clean += ' ' + houseNum;
                    }

                    return {
                        primary: primary,
                        secondary: secondary,
                        secondaryType: secondaryType, // Tipo do logradouro secundário (alameda, passagem, travessa, etc.)
                        number: houseNum,
                        clean: clean.trim()
                    };
                }

                // Calculate text similarity (Jaccard index based on words)
                // IMPORTANTE: Ignora números para evitar matches falsos baseados apenas no número da casa
                function textSimilarity(text1, text2) {
                    // Filtra palavras: mais de 2 caracteres E não é número puro
                    const isValidWord = w => w.length > 2 && !/^\d+$/.test(w);
                    const words1 = new Set(text1.split(' ').filter(isValidWord));
                    const words2 = new Set(text2.split(' ').filter(isValidWord));
                    if (words1.size === 0 || words2.size === 0) return 0;
                    const intersection = new Set([...words1].filter(x => words2.has(x)));
                    const union = new Set([...words1, ...words2]);
                    return intersection.size / union.size;
                }

                // Normalize CEP for comparison (remove dash and spaces)
                function normalizeCep(cep) {
                    if (!cep) return '';
                    return cep.toString().replace(/[-\s]/g, '').trim();
                }

                // Normalize bairro for comparison
                function normalizeBairro(bairro) {
                    if (!bairro) return '';
                    return bairro
                        .toLowerCase()
                        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                        .replace(/[()]/g, '')
                        .replace(/\s+/g, ' ')
                        .trim();
                }

                // Extract significant street name words (excluding common terms and numbers)
                // Returns an array of meaningful words that identify the street
                function extractStreetNameWords(addr) {
                    if (!addr) return [];

                    // Normalize the address
                    let text = addr
                        .toLowerCase()
                        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove acentos
                        .replace(/[.,;:\-\/\\()]/g, ' ') // Replace punctuation
                        .replace(/\s+/g, ' ')
                        .trim();

                    // Words to exclude (street types, common terms, complements)
                    // NOTA: Não excluir nomes que podem ser nomes de ruas (cidades, títulos, nomes próprios, etc.)
                    const excludeWords = new Set([
                        // Street types (tipos de logradouro)
                        'rua', 'av', 'avenida', 'travessa', 'alameda',
                        'praca', 'pca', 'largo', 'rod', 'rodovia', 'est', 'estrada',
                        'passagem', 'psg', 'viela', 'beco',
                        // Apartment/block terms (termos de apartamento/bloco)
                        'apt', 'apto', 'apartamento', 'bloco', 'lote',
                        'quadra', 'conj', 'conjunto', 'casa',
                        // Common prepositions and articles (preposições e artigos)
                        'de', 'da', 'do', 'das', 'dos', 'em', 'na', 'no', 'nas', 'nos',
                        'com', 'por', 'entre', 'sobre', 'sob', 'ate', 'desde',
                        // Common complement location words (palavras de localização)
                        'lado', 'frente', 'atras', 'perto', 'proximo', 'proxima', 'prox',
                        'esquina', 'canto', 'final', 'inicio', 'meio', 'fundos', 'fundo',
                        // Generic terms (termos genéricos)
                        'numero', 'num', 'nro', 'sem'
                    ]);

                    // Split into words and filter
                    const words = text.split(' ')
                        .filter(w => {
                            // Must be at least 3 characters
                            if (w.length < 3) return false;
                            // Must not be a number
                            if (/^\d+$/.test(w)) return false;
                            // Must not be in exclude list
                            if (excludeWords.has(w)) return false;
                            return true;
                        });

                    return words;
                }

                // Check if two addresses share at least one significant street name word
                function hasCommonStreetWord(addr1, addr2) {
                    const words1 = new Set(extractStreetNameWords(addr1));
                    const words2 = new Set(extractStreetNameWords(addr2));

                    if (words1.size === 0 || words2.size === 0) return false;

                    for (const word of words1) {
                        if (words2.has(word)) return true;
                    }
                    return false;
                }

                // Find matching registered client for an address (with optional bairro and zipcode)
                // Usa pré-filtro de palavras em comum para otimizar comparações
                function findRegisteredClient(addr, planilhaBairro = null, planilhaZipcode = null) {
                    if (!addr || registeredClients.length === 0) return null;
                    const normalizedAddr = normalizeAddress(addr);
                    const addrHouseNum = extractHouseNumber(addr);
                    const normalizedPlanilhaBairro = normalizeBairro(planilhaBairro);
                    const normalizedPlanilhaCep = normalizeCep(planilhaZipcode);

                    // Extrair componentes do endereço da planilha para verificar logradouros secundários
                    const addrComponents = extractAddressComponents(addr);
                    const addrHasSecondary = addrComponents.secondary && addrComponents.secondary.length > 0;

                    let bestMatch = null;
                    let bestScore = 0;

                    // Itera sobre todos os clientes cadastrados para encontrar o melhor match
                    for (const client of registeredClients) {
                        const normalizedClient = normalizeAddress(client.address);
                        const clientHouseNum = extractHouseNumber(client.address);
                        const normalizedClientBairro = normalizeBairro(client.bairro);
                        const normalizedClientCep = normalizeCep(client.zipcode);

                        // Extrair componentes do endereço cadastrado para verificar logradouros secundários
                        const clientComponents = extractAddressComponents(client.address);
                        const clientHasSecondary = clientComponents.secondary && clientComponents.secondary.length > 0;

                        // VERIFICAÇÃO DE LOGRADOURO SECUNDÁRIO (Alameda, Passagem, Travessa, etc.)
                        // Se um endereço tem logradouro secundário e o outro não, NÃO fazer match
                        // Exemplo: "Rua Variante, 17" NÃO deve combinar com "Rua Variante, 17, Alameda X"
                        if (addrHasSecondary !== clientHasSecondary) {
                            continue; // Pular este cliente, não é compatível
                        }

                        // Se AMBOS têm logradouros secundários, verificar TIPO e NOME
                        // O número principal (ex: 1026) já foi verificado, aqui verificamos apenas os termos do secundário
                        // Números dentro do secundário (Casa 05, Casa 01) são ignorados - o importante é identificar a alameda
                        if (addrHasSecondary && clientHasSecondary) {
                            // PRIMEIRO: Verificar se os TIPOS de logradouros secundários são iguais
                            // "Alameda X" só deve combinar com "Alameda X", não com "Passagem X" ou "Travessa X"
                            const addrSecType = addrComponents.secondaryType;
                            const clientSecType = clientComponents.secondaryType;

                            // Se ambos têm tipo identificado, eles DEVEM ser iguais
                            if (addrSecType && clientSecType && addrSecType !== clientSecType) {
                                continue; // Tipos diferentes: Alameda ≠ Passagem, Travessa ≠ Alameda, etc.
                            }

                            // SEGUNDO: Verificar se os NOMES são compatíveis
                            // Normalize both secondary streets for comparison (normalizeAddress already removes numbers)
                            const normalizedAddrSecondary = normalizeAddress(addrComponents.secondary);
                            const normalizedClientSecondary = normalizeAddress(clientComponents.secondary);

                            // Compare secondary street NAMES specifically
                            const secondarySimilarity = textSimilarity(normalizedAddrSecondary, normalizedClientSecondary);

                            // Also check if one contains keywords from the other (more flexible)
                            // This helps match "Alameda Escrava Anastácia" with "Al. Anastácia"
                            const addrSecondaryWords = normalizedAddrSecondary.split(' ').filter(w => w.length > 2);
                            const clientSecondaryWords = normalizedClientSecondary.split(' ').filter(w => w.length > 2);
                            const hasCommonWord = addrSecondaryWords.some(w => clientSecondaryWords.includes(w)) ||
                                                  clientSecondaryWords.some(w => addrSecondaryWords.includes(w));

                            // Accept if similarity >= 0.35 OR if they share a significant word (like "anastacia", "escrava")
                            if (secondarySimilarity < 0.35 && !hasCommonWord) {
                                continue; // Pular, são logradouros secundários diferentes
                            }
                        }

                        // PRÉ-FILTRO R��PIDO: Pular se não há palavras em comum
                        // Evita cálculos caros de similaridade para endereços obviamente diferentes
                        if (!hasCommonStreetWord(addr, client.address)) {
                            continue;
                        }

                        const similarity = textSimilarity(normalizedAddr, normalizedClient);

                        // Calculate bonus score for matching bairro and CEP
                        let bonusScore = 0;
                        let hasCepMatch = false;
                        let hasBairroMatch = false;

                        // CEP match gives highest bonus (most reliable)
                        if (normalizedPlanilhaCep && normalizedClientCep) {
                            if (normalizedPlanilhaCep === normalizedClientCep) {
                                bonusScore += 0.4;
                                hasCepMatch = true;
                            }
                        }

                        // Bairro match gives medium bonus
                        if (normalizedPlanilhaBairro && normalizedClientBairro) {
                            if (normalizedPlanilhaBairro === normalizedClientBairro ||
                                normalizedPlanilhaBairro.includes(normalizedClientBairro) ||
                                normalizedClientBairro.includes(normalizedPlanilhaBairro)) {
                                bonusScore += 0.25;
                                hasBairroMatch = true;
                            }
                        }

                        // Combined score
                        const totalScore = similarity + bonusScore;

                        // If both have house numbers, they must match EXACTLY
                        if (addrHouseNum && clientHouseNum) {
                            if (addrHouseNum === clientHouseNum) {
                                // Same house number - BUT we need high similarity to confirm it's the same street
                                // Different thresholds based on what matches:
                                // - CEP match (most reliable): 0.10 (CEP identifies exact location)
                                // - Only bairro match: 0.40 (bairro is too broad, need street similarity)
                                // - Neither matches: 0.70 (require high similarity)
                                let threshold;
                                if (hasCepMatch) {
                                    threshold = 0.10; // CEP é muito específico, confia
                                } else if (hasBairroMatch) {
                                    threshold = 0.40; // Bairro é amplo, precisa verificar a rua
                                } else {
                                    threshold = 0.70; // Sem match de localização, precisa alta similaridade
                                }

                                if (similarity >= threshold && totalScore > bestScore) {
                                    bestMatch = client;
                                    bestScore = totalScore;
                                }
                            }
                            // IMPORTANTE: Se os números de casa são DIFERENTES, NÃO fazer match
                            // Isso garante que "Rua X, 99" NUNCA combine com "Rua X, 587"
                            // O endereço será tratado como não cadastrado (marcador vermelho)
                        } else if (!addrHouseNum && !clientHouseNum) {
                            // Neither has house number - accept with lower threshold if CEP/bairro match
                            const threshold = (hasCepMatch || hasBairroMatch) ? 0.5 : 0.8;
                            if (similarity >= threshold && totalScore > bestScore) {
                                bestMatch = client;
                                bestScore = totalScore;
                            }
                        }
                        // IMPORTANTE: Se UM tem número e o OUTRO não, NÃO fazer match
                        // Exemplo: "Rua X, 99" não deve combinar com "Rua X" (sem número)
                        // Pois o cliente sem número pode ser qualquer endereço daquela rua
                    }

                    // Se encontrou um match, determinar se foi exato ou por similaridade
                    if (bestMatch) {
                        // Match exato: similarity >= 0.95 (endereços quase idênticos após normalização)
                        const normalizedBestClient = normalizeAddress(bestMatch.address);
                        const finalSimilarity = textSimilarity(normalizedAddr, normalizedBestClient);
                        const isExactMatch = finalSimilarity >= 0.95;

                        return {
                            client: bestMatch,
                            matchType: isExactMatch ? 'exact' : 'similarity'
                        };
                    }

                    return null;
                }

                // Check if two addresses should be merged (same street AND same house number)
                function shouldMergeAddresses(addr1, addr2, normalized1, normalized2, bairro1 = null, bairro2 = null, cep1 = null, cep2 = null) {
                    // Extract address components intelligently
                    const comp1 = extractAddressComponents(addr1);
                    const comp2 = extractAddressComponents(addr2);

                    // If both have house numbers, they MUST match to merge
                    if (comp1.number && comp2.number) {
                        if (comp1.number !== comp2.number) {
                            return false; // Different house numbers = different addresses
                        }

                        // Check if both have secondary streets (Passagem, Alameda, etc.)
                        const hasSecondary1 = comp1.secondary && comp1.secondary.length > 0;
                        const hasSecondary2 = comp2.secondary && comp2.secondary.length > 0;

                        // If both have secondary streets, they MUST match (same passagem/alameda)
                        if (hasSecondary1 && hasSecondary2) {
                            // Compare the clean identifiers which include primary + secondary + number
                            const similarity = textSimilarity(comp1.clean, comp2.clean);
                            // High threshold for secondary streets (they must be very similar)
                            return similarity >= 0.70;
                        }

                        // If one has secondary and other doesn't, don't merge
                        if (hasSecondary1 !== hasSecondary2) {
                            return false;
                        }

                        // Neither has secondary - check primary street + CEP/bairro
                        const normalizedCep1 = normalizeCep(cep1);
                        const normalizedCep2 = normalizeCep(cep2);
                        const normalizedBairro1 = normalizeBairro(bairro1);
                        const normalizedBairro2 = normalizeBairro(bairro2);

                        const hasCepMatch = normalizedCep1 && normalizedCep2 && normalizedCep1 === normalizedCep2;
                        const hasBairroMatch = normalizedBairro1 && normalizedBairro2 && (
                            normalizedBairro1 === normalizedBairro2 ||
                            normalizedBairro1.includes(normalizedBairro2) ||
                            normalizedBairro2.includes(normalizedBairro1)
                        );

                        // Compare primary streets using clean identifiers
                        const similarity = textSimilarity(comp1.clean, comp2.clean);

                        // Smart threshold based on CEP/bairro match:
                        // - If CEP AND bairro match: low threshold (15%) - allows different complements
                        // - If only one matches: medium threshold (40%)
                        // - If neither matches: high threshold (60%) - prevents different streets
                        let threshold;
                        if (hasCepMatch && hasBairroMatch) {
                            threshold = 0.15;
                        } else if (hasCepMatch || hasBairroMatch) {
                            threshold = 0.40;
                        } else {
                            threshold = 0.60;
                        }

                        return similarity >= threshold;
                    }

                    // If only one has house number, don't merge (ambiguous)
                    if (comp1.number || comp2.number) {
                        return false;
                    }

                    // Neither has house number - merge only if very similar text
                    const similarity = textSimilarity(normalized1, normalized2);
                    return similarity >= 0.7;
                }

                // PERFORMANCE: Cache para evitar recálculos de findRegisteredClient
                const clientMatchCache = new Map();
                function getCachedClientMatch(addr, bairro, zipcode) {
                    const cacheKey = `${addr}|${bairro || ''}|${zipcode || ''}`;
                    if (clientMatchCache.has(cacheKey)) {
                        return clientMatchCache.get(cacheKey);
                    }
                    const result = findRegisteredClient(addr, bairro, zipcode);
                    clientMatchCache.set(cacheKey, result);
                    return result;
                }

                // First pass: Group by exact normalized address
                const initialGroups = {};
                data.forEach(row => {
                    const normalizedAddr = normalizeAddress(row.destination_address);
                    if (!normalizedAddr) return;

                    if (!initialGroups[normalizedAddr]) {
                        initialGroups[normalizedAddr] = {
                            originalAddress: row.destination_address,
                            originalBairro: row.bairro,
                            originalZipcode: row.zipcode,
                            items: []
                        };
                    }
                    initialGroups[normalizedAddr].items.push(row);
                });

                // PERFORMANCE: Pré-calcular componentes dos endereços para evitar recálculos
                const addressComponentsCache = new Map();
                function getCachedComponents(addr) {
                    if (addressComponentsCache.has(addr)) {
                        return addressComponentsCache.get(addr);
                    }
                    const components = extractAddressComponents(addr);
                    addressComponentsCache.set(addr, components);
                    return components;
                }

                // Second pass: Merge similar addresses regardless of distance
                // Then use clustering to find correct coordinates (outliers get corrected)
                const mergedGroups = [];
                const processedKeys = new Set();

                // PERFORMANCE: Pré-calcular número de casa e normalização para todos os grupos
                const groupKeys = Object.keys(initialGroups);
                const groupMetadata = new Map();
                groupKeys.forEach(key => {
                    const group = initialGroups[key];
                    groupMetadata.set(key, {
                        houseNumber: extractHouseNumber(group.originalAddress),
                        components: getCachedComponents(group.originalAddress),
                        normalizedBairro: normalizeBairro(group.originalBairro),
                        normalizedCep: normalizeCep(group.originalZipcode)
                    });
                });

                // PERFORMANCE: Agrupar por número de casa para reduzir comparações O(n²) → O(n)
                const byHouseNumber = new Map();
                groupKeys.forEach(key => {
                    const meta = groupMetadata.get(key);
                    const houseNum = meta.houseNumber || 'NO_NUMBER';
                    if (!byHouseNumber.has(houseNum)) {
                        byHouseNumber.set(houseNum, []);
                    }
                    byHouseNumber.get(houseNum).push(key);
                });

                // Progresso: pré-processamento concluído (35%)
                updateProgress(35);

                // PERFORMANCE: Liberar thread antes do loop de merge
                await yieldToMain();

                // PERFORMANCE: Processar em lotes para evitar travamento
                let processedCount = 0;
                const BATCH_SIZE = 20;

                for (const key1 of groupKeys) {
                    if (processedKeys.has(key1)) continue;

                    const group1 = initialGroups[key1];
                    const meta1 = groupMetadata.get(key1);
                    const mergedItems = [...group1.items];
                    processedKeys.add(key1);

                    let mergeCount = 0;

                    // PERFORMANCE: Só comparar com endereços que têm o MESMO número de casa
                    const sameHouseKeys = byHouseNumber.get(meta1.houseNumber || 'NO_NUMBER') || [];

                    sameHouseKeys.forEach(key2 => {
                        if (processedKeys.has(key2)) return;
                        if (key1 === key2) return;

                        const group2 = initialGroups[key2];
                        // Check if addresses should be merged (similar text AND same house number)
                        const shouldMerge = shouldMergeAddresses(
                            group1.originalAddress,
                            group2.originalAddress,
                            key1,
                            key2,
                            group1.originalBairro,
                            group2.originalBairro,
                            group1.originalZipcode,
                            group2.originalZipcode
                        );

                        if (shouldMerge) {
                            // Check if both have registered clients with distant coordinates
                            // PERFORMANCE: Usar cache para evitar recálculos
                            const match1 = getCachedClientMatch(group1.originalAddress, group1.originalBairro, group1.originalZipcode);
                            const match2 = getCachedClientMatch(group2.originalAddress, group2.originalBairro, group2.originalZipcode);

                            if (match1 && match2) {
                                // Check if they are DIFFERENT clients
                                if (match1.client.id !== match2.client.id) {
                                    // Different clients - check distance between their coordinates
                                    const distance = haversineDistance(
                                        match1.client.latitude, match1.client.longitude,
                                        match2.client.latitude, match2.client.longitude
                                    );

                                    if (distance > 0.1) {
                                        return;
                                    }
                                }
                            }

                            mergedItems.push(...group2.items);
                            processedKeys.add(key2);
                            mergeCount++;
                        }
                    });

                    // Use clustering to find the correct coordinates
                    // Group coordinates that are close together, pick the largest cluster
                    // Only include items that have valid coordinates
                    const coordClusters = [];
                    const itemsWithCoords = mergedItems.filter(item => item.latitude && item.longitude);
                    const itemsWithoutCoords = mergedItems.filter(item => !item.latitude || !item.longitude);

                    itemsWithCoords.forEach(item => {
                        // Find a cluster within 200m
                        let foundCluster = null;
                        for (const cluster of coordClusters) {
                            const dist = haversineDistance(cluster.lat, cluster.lng, item.latitude, item.longitude);
                            if (dist <= 0.2) { // Within 200 meters
                                foundCluster = cluster;
                                break;
                            }
                        }

                        if (foundCluster) {
                            // Add to existing cluster, update centroid
                            const totalCount = foundCluster.count + 1;
                            foundCluster.lat = (foundCluster.lat * foundCluster.count + item.latitude) / totalCount;
                            foundCluster.lng = (foundCluster.lng * foundCluster.count + item.longitude) / totalCount;
                            foundCluster.count = totalCount;
                        } else {
                            // Create new cluster
                            coordClusters.push({ lat: item.latitude, lng: item.longitude, count: 1 });
                        }
                    });

                    // Find the largest cluster (most items = most likely correct location)
                    let bestCluster = coordClusters.length > 0 ? coordClusters[0] : null;
                    coordClusters.forEach(cluster => {
                        if (cluster.count > bestCluster.count) {
                            bestCluster = cluster;
                        }
                    });

                    // Build the merged group with corrected coordinates
                    const sequences = [];
                    const stopsList = [];
                    const ids = [];
                    const allAddresses = []; // Store all unique addresses in this group
                    const allAddressesWithDetails = []; // Store addresses with bairro/zipcode for matching
                    const addressSequencePairs = []; // Store address+sequence pairs
                    let deliveryStatus = null;
                    mergedItems.forEach(item => {
                        if (item.sequence && !sequences.includes(item.sequence)) {
                            sequences.push(item.sequence);
                        }
                        if (item.stop && !stopsList.includes(item.stop)) {
                            stopsList.push(item.stop);
                        }
                        if (item.id) {
                            ids.push(item.id);
                        }
                        // Collect all unique addresses with their bairro/zipcode
                        if (item.destination_address && !allAddresses.includes(item.destination_address)) {
                            allAddresses.push(item.destination_address);
                            allAddressesWithDetails.push({
                                address: item.destination_address,
                                bairro: item.bairro,
                                zipcode: item.zipcode
                            });
                        }
                        // Store address+sequence pairs for popup display
                        if (item.destination_address && item.sequence) {
                            addressSequencePairs.push({
                                address: item.destination_address,
                                sequence: item.sequence
                            });
                        }
                        // Use the first non-null delivery_status found
                        if (!deliveryStatus && item.delivery_status) {
                            deliveryStatus = item.delivery_status;
                        }
                    });

                    // Check if ANY address in this group has a registered client (Option 1: at least one)
                    // Collect ALL registered clients for this group, then cluster their coordinates
                    // PERFORMANCE: Usar cache para evitar recálculos
                    const registeredMatches = [];
                    for (const addrDetails of allAddressesWithDetails) {
                        const match = getCachedClientMatch(addrDetails.address, addrDetails.bairro, addrDetails.zipcode);
                        if (match) {
                            registeredMatches.push(match);
                        }
                    }

                    // Determine match type: 'exact' if ALL matches are exact, 'similarity' if at least one is similarity
                    let matchType = null;
                    let matchedClientAddress = null;
                    if (registeredMatches.length > 0) {
                        const hasAnySimilarity = registeredMatches.some(m => m.matchType === 'similarity');
                        matchType = hasAnySimilarity ? 'similarity' : 'exact';

                        // Se houver match por similaridade, armazena o endereço do cliente para exibir no popup
                        if (matchType === 'similarity') {
                            const similarityMatch = registeredMatches.find(m => m.matchType === 'similarity');
                            if (similarityMatch) {
                                matchedClientAddress = similarityMatch.client.address;
                            }
                        }
                    }

                    // Check if similarity was disabled by user for ANY item in this group
                    const hasSimilarityDisabled = mergedItems.some(item => item.similarity_disabled === true);
                    let wasDeactivated = false;
                    let originalMatchType = null;
                    let originalMatchedClientAddress = null;
                    let originalCoordinates = null;

                    // Determine final coordinates
                    // Priority: 1. User override (similarity disabled), 2. Registered client coords (GREEN/PURPLE), 3. Planilha coords (RED)
                    let finalLat, finalLng;
                    let hasValidCoords = false;

                    if (hasSimilarityDisabled) {
                        // User disabled similarity - use planilha coordinates
                        const disabledItem = mergedItems.find(item => item.similarity_disabled === true);
                        if (disabledItem && disabledItem.similarity_original_lat && disabledItem.similarity_original_lng) {
                            finalLat = disabledItem.similarity_original_lat;
                            finalLng = disabledItem.similarity_original_lng;
                            hasValidCoords = true;
                            wasDeactivated = true;

                            // Save original match data for reactivation
                            if (registeredMatches.length > 0) {
                                originalMatchType = matchType;
                                originalMatchedClientAddress = matchedClientAddress;
                                const clientLat = registeredMatches.reduce((sum, m) => sum + m.client.latitude, 0) / registeredMatches.length;
                                const clientLng = registeredMatches.reduce((sum, m) => sum + m.client.longitude, 0) / registeredMatches.length;
                                originalCoordinates = JSON.stringify([clientLng, clientLat]);
                            }

                            // Override match data to show as unregistered
                            matchType = null;
                            matchedClientAddress = null;
                        }
                    } else if (registeredMatches.length > 0) {
                        // Match found! Use client coordinates (GREEN or PURPLE marker)
                        finalLat = registeredMatches.reduce((sum, m) => sum + m.client.latitude, 0) / registeredMatches.length;
                        finalLng = registeredMatches.reduce((sum, m) => sum + m.client.longitude, 0) / registeredMatches.length;
                        hasValidCoords = true;
                    } else {
                        // NO match - use planilha coordinates (RED marker)
                        // Try bestCluster first, otherwise use first item with valid coords
                        if (bestCluster) {
                            finalLat = bestCluster.lat;
                            finalLng = bestCluster.lng;
                            hasValidCoords = true;
                        } else if (itemsWithCoords.length > 0) {
                            // Fallback: use first item's coordinates directly
                            finalLat = itemsWithCoords[0].latitude;
                            finalLng = itemsWithCoords[0].longitude;
                            hasValidCoords = true;
                        } else {
                            // Last resort: check if ANY mergedItem has coords
                            const itemWithCoord = mergedItems.find(item => item.latitude && item.longitude);
                            if (itemWithCoord) {
                                finalLat = itemWithCoord.latitude;
                                finalLng = itemWithCoord.longitude;
                                hasValidCoords = true;
                            }
                        }
                    }

                    // Add to mergedGroups if we have valid coordinates
                    if (hasValidCoords) {
                        mergedGroups.push({
                            address: group1.originalAddress,
                            allAddresses: allAddresses,
                            addressSequencePairs: addressSequencePairs,
                            latitude: finalLat,
                            longitude: finalLng,
                            sequences: sequences,
                            stops: stopsList,
                            ids: ids,
                            deliveryStatus: deliveryStatus,
                            isRegistered: wasDeactivated ? false : (registeredMatches.length > 0), // GREEN/PURPLE if match, RED if not or disabled
                            matchType: matchType, // 'exact', 'similarity', or null
                            matchedClientAddress: matchedClientAddress, // Endereço do cliente encontrado por similaridade
                            wasDeactivated: wasDeactivated, // Flag indicando que foi desativado pelo usuário
                            originalMatchType: originalMatchType, // Match type original (para reativação)
                            originalMatchedClientAddress: originalMatchedClientAddress, // Endereço original (para reativação)
                            originalCoordinates: originalCoordinates, // Coordenadas originais do cliente (para reativação)
                            bairro: group1.originalBairro || null,
                            zipcode: group1.originalZipcode || null
                        });
                    }

                    // PERFORMANCE: Liberar thread a cada lote processado
                    processedCount++;
                    if (processedCount % BATCH_SIZE === 0) {
                        await yieldToMain();
                        // Progresso: 35% a 65% durante o merge (30% da barra)
                        const mergeProgress = 35 + Math.floor((processedCount / groupKeys.length) * 30);
                        updateProgress(mergeProgress);
                    }
                }

                // Progresso: merge concluído (65%)
                updateProgress(65);

                // Post-process: Merge groups that are at the EXACT same geographic location
                // This handles cases where different addresses have identical coordinates in the spreadsheet
                const finalGroups = [];
                const coordKey = (lat, lng) => `${lat.toFixed(6)}_${lng.toFixed(6)}`;
                const coordMap = new Map();

                mergedGroups.forEach(group => {
                    const key = coordKey(group.latitude, group.longitude);

                    if (coordMap.has(key)) {
                        // Merge with existing group at this location
                        const existing = coordMap.get(key);

                        // Merge all addresses
                        group.allAddresses.forEach(addr => {
                            if (!existing.allAddresses.includes(addr)) {
                                existing.allAddresses.push(addr);
                            }
                        });

                        // Merge address-sequence pairs
                        group.addressSequencePairs.forEach(pair => {
                            const exists = existing.addressSequencePairs.some(p =>
                                p.sequence === pair.sequence && p.address === pair.address
                            );
                            if (!exists) {
                                existing.addressSequencePairs.push(pair);
                            }
                        });

                        // Merge sequences
                        group.sequences.forEach(seq => {
                            if (!existing.sequences.includes(seq)) {
                                existing.sequences.push(seq);
                            }
                        });

                        // Merge stops
                        group.stops.forEach(stop => {
                            if (!existing.stops.includes(stop)) {
                                existing.stops.push(stop);
                            }
                        });

                        // Merge ids
                        group.ids.forEach(id => {
                            if (!existing.ids.includes(id)) {
                                existing.ids.push(id);
                            }
                        });

                        // Use the most favorable registration status (if any is registered, show green/orange)
                        if (group.isRegistered) {
                            existing.isRegistered = true;
                            // Se qualquer um dos grupos tiver match por similaridade, use 'similarity'
                            // Prioridade: exact > similarity > null
                            if (!existing.matchType || existing.matchType === 'similarity') {
                                existing.matchType = group.matchType;
                            } else if (existing.matchType === 'exact' && group.matchType === 'similarity') {
                                existing.matchType = 'similarity';
                            }
                            // Preserva o matchedClientAddress do grupo que tem match de similaridade
                            if (group.matchType === 'similarity' && group.matchedClientAddress) {
                                existing.matchedClientAddress = group.matchedClientAddress;
                            } else if (!existing.matchedClientAddress && group.matchedClientAddress) {
                                existing.matchedClientAddress = group.matchedClientAddress;
                            }
                        }
                    } else {
                        // New location - add to map
                        coordMap.set(key, group);
                        finalGroups.push(group);
                    }
                });

                // PERFORMANCE: Liberar thread após processamento pesado
                await yieldToMain();

                // Progresso: pós-processamento concluído (75%)
                updateProgress(75);

                const stops = finalGroups;

                // Determine icon color based on delivery status and match type
                function getIconColor(stop) {
                    if (stop.deliveryStatus === 'delivered') return 'gray';
                    if (stop.deliveryStatus === 'not_delivered') return 'gray-x';

                    if (stop.isRegistered) {
                        // Verde: match exato (normalizado igual)
                        // Roxo: match por similaridade
                        return stop.matchType === 'exact' ? 'green' : 'purple';
                    }

                    return 'red'; // Não cadastrado
                }

                // Generate and add high-resolution pin icons for each unique config needed
                const iconConfigs = new Set();
                stops.forEach(stop => {
                    const packageCount = stop.sequences.length;
                    const color = getIconColor(stop);
                    iconConfigs.add(`${packageCount}-${color}`);
                });

                const iconPromises = Array.from(iconConfigs).map(config => {
                    return new Promise((resolve) => {
                        // Split only on first dash to handle "gray-x" color
                        const firstDash = config.indexOf('-');
                        const count = config.substring(0, firstDash);
                        const color = config.substring(firstDash + 1);
                        const iconName = `pin-${color}-${count}`;

                        // Only create if icon doesn't exist
                        if (map.hasImage(iconName)) {
                            resolve();
                            return;
                        }

                        const { dataUrl, pixelRatio } = generatePinIcon(parseInt(count), color);
                        const img = new Image();
                        img.onload = () => {
                            if (!map.hasImage(iconName)) {
                                map.addImage(iconName, img, { pixelRatio: pixelRatio });
                            }
                            resolve();
                        };
                        img.onerror = () => resolve();
                        img.src = dataUrl;
                    });
                });

                await Promise.all(iconPromises);

                // Progresso: ícones criados (85%)
                updateProgress(85);

                // Create GeoJSON features
                const features = stops.map(stop => {
                    stop.sequences.sort((a, b) => a - b);
                    stop.stops.sort((a, b) => a - b);
                    const packageCount = stop.sequences.length;
                    const color = getIconColor(stop);
                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [stop.longitude, stop.latitude]
                        },
                        properties: {
                            packageCount: packageCount,
                            allStops: stop.stops.join(', '),
                            icon: `pin-${color}-${packageCount}`,
                            address: stop.address || 'Endereço não disponível',
                            allAddresses: stop.allAddresses ? stop.allAddresses.join('|||') : '', // Store all addresses separated by |||
                            addressSequencePairs: stop.addressSequencePairs ? JSON.stringify(stop.addressSequencePairs) : '', // Store address+sequence pairs
                            sequences: stop.sequences.join(', '),
                            isRegistered: stop.isRegistered,
                            matchType: stop.matchType || null, // 'exact', 'similarity', or null
                            matchedClientAddress: stop.matchedClientAddress || '', // Endereço do cliente encontrado por similaridade
                            wasDeactivated: stop.wasDeactivated || false, // Flag de desativação pelo usuário
                            originalMatchType: stop.originalMatchType || null, // Match type original (para reativação)
                            originalMatchedClientAddress: stop.originalMatchedClientAddress || '', // Endereço original (para reativação)
                            originalCoordinates: stop.originalCoordinates || null, // Coordenadas originais do cliente (para reativação)
                            ids: stop.ids.join(','),
                            deliveryStatus: stop.deliveryStatus || 'pending',
                            bairro: stop.bairro || '',
                            zipcode: stop.zipcode || ''
                        }
                    };
                });

                const geojson = {
                    type: 'FeatureCollection',
                    features: features
                };

                // Add or update source
                if (map.getSource('route-stops')) {
                    // Remove old images to force regeneration with new colors
                    const layerIds = map.getStyle().layers.filter(layer => layer.id.startsWith('pin-')).map(layer => layer.id);
                    layerIds.forEach(id => {
                        try {
                            if (map.hasImage(id)) {
                                map.removeImage(id);
                            }
                        } catch (e) {
                            // Image doesn't exist, continue
                        }
                    });

                    map.getSource('route-stops').setData(geojson);
                    // Force Mapbox to re-render the layer by toggling visibility
                    map.setLayoutProperty('route-stops-pins', 'visibility', 'none');
                    map.setLayoutProperty('route-stops-pins', 'visibility', 'visible');
                } else {
                    map.addSource('route-stops', {
                        type: 'geojson',
                        data: geojson
                    });

                    // Add symbol layer with custom pin icons
                    map.addLayer({
                        id: 'route-stops-pins',
                        type: 'symbol',
                        source: 'route-stops',
                        layout: {
                            'icon-image': ['get', 'icon'],
                            'icon-size': 1,
                            'icon-anchor': 'bottom',
                            'icon-allow-overlap': true
                        }
                    });

                    // Add click event for popup
                    map.on('click', 'route-stops-pins', (e) => {
                        const feature = e.features[0];
                        const coords = feature.geometry.coordinates.slice();
                        const props = feature.properties;

                        const sequencesArr = props.sequences ? props.sequences.split(', ') : [];
                        const ordersHtml = sequencesArr.map(seq =>
                            `<span class="route-popup-order">${seq}</span>`
                        ).join('');

                        // Check if there are multiple addresses in this stop
                        const addressSequencePairs = props.addressSequencePairs ? JSON.parse(props.addressSequencePairs) : [];
                        const hasMultipleAddresses = addressSequencePairs.length > 1;

                        // Build bairro and CEP info display
                        const bairroDisplay = props.bairro ? `<span style="font-size: 10px; color: #8b5cf6; font-weight: 500; padding: 2px 6px; background: rgba(139, 92, 246, 0.1); border-radius: 4px;">🏘️ ${props.bairro}</span>` : '';
                        const cepDisplay = props.zipcode ? `<span style="font-size: 10px; color: #0ea5e9; font-weight: 500; padding: 2px 6px; background: rgba(14, 165, 233, 0.1); border-radius: 4px;">📮 ${props.zipcode}</span>` : '';
                        const locationInfo = (bairroDisplay || cepDisplay) ? `<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; margin-bottom: 8px;">${bairroDisplay}${cepDisplay}</div>` : '';

                        // Build address display with matched client address for similarity matches
                        let addressDisplay = '';

                        // Se for match por similaridade, mostrar endereço do cliente cadastrado acima (clicável para desativar similaridade)
                        const similarityHeader = (props.matchType === 'similarity' && props.matchedClientAddress)
                            ? `<div class="similarity-matched-address" data-ids="${props.ids}" style="font-size: 12px; font-weight: 600; color: #8b5cf6; margin-bottom: 4px; padding: 6px 8px; background: rgba(139, 92, 246, 0.1); border-radius: 6px; border-left: 3px solid #8b5cf6; cursor: pointer; transition: all 0.2s ease;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 0.2)'; this.style.borderLeftWidth='4px';"
                                    onmouseout="this.style.background='rgba(139, 92, 246, 0.1)'; this.style.borderLeftWidth='3px';">
                                   📍 ${props.matchedClientAddress}
                                   <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para usar coordenadas da planilha</div>
                               </div>
                               <div style="font-size: 10px; color: #64748b; margin-bottom: 8px; font-weight: 500;">
                                   ↓ Endereço da planilha:
                               </div>`
                            : '';

                        // Se for marcador vermelho que foi desativado, mostrar opção de reativar similaridade
                        const reactivateSimilarityHeader = (props.wasDeactivated && props.originalMatchedClientAddress)
                            ? `<div class="reactivate-similarity-address" data-ids="${props.ids}" style="font-size: 11px; font-weight: 600; color: #ef4444; margin-bottom: 8px; padding: 6px 8px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid #ef4444; cursor: pointer; transition: all 0.2s ease;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 0.15)'; this.style.borderLeftColor='#8b5cf6';"
                                    onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderLeftColor='#ef4444';">
                                   🔄 Voltar para: ${props.originalMatchedClientAddress}
                                   <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para reativar similaridade</div>
                               </div>`
                            : '';

                        if (hasMultipleAddresses) {
                            addressDisplay = `
                                ${similarityHeader}
                                ${reactivateSimilarityHeader}
                                <div style="font-size: 11px; color: #8b5cf6; font-weight: 600; margin-bottom: 4px;">📦 ${addressSequencePairs.length} pacotes nesta parada:</div>
                                ${locationInfo}
                                <div style="font-size: 11px; line-height: 1.5; max-height: 120px; overflow-y: auto; margin-bottom: 8px;">
                                    ${addressSequencePairs.map(pair => `<div style="margin-bottom: 3px;"><span style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 2px 6px; border-radius: 4px; font-weight: 600; margin-right: 4px; font-size: 10px;">${pair.sequence}</span> ${pair.address}</div>`).join('')}
                                </div>
                            `;
                        } else if (addressSequencePairs.length === 1) {
                            addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${addressSequencePairs[0].address}</div>${locationInfo}`;
                        } else {
                            addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${props.address}</div>${locationInfo}`;
                        }

                        // Determine current status for button styling
                        const currentStatus = props.deliveryStatus || 'pending';
                        const isDelivered = currentStatus === 'delivered';
                        const isNotDelivered = currentStatus === 'not_delivered';

                        closeRoutePopup();

                        // Only show order section at bottom if single address (multiple addresses show order inline)
                        const orderSection = hasMultipleAddresses ? '' : `
                            <div style="display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 6px;">
                                <span style="font-size: 11px; color: #64748b;">Ordem:</span>
                                <div class="route-popup-orders">${ordersHtml || '<span style="color: #94a3b8;">Sem ordem</span>'}</div>
                            </div>
                        `;

                        // Responsive maxWidth for popup - aumentado para acomodar 3 botões
                        const isMobile = window.innerWidth <= 480;
                        const popupMaxWidth = isMobile ? '280px' : '320px';

                        routePopup = ResourceRegistry.registerPopup(new mapboxgl.Popup({
                            offset: [0, -50],
                            closeButton: true,
                            closeOnClick: true,
                            maxWidth: popupMaxWidth
                        })
                            .setLngLat(coords)
                            .setHTML(`
                                <div class="route-popup-content">
                                    ${addressDisplay}
                                    ${orderSection}
                                    <div class="route-popup-actions">
                                        <button class="route-popup-btn ${isDelivered ? 'active' : ''}" data-action="delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
                                            <span class="btn-text">${isDelivered ? 'Desfazer' : 'Entregue'}</span>
                                        </button>
                                        <button class="route-popup-btn not-delivered ${isNotDelivered ? 'active' : ''}" data-action="not_delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                                            <span class="btn-text">${isNotDelivered ? 'Desfazer' : 'Não entreg'}</span>
                                        </button>
                                        <button class="route-popup-btn navigate" data-lng="${coords[0]}" data-lat="${coords[1]}" data-address="${props.address}" data-order="${sequencesArr.join(', ') || '-'}" data-ids="${props.ids}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>
                                            Navegar
                                        </button>
                                    </div>
                                </div>
                            `)
                            .addTo(map));

                        // Add click handlers for delivery buttons
                        const popupContent = routePopup.getElement();
                        popupContent.querySelectorAll('.route-popup-btn:not(.navigate)').forEach(btn => {
                            btn.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const action = btn.dataset.action; // 'delivered' or 'not_delivered'
                                const currentStatusData = btn.dataset.currentStatus;
                                const ids = btn.dataset.ids.split(',').map(id => parseInt(id));

                                let statusToSave = null;

                                if (btn.classList.contains('active')) {
                                    statusToSave = 'pending';
                                } else {
                                    statusToSave = action;
                                }

                                // OPTIMISTIC UPDATE - Atualiza UI imediatamente
                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                // Atualiza a propriedade do marcador localmente
                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);
                                if (markerFeature) {
                                    markerFeature.properties.deliveryStatus = statusToSave;

                                    // Atualiza o ícone baseado no novo status e tipo de match
                                    let newColor;
                                    if (statusToSave === 'delivered') {
                                        newColor = 'gray';
                                    } else if (statusToSave === 'not_delivered') {
                                        newColor = 'gray-x';
                                    } else if (props.isRegistered) {
                                        // Verde se match exato, roxo se match por similaridade
                                        newColor = props.matchType === 'exact' ? 'green' : 'purple';
                                    } else {
                                        newColor = 'red';
                                    }

                                    const newIconName = `pin-${newColor}-${props.packageCount}`;
                                    markerFeature.properties.icon = newIconName;

                                    // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                    map.getSource('route-stops').setData(sourceData);
                                    updateRouteMarkersCache(sourceData);

                                    // Carrega ícone em background se não existir
                                    if (!map.hasImage(newIconName)) {
                                        const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                                        const img = new Image();
                                        img.onload = () => {
                                            if (!map.hasImage(newIconName)) {
                                                map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                            }
                                            // Re-renderiza para mostrar o ícone correto
                                            map.getSource('route-stops').setData(sourceData);
                                        };
                                        img.src = dataUrl;
                                    }
                                }

                                // Update fixed stats panel after status change
                                updateFixedStatsPanel();

                                // Sincroniza em background (não bloqueia a UI)
                                updateDeliveryStatus(ids, statusToSave).catch(err => {
                                    // Erro ao sincronizar status
                                });
                            });
                        });

                        // Add click handler for navigate button
                        const navBtn = popupContent.querySelector('.route-popup-btn.navigate');
                        if (navBtn) {
                            navBtn.addEventListener('click', (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();
                                const destLng = parseFloat(navBtn.dataset.lng);
                                const destLat = parseFloat(navBtn.dataset.lat);
                                const destAddress = navBtn.dataset.address;
                                const destOrder = navBtn.dataset.order || '-';
                                const destIds = navBtn.dataset.ids || '';
                                closeRoutePopup();
                                startNavigation(destLng, destLat, destAddress, destOrder, destIds);
                            });
                        }

                        // Add click handler for similarity matched address (desativar similaridade)
                        const similarityAddress = popupContent.querySelector('.similarity-matched-address');
                        if (similarityAddress) {
                            similarityAddress.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const ids = similarityAddress.dataset.ids.split(',').map(id => parseInt(id));

                                // Fecha o popup
                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                // Busca as coordenadas originais da planilha para esses IDs
                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);

                                if (markerFeature) {
                                    // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                                    // porque props pode estar desatualizado após setData() de reativação
                                    const currentProps = markerFeature.properties;

                                    // Busca as coordenadas originais da planilha
                                    let originalLat = null;
                                    let originalLng = null;

                                    // Busca nos dados originais da planilha
                                    if (window.currentRouteData) {
                                        const itemsForThisMarker = window.currentRouteData.filter(item =>
                                            ids.includes(item.id) && item.latitude && item.longitude
                                        );

                                        if (itemsForThisMarker.length > 0) {
                                            // Calcula a média das coordenadas da planilha (pode haver múltiplos pontos)
                                            originalLat = itemsForThisMarker.reduce((sum, item) => sum + item.latitude, 0) / itemsForThisMarker.length;
                                            originalLng = itemsForThisMarker.reduce((sum, item) => sum + item.longitude, 0) / itemsForThisMarker.length;
                                        }
                                    }

                                    if (originalLat && originalLng) {
                                        // Salva os dados originais do match de similaridade para permitir reversão
                                        markerFeature.properties.originalMatchType = currentProps.matchType;
                                        markerFeature.properties.originalMatchedClientAddress = currentProps.matchedClientAddress;
                                        markerFeature.properties.originalCoordinates = JSON.stringify(markerFeature.geometry.coordinates);

                                        // Atualiza as propriedades do marcador
                                        markerFeature.properties.matchType = null;
                                        markerFeature.properties.isRegistered = false;
                                        markerFeature.properties.matchedClientAddress = '';
                                        markerFeature.properties.wasDeactivated = true; // Flag para indicar que foi desativado
                                        markerFeature.geometry.coordinates = [originalLng, originalLat];

                                        // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                                        const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                                        let newColor;
                                        if (currentDeliveryStatus === 'delivered') {
                                            newColor = 'gray';
                                        } else if (currentDeliveryStatus === 'not_delivered') {
                                            newColor = 'gray-x';
                                        } else {
                                            newColor = 'red'; // Não cadastrado (similaridade desativada)
                                        }
                                        const newIconName = `pin-${newColor}-${props.packageCount}`;
                                        markerFeature.properties.icon = newIconName;

                                        // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                        map.getSource('route-stops').setData(sourceData);
                                        updateRouteMarkersCache(sourceData);

                                        // Move o mapa para a nova posição
                                        map.flyTo({
                                            center: [originalLng, originalLat],
                                            zoom: 16,
                                            duration: 1500
                                        });

                                        // Carrega ícone em background se não existir
                                        if (!map.hasImage(newIconName)) {
                                            const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                                            const img = new Image();
                                            img.onload = () => {
                                                if (!map.hasImage(newIconName)) {
                                                    map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                                }
                                                // Re-renderiza para mostrar o ícone correto
                                                map.getSource('route-stops').setData(sourceData);
                                            };
                                            img.src = dataUrl;
                                        }

                                        // Atualiza estatísticas
                                        updateFixedStatsPanel();

                                        // Salva no banco de dados
                                        updateSimilarityOverride(ids, true, originalLat, originalLng).catch(err => {
                                            console.error('Erro ao salvar desativação de similaridade:', err);
                                        });
                                    }
                                }
                            });
                        }

                        // Add click handler for reactivate similarity address (reativar similaridade)
                        const reactivateAddress = popupContent.querySelector('.reactivate-similarity-address');
                        if (reactivateAddress) {
                            reactivateAddress.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const ids = reactivateAddress.dataset.ids.split(',').map(id => parseInt(id));

                                // Fecha o popup
                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                // Busca o marcador
                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);

                                // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                                // porque props pode estar desatualizado após setData() de sincronização
                                const currentProps = markerFeature ? markerFeature.properties : null;

                                if (markerFeature && currentProps && currentProps.originalCoordinates) {
                                    // Restaura as coordenadas originais (do cliente cadastrado)
                                    const originalCoords = JSON.parse(currentProps.originalCoordinates);

                                    // Restaura as propriedades do match de similaridade
                                    markerFeature.properties.matchType = currentProps.originalMatchType;
                                    markerFeature.properties.isRegistered = true;
                                    markerFeature.properties.matchedClientAddress = currentProps.originalMatchedClientAddress;
                                    markerFeature.properties.wasDeactivated = false;
                                    markerFeature.geometry.coordinates = originalCoords;

                                    // Remove as propriedades salvas
                                    markerFeature.properties.originalMatchType = null;
                                    markerFeature.properties.originalMatchedClientAddress = null;
                                    markerFeature.properties.originalCoordinates = null;

                                    // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                                    const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                                    let newColor;
                                    if (currentDeliveryStatus === 'delivered') {
                                        newColor = 'gray';
                                    } else if (currentDeliveryStatus === 'not_delivered') {
                                        newColor = 'gray-x';
                                    } else {
                                        newColor = 'purple'; // Similaridade reativada
                                    }
                                    const newIconName = `pin-${newColor}-${currentProps.packageCount}`;
                                    markerFeature.properties.icon = newIconName;

                                    // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                    map.getSource('route-stops').setData(sourceData);
                                    updateRouteMarkersCache(sourceData);

                                    // Move o mapa de volta para a posição original
                                    map.flyTo({
                                        center: originalCoords,
                                        zoom: 16,
                                        duration: 1500
                                    });

                                    // Carrega ícone em background se não existir
                                    if (!map.hasImage(newIconName)) {
                                        const { dataUrl, pixelRatio } = generatePinIcon(currentProps.packageCount, newColor);
                                        const img = new Image();
                                        img.onload = () => {
                                            if (!map.hasImage(newIconName)) {
                                                map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                            }
                                            // Re-renderiza para mostrar o ícone correto
                                            map.getSource('route-stops').setData(sourceData);
                                        };
                                        img.src = dataUrl;
                                    }

                                    // Atualiza estatísticas
                                    updateFixedStatsPanel();

                                    // Salva no banco de dados (reativa similaridade)
                                    updateSimilarityOverride(ids, false).catch(err => {
                                        console.error('Erro ao salvar reativação de similaridade:', err);
                                    });
                                }
                            });
                        }

                    });

                    // Change cursor on hover
                    map.on('mouseenter', 'route-stops-pins', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'route-stops-pins', () => {
                        map.getCanvas().style.cursor = '';
                    });
                }

                // Show layer
                map.setLayoutProperty('route-stops-pins', 'visibility', 'visible');

                // Progresso: marcadores exibidos (100%)
                updateProgress(100);

                routeMarkersVisible = true;
                routeMarkersBtn.classList.add('active');

                // Fit map to show all markers (only on first load, not on status updates)
                if (features.length > 0 && !skipFitBounds) {
                    const bounds = new mapboxgl.LngLatBounds();
                    features.forEach(f => bounds.extend(f.geometry.coordinates));
                    map.fitBounds(bounds, { padding: 50, duration: 1500 });
                }

                // PERFORMANCE: Restaurar botão após carregamento com delay para animação
                if (routeBtn) {
                    setTimeout(() => {
                        routeBtn.classList.remove('loading');
                        routeBtn.style.pointerEvents = 'auto';
                        updateProgress(0); // Reset para próximo uso
                    }, 300);
                }

                // Update fixed stats panel with route data
                updateFixedStatsPanel();

                // Save route markers to cache for persistence across page reloads
                try {
                    const statsToSave = {
                        total: features.filter(f => f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                        registered: features.filter(f => f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                        unregistered: features.filter(f => !f.properties.isRegistered && f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered').length,
                        pending: features.reduce((sum, f) => {
                            if (f.properties.deliveryStatus !== 'delivered' && f.properties.deliveryStatus !== 'not_delivered') {
                                return sum + (f.properties.packageCount || 1);
                            }
                            return sum;
                        }, 0),
                        delivered: features.reduce((sum, f) => {
                            if (f.properties.deliveryStatus === 'delivered' || f.properties.deliveryStatus === 'not_delivered') {
                                return sum + (f.properties.packageCount || 1);
                            }
                            return sum;
                        }, 0)
                    };
                    await saveRouteMarkersToCache(geojson, statsToSave);
                } catch (cacheErr) {
                    // Silently fail - cache is not critical
                }

            } catch (error) {
                // PERFORMANCE: Restaurar botão em caso de erro
                const routeBtn = document.getElementById('routeMarkersBtn');
                const progressFill = document.getElementById('routeProgressFill');
                if (routeBtn) {
                    routeBtn.classList.remove('loading');
                    routeBtn.style.pointerEvents = 'auto';
                }
                if (progressFill) {
                    progressFill.style.height = '0%';
                }
                showErrorModal('Erro ao carregar as paradas da planilha.');
            }
        }

        function removeRouteMarkers() {
            if (map.getLayer('route-stops-pins')) {
                map.setLayoutProperty('route-stops-pins', 'visibility', 'none');
            }
            if (routePopup) {
                closeRoutePopup();
                routePopup = null;
            }
            routeMarkersVisible = false;
            routeMarkersBtn.classList.remove('active');

            // Hide fixed stats panel when markers are removed
            hideFixedStatsPanel();
        }

        // Load route markers from cache (fast, skips all calculations)
        // Uses the same popup structure and handlers as loadRouteMarkers
        async function loadCachedRouteMarkers() {
            try {
                const cachedData = await getCachedRouteMarkers();
                if (!cachedData || !cachedData.geojson || !cachedData.geojson.features || cachedData.geojson.features.length === 0) {
                    return false; // No cached data
                }

                const geojson = cachedData.geojson;
                const stats = cachedData.stats;

                // Generate and add pin icons for each unique config needed
                const iconConfigs = new Set();
                geojson.features.forEach(feature => {
                    const icon = feature.properties.icon;
                    if (icon) {
                        iconConfigs.add(icon);
                    }
                });

                const iconPromises = Array.from(iconConfigs).map(iconName => {
                    return new Promise((resolve) => {
                        if (map.hasImage(iconName)) {
                            resolve();
                            return;
                        }

                        // Parse icon name: pin-{color}-{count}
                        const parts = iconName.replace('pin-', '').split('-');
                        let color, count;
                        if (parts.length === 2 && parts[0] === 'gray' && parts[1] === 'x') {
                            color = 'gray-x';
                            count = parseInt(iconName.split('-').pop());
                        } else if (parts[0] === 'gray' && parts.length === 3) {
                            color = 'gray-x';
                            count = parseInt(parts[2]);
                        } else {
                            count = parseInt(parts.pop());
                            color = parts.join('-');
                        }

                        const { dataUrl, pixelRatio } = generatePinIcon(count, color);
                        const img = new Image();
                        img.onload = () => {
                            if (!map.hasImage(iconName)) {
                                map.addImage(iconName, img, { pixelRatio: pixelRatio });
                            }
                            resolve();
                        };
                        img.onerror = () => resolve();
                        img.src = dataUrl;
                    });
                });

                await Promise.all(iconPromises);

                // Add or update source
                if (map.getSource('route-stops')) {
                    map.getSource('route-stops').setData(geojson);
                    map.setLayoutProperty('route-stops-pins', 'visibility', 'visible');
                } else {
                    map.addSource('route-stops', {
                        type: 'geojson',
                        data: geojson
                    });

                    // Add symbol layer with custom pin icons
                    map.addLayer({
                        id: 'route-stops-pins',
                        type: 'symbol',
                        source: 'route-stops',
                        layout: {
                            'icon-image': ['get', 'icon'],
                            'icon-size': 1,
                            'icon-anchor': 'bottom',
                            'icon-allow-overlap': true
                        }
                    });

                    // Add click event for popup (FULL popup with all features)
                    map.on('click', 'route-stops-pins', (e) => {
                        const feature = e.features[0];
                        const coords = feature.geometry.coordinates.slice();
                        const props = feature.properties;

                        const sequencesArr = props.sequences ? props.sequences.split(', ') : [];
                        const ordersHtml = sequencesArr.map(seq =>
                            `<span class="route-popup-order">${seq}</span>`
                        ).join('');

                        // Check if there are multiple addresses in this stop
                        const addressSequencePairs = props.addressSequencePairs ? JSON.parse(props.addressSequencePairs) : [];
                        const hasMultipleAddresses = addressSequencePairs.length > 1;

                        // Build bairro and CEP info display
                        const bairroDisplay = props.bairro ? `<span style="font-size: 10px; color: #8b5cf6; font-weight: 500; padding: 2px 6px; background: rgba(139, 92, 246, 0.1); border-radius: 4px;">🏘️ ${props.bairro}</span>` : '';
                        const cepDisplay = props.zipcode ? `<span style="font-size: 10px; color: #0ea5e9; font-weight: 500; padding: 2px 6px; background: rgba(14, 165, 233, 0.1); border-radius: 4px;">📮 ${props.zipcode}</span>` : '';
                        const locationInfo = (bairroDisplay || cepDisplay) ? `<div style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 6px; margin-bottom: 8px;">${bairroDisplay}${cepDisplay}</div>` : '';

                        // Build address display with matched client address for similarity matches
                        let addressDisplay = '';

                        // Se for match por similaridade, mostrar endereço do cliente cadastrado acima (clicável para desativar similaridade)
                        const similarityHeader = (props.matchType === 'similarity' && props.matchedClientAddress)
                            ? `<div class="similarity-matched-address" data-ids="${props.ids}" style="font-size: 12px; font-weight: 600; color: #8b5cf6; margin-bottom: 4px; padding: 6px 8px; background: rgba(139, 92, 246, 0.1); border-radius: 6px; border-left: 3px solid #8b5cf6; cursor: pointer; transition: all 0.2s ease;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 0.2)'; this.style.borderLeftWidth='4px';"
                                    onmouseout="this.style.background='rgba(139, 92, 246, 0.1)'; this.style.borderLeftWidth='3px';">
                                   📍 ${props.matchedClientAddress}
                                   <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para usar coordenadas da planilha</div>
                               </div>
                               <div style="font-size: 10px; color: #64748b; margin-bottom: 8px; font-weight: 500;">
                                   ↓ Endereço da planilha:
                               </div>`
                            : '';

                        // Se for marcador vermelho que foi desativado, mostrar opção de reativar similaridade
                        const reactivateSimilarityHeader = (props.wasDeactivated === true || props.wasDeactivated === 'true') && props.originalMatchedClientAddress
                            ? `<div class="reactivate-similarity-address" data-ids="${props.ids}" style="font-size: 11px; font-weight: 600; color: #ef4444; margin-bottom: 8px; padding: 6px 8px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid #ef4444; cursor: pointer; transition: all 0.2s ease;"
                                    onmouseover="this.style.background='rgba(139, 92, 246, 0.15)'; this.style.borderLeftColor='#8b5cf6';"
                                    onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderLeftColor='#ef4444';">
                                   🔄 Voltar para: ${props.originalMatchedClientAddress}
                                   <div style="font-size: 9px; color: #7c3aed; margin-top: 3px; font-weight: 500;">🖱️ Clique para reativar similaridade</div>
                               </div>`
                            : '';

                        if (hasMultipleAddresses) {
                            addressDisplay = `
                                ${similarityHeader}
                                ${reactivateSimilarityHeader}
                                <div style="font-size: 11px; color: #8b5cf6; font-weight: 600; margin-bottom: 4px;">📦 ${addressSequencePairs.length} pacotes nesta parada:</div>
                                ${locationInfo}
                                <div style="font-size: 11px; line-height: 1.5; max-height: 120px; overflow-y: auto; margin-bottom: 8px;">
                                    ${addressSequencePairs.map(pair => `<div style="margin-bottom: 3px;"><span style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; padding: 2px 6px; border-radius: 4px; font-weight: 600; margin-right: 4px; font-size: 10px;">${pair.sequence}</span> ${pair.address}</div>`).join('')}
                                </div>
                            `;
                        } else if (addressSequencePairs.length === 1) {
                            addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${addressSequencePairs[0].address}</div>${locationInfo}`;
                        } else {
                            addressDisplay = `${similarityHeader}${reactivateSimilarityHeader}<div class="route-popup-address">${props.address}</div>${locationInfo}`;
                        }

                        // Determine current status for button styling
                        const currentStatus = props.deliveryStatus || 'pending';
                        const isDelivered = currentStatus === 'delivered';
                        const isNotDelivered = currentStatus === 'not_delivered';

                        closeRoutePopup();

                        // Only show order section at bottom if single address
                        const orderSection = hasMultipleAddresses ? '' : `
                            <div style="display: flex; align-items: center; gap: 6px; flex-wrap: wrap; margin-bottom: 6px;">
                                <span style="font-size: 11px; color: #64748b;">Ordem:</span>
                                <div class="route-popup-orders">${ordersHtml || '<span style="color: #94a3b8;">Sem ordem</span>'}</div>
                            </div>
                        `;

                        const isMobile = window.innerWidth <= 480;
                        const popupMaxWidth = isMobile ? '280px' : '320px';

                        routePopup = ResourceRegistry.registerPopup(new mapboxgl.Popup({
                            offset: [0, -50],
                            closeButton: true,
                            closeOnClick: true,
                            maxWidth: popupMaxWidth
                        })
                            .setLngLat(coords)
                            .setHTML(`
                                <div class="route-popup-content">
                                    ${addressDisplay}
                                    ${orderSection}
                                    <div class="route-popup-actions">
                                        <button class="route-popup-btn ${isDelivered ? 'active' : ''}" data-action="delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
                                            <span class="btn-text">${isDelivered ? 'Desfazer' : 'Entregue'}</span>
                                        </button>
                                        <button class="route-popup-btn not-delivered ${isNotDelivered ? 'active' : ''}" data-action="not_delivered" data-ids="${props.ids}" data-current-status="${currentStatus}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                                            <span class="btn-text">${isNotDelivered ? 'Desfazer' : 'Não entreg'}</span>
                                        </button>
                                        <button class="route-popup-btn navigate" data-lng="${coords[0]}" data-lat="${coords[1]}" data-address="${props.address}" data-order="${sequencesArr.join(', ') || '-'}" data-ids="${props.ids}">
                                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" /></svg>
                                            Navegar
                                        </button>
                                    </div>
                                </div>
                            `)
                            .addTo(map));

                        // Add click handlers for delivery buttons
                        const popupContentEl = routePopup.getElement();
                        popupContentEl.querySelectorAll('.route-popup-btn:not(.navigate)').forEach(btn => {
                            btn.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const action = btn.dataset.action;
                                const ids = btn.dataset.ids.split(',').map(id => parseInt(id));

                                let statusToSave = null;
                                if (btn.classList.contains('active')) {
                                    statusToSave = 'pending';
                                } else {
                                    statusToSave = action;
                                }

                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);
                                if (markerFeature) {
                                    markerFeature.properties.deliveryStatus = statusToSave;

                                    let newColor;
                                    if (statusToSave === 'delivered') {
                                        newColor = 'gray';
                                    } else if (statusToSave === 'not_delivered') {
                                        newColor = 'gray-x';
                                    } else if (props.isRegistered === true || props.isRegistered === 'true') {
                                        newColor = props.matchType === 'exact' ? 'green' : 'purple';
                                    } else {
                                        newColor = 'red';
                                    }

                                    const newIconName = `pin-${newColor}-${props.packageCount}`;
                                    markerFeature.properties.icon = newIconName;

                                    // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                    map.getSource('route-stops').setData(sourceData);
                                    updateRouteMarkersCache(sourceData);

                                    // Carrega ícone em background se não existir
                                    if (!map.hasImage(newIconName)) {
                                        const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                                        const img = new Image();
                                        img.onload = () => {
                                            if (!map.hasImage(newIconName)) {
                                                map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                            }
                                            // Re-renderiza para mostrar o ícone correto
                                            map.getSource('route-stops').setData(sourceData);
                                        };
                                        img.src = dataUrl;
                                    }
                                }

                                updateFixedStatsPanel();
                                updateDeliveryStatus(ids, statusToSave).catch(() => {});
                            });
                        });

                        // Add click handler for navigate button
                        const navBtn = popupContentEl.querySelector('.route-popup-btn.navigate');
                        if (navBtn) {
                            navBtn.addEventListener('click', (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();
                                const destLng = parseFloat(navBtn.dataset.lng);
                                const destLat = parseFloat(navBtn.dataset.lat);
                                const destAddress = navBtn.dataset.address;
                                const destOrder = navBtn.dataset.order || '-';
                                const destIds = navBtn.dataset.ids || '';
                                closeRoutePopup();
                                startNavigation(destLng, destLat, destAddress, destOrder, destIds);
                            });
                        }

                        // Add click handler for similarity matched address (desativar similaridade)
                        const similarityAddress = popupContentEl.querySelector('.similarity-matched-address');
                        if (similarityAddress) {
                            similarityAddress.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const ids = similarityAddress.dataset.ids.split(',').map(id => parseInt(id));
                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);

                                if (markerFeature) {
                                    // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                                    // porque props pode estar desatualizado após setData() de reativação
                                    const currentProps = markerFeature.properties;

                                    // Busca as coordenadas originais da planilha
                                    let originalLat = null;
                                    let originalLng = null;

                                    // Tenta buscar de window.currentRouteData primeiro
                                    if (window.currentRouteData) {
                                        const itemsForThisMarker = window.currentRouteData.filter(item =>
                                            ids.includes(item.id) && item.latitude && item.longitude
                                        );

                                        if (itemsForThisMarker.length > 0) {
                                            originalLat = itemsForThisMarker.reduce((sum, item) => sum + item.latitude, 0) / itemsForThisMarker.length;
                                            originalLng = itemsForThisMarker.reduce((sum, item) => sum + item.longitude, 0) / itemsForThisMarker.length;
                                        }
                                    }

                                    // Se não encontrou, busca do cache da planilha (para quando marcadores são carregados do cache)
                                    if (!originalLat || !originalLng) {
                                        try {
                                            const cachedPlanilha = await getAllFromOfflineDB('cachedPlanilha');
                                            if (cachedPlanilha && cachedPlanilha.length > 0) {
                                                const itemsForThisMarker = cachedPlanilha.filter(item =>
                                                    ids.includes(item.id) && item.latitude && item.longitude
                                                );

                                                if (itemsForThisMarker.length > 0) {
                                                    originalLat = itemsForThisMarker.reduce((sum, item) => sum + item.latitude, 0) / itemsForThisMarker.length;
                                                    originalLng = itemsForThisMarker.reduce((sum, item) => sum + item.longitude, 0) / itemsForThisMarker.length;
                                                }
                                            }
                                        } catch (e) {
                                            // Falha ao buscar do cache
                                        }
                                    }

                                    if (originalLat && originalLng) {
                                        markerFeature.properties.originalMatchType = currentProps.matchType;
                                        markerFeature.properties.originalMatchedClientAddress = currentProps.matchedClientAddress;
                                        markerFeature.properties.originalCoordinates = JSON.stringify(markerFeature.geometry.coordinates);

                                        markerFeature.properties.matchType = null;
                                        markerFeature.properties.isRegistered = false;
                                        markerFeature.properties.matchedClientAddress = '';
                                        markerFeature.properties.wasDeactivated = true;
                                        markerFeature.geometry.coordinates = [originalLng, originalLat];

                                        // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                                        const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                                        let newColor;
                                        if (currentDeliveryStatus === 'delivered') {
                                            newColor = 'gray';
                                        } else if (currentDeliveryStatus === 'not_delivered') {
                                            newColor = 'gray-x';
                                        } else {
                                            newColor = 'red'; // Não cadastrado (similaridade desativada)
                                        }
                                        const newIconName = `pin-${newColor}-${props.packageCount}`;
                                        markerFeature.properties.icon = newIconName;

                                        // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                        map.getSource('route-stops').setData(sourceData);
                                        updateRouteMarkersCache(sourceData);
                                        map.flyTo({ center: [originalLng, originalLat], zoom: 16, duration: 1500 });

                                        // Carrega ícone em background se não existir
                                        if (!map.hasImage(newIconName)) {
                                            const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                                            const img = new Image();
                                            img.onload = () => {
                                                if (!map.hasImage(newIconName)) {
                                                    map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                                }
                                                // Re-renderiza para mostrar o ícone correto
                                                map.getSource('route-stops').setData(sourceData);
                                            };
                                            img.src = dataUrl;
                                        }

                                        updateFixedStatsPanel();
                                        updateSimilarityOverride(ids, true, originalLat, originalLng).catch(() => {});
                                    }
                                }
                            });
                        }

                        // Add click handler for reactivate similarity address
                        const reactivateAddress = popupContentEl.querySelector('.reactivate-similarity-address');
                        if (reactivateAddress) {
                            reactivateAddress.addEventListener('click', async (evt) => {
                                evt.stopPropagation();
                                evt.preventDefault();

                                const ids = reactivateAddress.dataset.ids.split(',').map(id => parseInt(id));
                                closeRoutePopup();

                                // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                                lastRouteMarkersSave = Date.now();

                                const sourceData = map.getSource('route-stops')._data;
                                const markerFeature = sourceData.features.find(f => f.properties.ids === props.ids);

                                // IMPORTANTE: Busca dados atuais do feature, não usa props capturado
                                // porque props pode estar desatualizado após setData() de sincronização
                                const currentProps = markerFeature ? markerFeature.properties : null;

                                if (markerFeature && currentProps && currentProps.originalCoordinates) {
                                    const originalCoords = JSON.parse(currentProps.originalCoordinates);

                                    markerFeature.properties.matchType = currentProps.originalMatchType;
                                    markerFeature.properties.isRegistered = true;
                                    markerFeature.properties.matchedClientAddress = currentProps.originalMatchedClientAddress;
                                    markerFeature.properties.wasDeactivated = false;
                                    markerFeature.geometry.coordinates = originalCoords;

                                    markerFeature.properties.originalMatchType = null;
                                    markerFeature.properties.originalMatchedClientAddress = null;
                                    markerFeature.properties.originalCoordinates = null;

                                    // PRESERVAR STATUS DE ENTREGA: Verifica se já tem status de entrega definido
                                    const currentDeliveryStatus = currentProps.deliveryStatus || 'pending';
                                    let newColor;
                                    if (currentDeliveryStatus === 'delivered') {
                                        newColor = 'gray';
                                    } else if (currentDeliveryStatus === 'not_delivered') {
                                        newColor = 'gray-x';
                                    } else {
                                        newColor = 'purple'; // Similaridade reativada
                                    }
                                    const newIconName = `pin-${newColor}-${currentProps.packageCount}`;
                                    markerFeature.properties.icon = newIconName;

                                    // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                                    map.getSource('route-stops').setData(sourceData);
                                    updateRouteMarkersCache(sourceData);
                                    map.flyTo({ center: originalCoords, zoom: 16, duration: 1500 });

                                    // Carrega ícone em background se não existir
                                    if (!map.hasImage(newIconName)) {
                                        const { dataUrl, pixelRatio } = generatePinIcon(currentProps.packageCount, newColor);
                                        const img = new Image();
                                        img.onload = () => {
                                            if (!map.hasImage(newIconName)) {
                                                map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                            }
                                            // Re-renderiza para mostrar o ícone correto
                                            map.getSource('route-stops').setData(sourceData);
                                        };
                                        img.src = dataUrl;
                                    }

                                    updateFixedStatsPanel();
                                    updateSimilarityOverride(ids, false).catch(() => {});
                                }
                            });
                        }
                    });

                    // Change cursor on hover
                    map.on('mouseenter', 'route-stops-pins', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', 'route-stops-pins', () => {
                        map.getCanvas().style.cursor = '';
                    });
                }

                routeMarkersVisible = true;
                routeMarkersBtn.classList.add('active');

                // Update fixed stats panel with cached stats
                if (stats) {
                    updateFixedStatsPanel(stats);
                } else {
                    updateFixedStatsPanel();
                }

                // SYNC: Sincroniza status de entrega do Supabase em background
                // Isso garante que os status sejam atualizados entre dispositivos
                if (isOnline) {
                    syncDeliveryStatusFromSupabase().catch(() => {});
                }

                return true; // Successfully loaded from cache
            } catch (error) {
                return false; // Failed to load from cache
            }
        }

        routeMarkersBtn.addEventListener('click', () => {
            if (routeMarkersVisible) {
                removeRouteMarkers();
            } else {
                loadRouteMarkers();
            }
        });

        // ========================================
        // Spreadsheet Upload Functionality
        // ========================================
        const spreadsheetBtn = document.getElementById('spreadsheetBtn');
        const uploadModal = document.getElementById('uploadModal');
        const uploadModalClose = document.getElementById('uploadModalClose');
        const uploadDropzone = document.getElementById('uploadDropzone');
        const fileInput = document.getElementById('fileInput');
        const uploadPreview = document.getElementById('uploadPreview');
        const uploadProgress = document.getElementById('uploadProgress');
        const uploadSuccess = document.getElementById('uploadSuccess');
        const uploadCancel = document.getElementById('uploadCancel');
        const uploadConfirm = document.getElementById('uploadConfirm');
        const uploadModalFooter = document.getElementById('uploadModalFooter');
        let parsedData = [];

        // Open modal
        spreadsheetBtn.addEventListener('click', () => {
            resetUploadModal();
            uploadModal.classList.add('active');
        });

        // Close modal
        function closeUploadModal() {
            uploadModal.classList.remove('active');
            setTimeout(resetUploadModal, 300);
        }

        uploadModalClose.addEventListener('click', closeUploadModal);
        uploadCancel.addEventListener('click', closeUploadModal);

        uploadModal.addEventListener('click', (e) => {
            if (e.target === uploadModal) {
                closeUploadModal();
            }
        });

        // Reset modal state
        function resetUploadModal() {
            uploadDropzone.style.display = 'block';
            uploadPreview.classList.remove('active');
            uploadProgress.classList.remove('active');
            uploadSuccess.classList.remove('active');
            uploadModalFooter.style.display = 'flex';
            uploadConfirm.disabled = true;
            parsedData = [];
            fileInput.value = '';
        }

        // Drag and drop
        uploadDropzone.addEventListener('click', () => fileInput.click());

        uploadDropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadDropzone.classList.add('dragover');
        });

        uploadDropzone.addEventListener('dragleave', () => {
            uploadDropzone.classList.remove('dragover');
        });

        uploadDropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadDropzone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        // ============================================
        // Web Worker para parsing XLSX (Background Thread)
        // ============================================
        const xlsxWorkerCode = `
            // Web Worker para parsing de planilhas XLSX
            // Executa em thread separada para não bloquear a UI

            importScripts('https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js');

            // Helper functions para parsing seguro
            function parseIntSafe(val) {
                if (val === null || val === undefined || val === '' || val === '-') return null;
                const num = parseInt(val, 10);
                return isNaN(num) ? null : num;
            }

            function parseFloatSafe(val) {
                if (val === null || val === undefined || val === '' || val === '-') return null;
                const num = parseFloat(val);
                return isNaN(num) ? null : num;
            }

            function parseStringSafe(val) {
                if (val === null || val === undefined || val === '') return null;
                return String(val).trim();
            }

            self.onmessage = function(e) {
                try {
                    const arrayBuffer = e.data;

                    // Parse XLSX (operação pesada)
                    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    if (jsonData.length === 0) {
                        self.postMessage({ success: false, error: 'empty' });
                        return;
                    }

                    // Map column names to database fields
                    const parsedData = jsonData.map(row => ({
                        at_id: parseStringSafe(row['AT ID']),
                        sequence: parseIntSafe(row['Sequence']),
                        stop: parseIntSafe(row['Stop']),
                        spx_tn: parseStringSafe(row['SPX TN']),
                        destination_address: parseStringSafe(row['Destination Address']),
                        bairro: parseStringSafe(row['Bairro']),
                        city: parseStringSafe(row['City']),
                        zipcode: parseStringSafe(row['Zipcode/Postal code']),
                        latitude: parseFloatSafe(row['Latitude']),
                        longitude: parseFloatSafe(row['Longitude'])
                    }));

                    self.postMessage({ success: true, data: parsedData });
                } catch (error) {
                    self.postMessage({ success: false, error: 'parse_error', message: error.message });
                }
            };
        `;

        // Criar Blob URL para o Worker
        let xlsxWorkerUrl = null;
        let xlsxWorker = null;

        function getXlsxWorker() {
            if (!xlsxWorker && typeof Worker !== 'undefined') {
                try {
                    const blob = new Blob([xlsxWorkerCode], { type: 'application/javascript' });
                    xlsxWorkerUrl = URL.createObjectURL(blob);
                    xlsxWorker = new Worker(xlsxWorkerUrl);
                } catch (e) {
                    console.warn('Web Worker não suportado, usando fallback:', e);
                    return null;
                }
            }
            return xlsxWorker;
        }

        // Fallback: parsing na thread principal (para browsers sem suporte a Worker)
        function parseXlsxFallback(arrayBuffer) {
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet);

            if (jsonData.length === 0) {
                return { success: false, error: 'empty' };
            }

            const parseIntSafe = (val) => {
                if (val === null || val === undefined || val === '' || val === '-') return null;
                const num = parseInt(val, 10);
                return isNaN(num) ? null : num;
            };

            const parseFloatSafe = (val) => {
                if (val === null || val === undefined || val === '' || val === '-') return null;
                const num = parseFloat(val);
                return isNaN(num) ? null : num;
            };

            const parseStringSafe = (val) => {
                if (val === null || val === undefined || val === '') return null;
                return String(val).trim();
            };

            const parsedData = jsonData.map(row => ({
                at_id: parseStringSafe(row['AT ID']),
                sequence: parseIntSafe(row['Sequence']),
                stop: parseIntSafe(row['Stop']),
                spx_tn: parseStringSafe(row['SPX TN']),
                destination_address: parseStringSafe(row['Destination Address']),
                bairro: parseStringSafe(row['Bairro']),
                city: parseStringSafe(row['City']),
                zipcode: parseStringSafe(row['Zipcode/Postal code']),
                latitude: parseFloatSafe(row['Latitude']),
                longitude: parseFloatSafe(row['Longitude'])
            }));

            return { success: true, data: parsedData };
        }

        // Handle file com Web Worker
        async function handleFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/i)) {
                showErrorModal('Por favor, selecione um arquivo Excel (.xlsx ou .xls)');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const worker = getXlsxWorker();

                if (worker) {
                    // Usar Web Worker (não bloqueia UI)
                    const result = await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Worker timeout'));
                        }, 60000); // 60s timeout

                        worker.onmessage = (e) => {
                            clearTimeout(timeout);
                            resolve(e.data);
                        };

                        worker.onerror = (e) => {
                            clearTimeout(timeout);
                            reject(e);
                        };

                        worker.postMessage(arrayBuffer);
                    });

                    if (!result.success) {
                        if (result.error === 'empty') {
                            showErrorModal('A planilha está vazia ou não possui dados válidos.');
                        } else {
                            showErrorModal('Erro ao ler a planilha. Verifique se o arquivo está no formato correto.');
                        }
                        return;
                    }

                    parsedData = result.data;
                } else {
                    // Fallback para thread principal
                    const result = parseXlsxFallback(arrayBuffer);

                    if (!result.success) {
                        if (result.error === 'empty') {
                            showErrorModal('A planilha está vazia ou não possui dados válidos.');
                        } else {
                            showErrorModal('Erro ao ler a planilha. Verifique se o arquivo está no formato correto.');
                        }
                        return;
                    }

                    parsedData = result.data;
                }

                // Show preview
                showPreview(file.name, parsedData);

            } catch (error) {
                console.error('Erro no parsing XLSX:', error);
                showErrorModal('Erro ao ler a planilha. Verifique se o arquivo está no formato correto.');
            }
        }

        // Show preview
        function showPreview(fileName, data) {
            uploadDropzone.style.display = 'none';
            uploadPreview.classList.add('active');
            uploadConfirm.disabled = false;

            document.getElementById('fileName').textContent = fileName;
            document.getElementById('fileMeta').textContent = `${data.length} registros encontrados`;

            // Build preview table
            const previewHead = document.getElementById('previewHead');
            const previewBody = document.getElementById('previewBody');

            previewHead.innerHTML = '<tr><th>#</th><th>Endereço</th><th>Bairro</th><th>Lat</th><th>Lng</th></tr>';

            const previewRows = data.slice(0, 5).map((row, i) => {
                const addr = row.destination_address ? row.destination_address.substring(0, 30) + '...' : '-';
                const bairro = row.bairro || '-';
                const lat = row.latitude !== null ? row.latitude.toFixed(4) : '-';
                const lng = row.longitude !== null ? row.longitude.toFixed(4) : '-';
                return `
                <tr>
                    <td>${i + 1}</td>
                    <td>${addr}</td>
                    <td>${bairro}</td>
                    <td>${lat}</td>
                    <td>${lng}</td>
                </tr>`;
            }).join('');

            previewBody.innerHTML = previewRows;
            if (data.length > 5) {
                previewBody.innerHTML += `<tr><td colspan="5" style="text-align: center; color: var(--text-muted-light);">... e mais ${data.length - 5} registros</td></tr>`;
            }
        }

        // Upload confirm
        uploadConfirm.addEventListener('click', async () => {
            if (parsedData.length === 0) return;

            uploadPreview.classList.remove('active');
            uploadProgress.classList.add('active');
            uploadModalFooter.style.display = 'none';

            // Clear cached route markers (new planilha = new markers will be generated)
            try {
                await clearRouteMarkersCache();
                // Also clear from Supabase (cross-device sync)
                if (isOnline) {
                    clearRouteMarkersFromSupabase().catch(() => {});
                }
                // Also remove visible markers from map
                removeRouteMarkers();
            } catch (e) {
                // Silently fail - cache clear is not critical
            }

            // If offline, save locally
            if (!isOnline) {
                try {
                    document.getElementById('progressText').textContent = 'Salvando offline...';

                    // Save each record to IndexedDB
                    for (let i = 0; i < parsedData.length; i++) {
                        await saveToOfflineDB('pendingPlanilha', parsedData[i]);
                        document.getElementById('progressText').textContent = `Salvando offline... ${i + 1}/${parsedData.length}`;
                    }

                    // Also update cached planilha to include the new data
                    try {
                        const existingCache = await getAllFromOfflineDB('cachedPlanilha');
                        // Merge with existing cache, new data comes first
                        const mergedData = [...parsedData, ...existingCache];
                        await saveCacheToDB('cachedPlanilha', mergedData);
                    } catch (cacheErr) {
                        // Cache update failed, but pending data was saved
                    }

                    // Success
                    uploadProgress.classList.remove('active');
                    uploadSuccess.classList.add('active');
                    document.getElementById('successText').textContent = `${parsedData.length} registros salvos offline. Serão sincronizados quando a internet voltar.`;
                    updateOfflineIndicator();

                    // Auto close after 2 seconds
                    setTimeout(() => {
                        closeUploadModal();
                    }, 2000);

                } catch (offlineErr) {
                    uploadProgress.classList.remove('active');
                    uploadModalFooter.style.display = 'flex';
                    uploadPreview.classList.add('active');
                    showErrorModal('Erro ao salvar offline. Tente novamente.');
                }
                return;
            }

            // If online, try Supabase
            try {
                // Step 1: Delete all existing data
                document.getElementById('progressText').textContent = 'Removendo dados anteriores...';

                const { error: deleteError } = await db
                    .from('planilha')
                    .delete()
                    .neq('id', 0); // Delete all rows

                if (deleteError) throw deleteError;

                // Step 2: Insert new data in batches
                document.getElementById('progressText').textContent = 'Inserindo novos dados...';

                const batchSize = 50;
                let allInsertedData = [];
                for (let i = 0; i < parsedData.length; i += batchSize) {
                    const batch = parsedData.slice(i, i + batchSize);
                    const { data: insertedData, error: insertError } = await db
                        .from('planilha')
                        .insert(batch)
                        .select();

                    if (insertError) throw insertError;

                    if (insertedData) {
                        allInsertedData = allInsertedData.concat(insertedData);
                    }

                    document.getElementById('progressText').textContent = `Inserindo dados... ${Math.min(i + batchSize, parsedData.length)}/${parsedData.length}`;
                }

                // Step 3: Save to cache for offline use
                document.getElementById('progressText').textContent = 'Salvando cache local...';
                await saveCacheToDB('cachedPlanilha', allInsertedData.length > 0 ? allInsertedData : parsedData);

                // Success
                uploadProgress.classList.remove('active');
                uploadSuccess.classList.add('active');
                document.getElementById('successText').textContent = `${parsedData.length} registros foram salvos com sucesso.`;

                // Auto close after 2 seconds
                setTimeout(() => {
                    closeUploadModal();
                }, 2000);

            } catch (error) {
                try {
                    document.getElementById('progressText').textContent = 'Salvando offline...';

                    for (let i = 0; i < parsedData.length; i++) {
                        await saveToOfflineDB('pendingPlanilha', parsedData[i]);
                        document.getElementById('progressText').textContent = `Salvando offline... ${i + 1}/${parsedData.length}`;
                    }

                    uploadProgress.classList.remove('active');
                    uploadSuccess.classList.add('active');
                    document.getElementById('successText').textContent = `${parsedData.length} registros salvos offline. Serão sincronizados quando a internet voltar.`;
                    updateOfflineIndicator();

                    // Auto close after 2 seconds
                    setTimeout(() => {
                        closeUploadModal();
                    }, 2000);

                } catch (offlineErr) {
                    uploadProgress.classList.remove('active');
                    uploadModalFooter.style.display = 'flex';
                    uploadPreview.classList.add('active');
                    showErrorModal('Erro ao salvar os dados. Tente novamente.');
                }
            }
        });

        // ========================================
        // QR Scanner Functionality
        // ========================================
        const cadastrarBtn = document.getElementById('cadastrarBtn');
        const qrModal = document.getElementById('qrModal');
        const qrModalClose = document.getElementById('qrModalClose');
        const qrVideo = document.getElementById('qrVideo');
        const qrCanvas = document.getElementById('qrCanvas');
        const qrCanvasContext = qrCanvas.getContext('2d', { willReadFrequently: true });
        const qrLoading = document.getElementById('qrLoading');
        const qrStatusText = document.getElementById('qrStatusText');
        const qrAddressList = document.getElementById('qrAddressList');

        let qrStream = null;
        let qrAnimationFrame = null;
        let torchEnabled = false;
        let torchTrack = null; // Track da câmera para controle da lanterna
        let torchSupported = false; // Se o dispositivo suporta lanterna
        let lastBrightnessCheck = 0; // Timestamp da última verificação de luminosidade
        const BRIGHTNESS_CHECK_INTERVAL = 500; // Verificar a cada 500ms
        const DARK_THRESHOLD = 50; // Limiar de escuridão (0-255, menor = mais escuro)

        // Open QR Scanner
        cadastrarBtn.addEventListener('click', () => {
            openQrScanner();
        });

        // Close QR Scanner
        qrModalClose.addEventListener('click', closeQrScanner);

        qrModal.addEventListener('click', (e) => {
            if (e.target === qrModal) {
                closeQrScanner();
            }
        });

        async function openQrScanner() {
            qrModal.classList.add('active');
            qrLoading.classList.add('active');
            qrStatusText.textContent = 'Iniciando câmera...';

            // Reset torch state
            torchEnabled = false;
            torchTrack = null;
            torchSupported = false;
            lastBrightnessCheck = 0;

            // Reset selected address
            selectedAddressIdx = null;

            // Load addresses for manual selection
            loadPlanilhaAddresses();

            try {
                qrStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                qrVideo.srcObject = qrStream;
                await qrVideo.play();

                // Check if torch/flashlight is supported
                const videoTrack = qrStream.getVideoTracks()[0];
                if (videoTrack) {
                    torchTrack = videoTrack;
                    try {
                        const capabilities = videoTrack.getCapabilities();
                        if (capabilities && capabilities.torch) {
                            torchSupported = true;
                        }
                    } catch (e) {
                        // getCapabilities not supported
                    }
                }

                qrLoading.classList.remove('active');
                qrStatusText.textContent = 'Posicione o QR Code dentro da área';

                startScanning();

            } catch (error) {
                qrLoading.classList.remove('active');
                qrStatusText.textContent = 'Erro ao acessar a câmera';
                showErrorModal('Não foi possível acessar a câmera. Verifique as permissões do navegador.');
            }
        }

        // Turn on torch with flash protection
        const qrTorchFlash = document.getElementById('qrTorchFlash');

        async function turnOnTorch() {
            if (!torchTrack || !torchSupported || torchEnabled) return;

            try {
                // Show black overlay BEFORE turning on torch
                // This hides the bright flash while camera adjusts exposure
                if (qrTorchFlash) {
                    qrTorchFlash.classList.add('active');
                }

                // Turn on torch
                await torchTrack.applyConstraints({
                    advanced: [{ torch: true }]
                });
                torchEnabled = true;

                // Wait for camera to adjust exposure, then fade out overlay
                setTimeout(() => {
                    if (qrTorchFlash) {
                        qrTorchFlash.classList.remove('active');
                    }
                }, 300); // 300ms for camera adjustment

            } catch (e) {
                // Failed to turn on torch - remove overlay
                if (qrTorchFlash) {
                    qrTorchFlash.classList.remove('active');
                }
            }
        }

        // Turn off torch
        async function turnOffTorch() {
            if (!torchTrack || !torchEnabled) return;

            try {
                await torchTrack.applyConstraints({
                    advanced: [{ torch: false }]
                });
                torchEnabled = false;
            } catch (e) {
                // Failed to turn off torch
            }
        }

        // Calculate average brightness from image data (0-255)
        function calculateBrightness(imageData) {
            const data = imageData.data;
            let totalBrightness = 0;
            const pixelCount = data.length / 4;

            // Sample every 10th pixel for performance
            for (let i = 0; i < data.length; i += 40) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                // Luminance formula (perceived brightness)
                totalBrightness += (0.299 * r + 0.587 * g + 0.114 * b);
            }

            return totalBrightness / (pixelCount / 10);
        }

        // Check brightness and auto-enable torch
        // IMPORTANTE: Só LIGA automaticamente, nunca desliga
        // Uma vez ligada, fica ligada até ler QR ou fechar o modal
        function checkBrightnessAndToggleTorch(imageData) {
            // Se já ligou ou não suporta, não verifica mais
            if (!torchSupported || torchEnabled) return;

            const now = Date.now();
            if (now - lastBrightnessCheck < BRIGHTNESS_CHECK_INTERVAL) return;
            lastBrightnessCheck = now;

            const brightness = calculateBrightness(imageData);

            // Ambiente escuro - ligar lanterna (e manter ligada)
            if (brightness < DARK_THRESHOLD) {
                turnOnTorch();
            }
        }

        // Função para normalizar endereços para comparação (versão local para o modal)
        function normalizeAddressForComparison(addr) {
            if (!addr) return '';
            return addr
                .toLowerCase()
                .trim()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove acentos
                .replace(/[.,;:\-\/\\()]/g, ' ') // Substitui pontuação por espaço
                .replace(/\s+/g, ' ') // Múltiplos espaços para um único
                .trim();
        }

        // ============================================
        // FAST CLIENT LOOKUP - Cache-first com timeout
        // ============================================
        // Otimização para evitar lentidão quando internet está instável
        // Estratégia: verifica cache local primeiro (instantâneo), depois online com timeout

        async function findExistingClientFast(addressToCheck, options = {}) {
            const {
                onlineTimeout = 3000,  // Timeout de 3s para busca online
                skipOnline = false     // Pular busca online (força uso do cache)
            } = options;

            if (!addressToCheck) return null;

            const normalizedAddressToCheck = normalizeAddressForComparison(addressToCheck);
            let existingClient = null;

            // PASSO 1: Verifica cache local PRIMEIRO (instantâneo)
            try {
                // Check in pending clients (offline data waiting to sync)
                const pendingClients = await getAllFromOfflineDB('pendingClients');
                existingClient = pendingClients.find(client => {
                    const normalizedClientAddr = normalizeAddressForComparison(client.address);
                    return normalizedClientAddr === normalizedAddressToCheck;
                });

                // If not found in pending, check in cached clients
                if (!existingClient) {
                    const cachedClients = await getAllFromOfflineDB('cachedClients');
                    existingClient = cachedClients.find(client => {
                        const normalizedClientAddr = normalizeAddressForComparison(client.address);
                        return normalizedClientAddr === normalizedAddressToCheck;
                    });
                }

                // Fallback: Verifica em cachedRouteMarkers se o endereço está marcado como registrado
                if (!existingClient) {
                    try {
                        const cachedMarkers = await getCachedRouteMarkers();
                        if (cachedMarkers && cachedMarkers.geojson && cachedMarkers.geojson.features) {
                            for (const feature of cachedMarkers.geojson.features) {
                                const props = feature.properties;

                                // Verifica se está marcado como registrado (exato, não similaridade)
                                const isExactMatch = (props.isRegistered === true || props.isRegistered === 'true') &&
                                                     props.matchType === 'exact';

                                if (!isExactMatch) continue;

                                // Extrai endereços do marcador
                                const addresses = props.allAddresses ?
                                    (typeof props.allAddresses === 'string' ? props.allAddresses.split('|||') : props.allAddresses) :
                                    [props.address];

                                // Verifica se algum endereço corresponde
                                const normalizedAddresses = addresses.map(a => normalizeAddressForComparison(a));
                                if (normalizedAddresses.includes(normalizedAddressToCheck)) {
                                    // Retorna como cliente existente
                                    existingClient = {
                                        address: addresses[0] || props.address,
                                        latitude: feature.geometry.coordinates[1],
                                        longitude: feature.geometry.coordinates[0],
                                        bairro: props.bairro || '',
                                        zipcode: props.zipcode || ''
                                    };
                                    break;
                                }
                            }
                        }
                    } catch (e) {}
                }
            } catch (err) {
                // Erro no cache local - continua sem resultado
            }

            // Se encontrou no cache, retorna imediatamente (sem esperar online)
            if (existingClient) {
                return existingClient;
            }

            // PASSO 2: Se não encontrou no cache e está online, tenta busca online COM TIMEOUT
            if (isOnline && !skipOnline) {
                try {
                    // Cria promise com timeout
                    const onlineSearchPromise = (async () => {
                        let clientFrom = 0;
                        const clientPageSize = 1000;
                        let hasMoreClient = true;

                        while (hasMoreClient) {
                            const { data: clientPage, error: clientPageError } = await db
                                .from('clients')
                                .select('id, address, latitude, longitude, bairro, city, zipcode')
                                .not('address', 'is', null)
                                .range(clientFrom, clientFrom + clientPageSize - 1);

                            if (clientPageError) {
                                break;
                            }

                            if (clientPage && clientPage.length > 0) {
                                // Busca match na página atual
                                const foundClient = clientPage.find(client => {
                                    const normalizedClientAddr = normalizeAddressForComparison(client.address);
                                    return normalizedClientAddr === normalizedAddressToCheck;
                                });

                                if (foundClient) {
                                    return foundClient;
                                }

                                clientFrom += clientPageSize;
                                if (clientPage.length < clientPageSize) {
                                    hasMoreClient = false;
                                }
                            } else {
                                hasMoreClient = false;
                            }
                        }
                        return null;
                    })();

                    // Timeout promise
                    const timeoutPromise = new Promise((resolve) => {
                        setTimeout(() => resolve(null), onlineTimeout);
                    });

                    // Race: retorna o primeiro que completar
                    existingClient = await Promise.race([onlineSearchPromise, timeoutPromise]);

                } catch (err) {
                    // Falha na busca online - retorna null (assume novo endereço)
                }
            }

            return existingClient;
        }

        // Extrai componentes básicos do endereço (rua principal + número)
        // Versão simplificada para uso em updateRouteMarkerForNewClient
        // Permite match semântico: "Rua X, 510" = "Rua X, 510, Em frente ao HGM"
        function extractAddressComponentsSimple(addr) {
            if (!addr) return { primary: '', number: '' };

            // Normaliza o endereço
            let normalized = addr
                .toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .trim();

            // Remove referências (tudo após padrões de referência)
            const referencePatterns = [
                /\b(proximo|prox\.?|px\.?)\b/i,
                /\b(ao lado|em frente|atras|entre|perto)\b/i,
                /\b(fundos|frente|esquina|esq\.?)\b/i,
                /\b(referencia|ref\.?|descendo|subindo)\b/i
            ];

            for (const pattern of referencePatterns) {
                const match = normalized.match(pattern);
                if (match) {
                    normalized = normalized.substring(0, match.index).trim();
                }
            }

            // Extrai número da casa
            // Padrões: ", 510", " 510," , " 510 ", ", 510A", etc.
            const numberMatch = normalized.match(/[,\s](\d+[a-zA-Z]?)\s*[,\s]?/);
            const number = numberMatch ? numberMatch[1] : '';

            // Extrai rua principal (primeiro tipo de logradouro encontrado)
            const streetTypes = [
                /\b(rua|r\.?)\s+([^,]+)/i,
                /\b(avenida|av\.?)\s+([^,]+)/i,
                /\b(alameda|al\.?)\s+([^,]+)/i,
                /\b(travessa|tv\.?|trav\.?)\s+([^,]+)/i,
                /\b(passagem|pass\.?)\s+([^,]+)/i,
                /\b(rodovia|rod\.?)\s+([^,]+)/i,
                /\b(estrada|est\.?)\s+([^,]+)/i,
                /\b(praca|pca\.?)\s+([^,]+)/i
            ];

            let primary = '';
            for (const pattern of streetTypes) {
                const match = normalized.match(pattern);
                if (match) {
                    // Pega o nome da rua até o primeiro número ou vírgula
                    let streetName = match[2].split(/[,\d]/)[0].trim();
                    // Remove pontuação do final
                    streetName = streetName.replace(/[.,;:\-\/\\()]+$/, '').trim();
                    primary = streetName;
                    break;
                }
            }

            return { primary, number };
        }

        // Load addresses from planilha for manual selection
        // Only shows addresses that are NOT yet registered as clients
        // ============================================
        // CACHE-FIRST STRATEGY - Modal de Cadastro Rápido
        // ============================================
        // Usa cache local primeiro (rápido), busca online só se cache vazio
        // Isso garante velocidade E dados corretos

        async function loadPlanilhaAddresses() {
            qrAddressList.innerHTML = '<div class="qr-address-list-empty">Carregando...</div>';

            try {
                // ============================================
                // ESTRATÉGIA OTIMIZADA: Usa cachedRouteMarkers
                // ============================================
                // O cálculo de isRegistered já foi feito quando clicou em "Paradas da Rota"
                // Reutiliza esses dados ao invés de recalcular!

                const cachedMarkers = await getCachedRouteMarkers();

                if (cachedMarkers && cachedMarkers.geojson && cachedMarkers.geojson.features) {
                    // FAST PATH: Usa dados pré-calculados dos marcadores
                    const features = cachedMarkers.geojson.features;

                    // Filtra endereços que PRECISAM ser cadastrados:
                    // - Vermelhos: isRegistered === false (não cadastrado)
                    // - Roxos: isRegistered === true + matchType === 'similarity' (match por similaridade, não exato)
                    // NÃO inclui:
                    // - Verdes: isRegistered === true + matchType === 'exact' (já cadastrado exatamente)
                    // - Finalizados: deliveryStatus === 'delivered' ou 'not_delivered'
                    const unregisteredAddresses = features
                        .filter(f => {
                            const props = f.properties;

                            // Não finalizado
                            const isNotDelivered = props.deliveryStatus !== 'delivered' && props.deliveryStatus !== 'not_delivered';
                            if (!isNotDelivered) return false;

                            // Verifica se NÃO está cadastrado (vermelho)
                            const isNotRegistered = props.isRegistered === false || props.isRegistered === 'false' ||
                                                    props.isRegistered === undefined || props.isRegistered === null;

                            // Verifica se é match por similaridade (roxo) - precisa cadastrar endereço exato
                            const isSimilarityMatch = (props.isRegistered === true || props.isRegistered === 'true') &&
                                                      props.matchType === 'similarity';

                            return isNotRegistered || isSimilarityMatch;
                        })
                        .map(f => {
                            const props = f.properties;

                            // allAddresses é armazenado como string 'addr1|||addr2|||addr3'
                            let addresses = [];
                            if (props.allAddresses) {
                                if (typeof props.allAddresses === 'string') {
                                    addresses = props.allAddresses.split('|||').filter(Boolean);
                                } else if (Array.isArray(props.allAddresses)) {
                                    addresses = props.allAddresses;
                                }
                            }

                            // Primeiro endereço do grupo (ou address principal)
                            const firstAddr = addresses[0] || props.address || '';

                            // sequences é armazenado como string '1, 2, 3'
                            let sequences = [];
                            if (props.sequences) {
                                if (typeof props.sequences === 'string') {
                                    sequences = props.sequences.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
                                } else if (Array.isArray(props.sequences)) {
                                    sequences = props.sequences;
                                }
                            }
                            const firstSeq = sequences[0] || 0;

                            return {
                                id: props.ids ? props.ids.split(',')[0] : props.id,
                                sequence: firstSeq,
                                destination_address: firstAddr,
                                bairro: props.bairro || '',
                                city: props.city || '',
                                zipcode: props.zipcode || '',
                                latitude: f.geometry.coordinates[1],
                                longitude: f.geometry.coordinates[0],
                                // Dados extras para grupos
                                allAddresses: addresses,
                                allSequences: sequences,
                                allIds: props.ids
                            };
                        })
                        .filter(addr => addr.destination_address) // Remove entradas sem endereço
                        .sort((a, b) => (a.sequence || 0) - (b.sequence || 0));

                    // Também inclui pendingClients recém-cadastrados que não estão no mapa ainda
                    // Esses precisam ser removidos da lista
                    let pendingAddresses = [];
                    try {
                        const pendingClients = await getAllFromOfflineDB('pendingClients');
                        if (pendingClients && pendingClients.length > 0) {
                            pendingAddresses = pendingClients
                                .map(c => normalizeAddressForComparison(c.address))
                                .filter(Boolean);
                        }
                    } catch (e) {}

                    // Remove endereços que foram cadastrados depois que o mapa foi gerado
                    const finalAddresses = unregisteredAddresses.filter(addr => {
                        if (!addr.destination_address) return false;
                        const normalized = normalizeAddressForComparison(addr.destination_address);
                        return !pendingAddresses.includes(normalized);
                    });

                    if (finalAddresses.length === 0) {
                        qrAddressList.innerHTML = '<div class="qr-address-list-empty">Todos os endereços já foram cadastrados! 🎉</div>';
                    } else {
                        planilhaAddressData = finalAddresses;
                        renderAddressList(finalAddresses);
                    }
                    return;
                }

                // ============================================
                // FALLBACK: Se cachedRouteMarkers não existe
                // ============================================
                // Isso acontece se o usuário não clicou em "Paradas da Rota" ainda
                // Usa o método antigo como fallback

                let addressData = [];
                let registeredClientsRaw = [];

                // Carrega do cache (instantâneo)
                try {
                    const cachedClients = await getAllFromOfflineDB('cachedClients');
                    if (cachedClients && cachedClients.length > 0) {
                        registeredClientsRaw = cachedClients.map(c => c.address).filter(Boolean);
                    }
                } catch (e) {}

                // Inclui pendingClients
                try {
                    const pendingClients = await getAllFromOfflineDB('pendingClients');
                    if (pendingClients && pendingClients.length > 0) {
                        pendingClients.forEach(c => {
                            if (c.address && !registeredClientsRaw.includes(c.address)) {
                                registeredClientsRaw.push(c.address);
                            }
                        });
                    }
                } catch (e) {}

                // Carrega planilha do cache
                try {
                    const cachedData = await getAllFromOfflineDB('cachedPlanilha');
                    if (cachedData && cachedData.length > 0) {
                        addressData = cachedData;
                    }
                } catch (e) {}

                // Fallback para pendingPlanilha
                if (addressData.length === 0) {
                    try {
                        const offlineData = await getAllFromOfflineDB('pendingPlanilha');
                        if (offlineData && offlineData.length > 0) {
                            addressData = offlineData
                                .filter(item => item.destination_address)
                                .map(item => ({
                                    localId: item.localId,
                                    sequence: item.sequence,
                                    destination_address: item.destination_address,
                                    bairro: item.bairro,
                                    city: item.city,
                                    zipcode: item.zipcode,
                                    latitude: item.latitude,
                                    longitude: item.longitude,
                                    spx_tn: item.spx_tn
                                }))
                                .sort((a, b) => (a.sequence || 0) - (b.sequence || 0));
                        }
                    } catch (e) {}
                }

                // Renderiza com filtragem
                if (addressData.length > 0) {
                    const registeredClientsNormalized = registeredClientsRaw
                        .filter(addr => addr)
                        .map(addr => normalizeAddressForComparison(addr));

                    const unregisteredAddresses = addressData.filter(addr => {
                        if (!addr.destination_address) return false;
                        const normalizedPlanilhaAddr = normalizeAddressForComparison(addr.destination_address);
                        return !registeredClientsNormalized.some(registeredAddr =>
                            registeredAddr === normalizedPlanilhaAddr
                        );
                    });

                    if (unregisteredAddresses.length === 0) {
                        qrAddressList.innerHTML = '<div class="qr-address-list-empty">Todos os endereços já foram cadastrados! 🎉</div>';
                    } else {
                        planilhaAddressData = unregisteredAddresses;
                        renderAddressList(unregisteredAddresses);
                    }
                } else {
                    qrAddressList.innerHTML = '<div class="qr-address-list-empty">Nenhum endereço na planilha. Clique em "Paradas da Rota" primeiro.</div>';
                }

            } catch (error) {
                qrAddressList.innerHTML = '<div class="qr-address-list-empty">Erro ao carregar</div>';
            }
        }

        // Virtualized list - only renders visible items (QR Address List)
        let planilhaAddressData = [];
        const QR_ITEM_HEIGHT = 52;
        const QR_BUFFER_ITEMS = 2;
        let virtualViewport = null;
        let selectedAddressIdx = null; // Track selected address index

        function renderAddressList(addresses) {
            if (addresses.length === 0) {
                qrAddressList.innerHTML = '<div class="qr-address-list-empty">Nenhum endereço encontrado</div>';
                return;
            }

            const totalHeight = addresses.length * QR_ITEM_HEIGHT;
            qrAddressList.innerHTML = `<div class="qr-address-viewport" style="height:${totalHeight}px"></div>`;
            virtualViewport = qrAddressList.querySelector('.qr-address-viewport');

            renderQRVisibleItems();
            // THROTTLE: Limita scroll a 60fps (16ms) para performance
            qrAddressList.addEventListener('scroll', throttledVirtualScroll, { passive: true });
        }

        // THROTTLE: Scroll otimizado com requestAnimationFrame + throttle
        // Combina RAF para sincronização com display + throttle para limitar chamadas
        const throttledVirtualScroll = throttle(() => {
            requestAnimationFrame(renderQRVisibleItems);
        }, 16); // ~60fps

        function renderQRVisibleItems() {
            if (!virtualViewport || !planilhaAddressData.length) return;

            const scrollTop = qrAddressList.scrollTop;
            const containerHeight = qrAddressList.clientHeight;

            const startIdx = Math.max(0, Math.floor(scrollTop / QR_ITEM_HEIGHT) - QR_BUFFER_ITEMS);
            const endIdx = Math.min(planilhaAddressData.length - 1, Math.ceil((scrollTop + containerHeight) / QR_ITEM_HEIGHT) + QR_BUFFER_ITEMS);

            let html = '';
            for (let i = startIdx; i <= endIdx; i++) {
                const addr = planilhaAddressData[i];
                const top = i * QR_ITEM_HEIGHT;
                const isSelected = selectedAddressIdx === i ? ' selected' : '';
                html += `<div class="qr-address-item${isSelected}" data-idx="${i}" style="top:${top}px"><div class="qr-address-text"><p>${addr.destination_address || 'Endereço não disponível'}</p><span>${addr.bairro || ''}${addr.city ? ' - ' + addr.city : ''}</span></div><div class="qr-address-order">${addr.sequence || '-'}</div></div>`;
            }
            virtualViewport.innerHTML = html;
        }

        // Handle address item click
        qrAddressList.addEventListener('click', async (e) => {
            const item = e.target.closest('.qr-address-item');
            if (!item || item.dataset.idx === undefined) return;

            const idx = parseInt(item.dataset.idx);
            const addr = planilhaAddressData[idx];
            if (!addr) return;

            // Mark item as selected visually
            selectedAddressIdx = idx;
            renderQRVisibleItems();

            currentRecord = {
                id: addr.id,
                destination_address: addr.destination_address,
                bairro: addr.bairro,
                city: addr.city,
                zipcode: addr.zipcode,
                latitude: addr.latitude || null,
                longitude: addr.longitude || null,
                sequence: addr.sequence
            };

            const addressToCheck = currentRecord.destination_address;

            // OTIMIZADO: Usa APENAS cache local (skipOnline = true)
            // A lista já foi filtrada com dados do cache, então não precisa buscar online
            // Isso garante resposta instantânea ao clicar
            const existingClient = await findExistingClientFast(addressToCheck, {
                skipOnline: true  // Pula busca online - usa só cache
            });

            // If address already registered, show modal
            if (existingClient) {
                closeQrScanner();
                showAddressExistsModal(addressToCheck, existingClient);
            } else {
                // Go directly to adjust mode (new address)
                enterAdjustMode();
            }
        });

        function closeQrScanner() {
            qrModal.classList.remove('active');

            // Turn off torch before closing
            turnOffTorch();

            // Stop scanning
            if (qrAnimationFrame) {
                cancelAnimationFrame(qrAnimationFrame);
                qrAnimationFrame = null;
            }

            // Stop camera
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }

            // Reset torch state
            torchTrack = null;
            torchSupported = false;

            qrVideo.srcObject = null;
        }

        function startScanning() {
            if (!qrStream) return;

            function tick() {
                if (!qrModal.classList.contains('active')) return;

                if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                    // Solução 1: Reduzir resolução de processamento (640x480)
                    const processWidth = 640;
                    const processHeight = Math.floor((qrVideo.videoHeight / qrVideo.videoWidth) * processWidth);

                    qrCanvas.width = processWidth;
                    qrCanvas.height = processHeight;

                    qrCanvasContext.drawImage(qrVideo, 0, 0, processWidth, processHeight);

                    // Solução 2: Limitar área de leitura (ROI - Region of Interest)
                    const scanSize = 300;
                    const centerX = Math.floor(processWidth / 2);
                    const centerY = Math.floor(processHeight / 2);
                    const startX = Math.max(0, centerX - Math.floor(scanSize / 2));
                    const startY = Math.max(0, centerY - Math.floor(scanSize / 2));
                    const actualWidth = Math.min(scanSize, processWidth - startX);
                    const actualHeight = Math.min(scanSize, processHeight - startY);

                    // Captura apenas o centro da imagem
                    const imageData = qrCanvasContext.getImageData(startX, startY, actualWidth, actualHeight);

                    // Auto-detect dark environment and toggle torch
                    checkBrightnessAndToggleTorch(imageData);

                    // Solução 3: Permitir leitura invertida (attemptBoth)
                    const code = jsQR(imageData.data, actualWidth, actualHeight, {
                        inversionAttempts: 'attemptBoth'
                    });

                    if (code && code.data) {
                        searchAndShowResult(code.data);
                        return;
                    }
                }

                qrAnimationFrame = requestAnimationFrame(tick);
            }

            qrAnimationFrame = requestAnimationFrame(tick);
        }

        // Store current record for navigation
        let currentRecord = null;

        // Search in database and show result with address
        // OTIMIZADO: Cache-first - busca no cache local primeiro (instantâneo)
        async function searchAndShowResult(qrData) {
            // Show loading
            qrLoading.classList.add('active');
            document.querySelector('.qr-loading-text').textContent = 'Buscando endereço...';

            let foundRecord = null;

            try {
                // ============================================
                // CACHE-FIRST: Busca no cache LOCAL primeiro
                // ============================================

                // 1. Tenta buscar pelo índice spx_tn (mais rápido)
                try {
                    foundRecord = await getFromCacheByIndex('cachedPlanilha', 'spx_tn', qrData);
                } catch (err) {}

                // 2. Se não encontrou, busca manual no cachedPlanilha
                if (!foundRecord) {
                    try {
                        const cachedData = await getAllFromOfflineDB('cachedPlanilha');
                        if (cachedData && cachedData.length > 0) {
                            foundRecord = cachedData.find(item =>
                                item.spx_tn && item.spx_tn.toString() === qrData.toString()
                            );
                        }
                    } catch (err) {}
                }

                // 3. Tenta também em pendingPlanilha
                if (!foundRecord) {
                    try {
                        const offlineData = await getAllFromOfflineDB('pendingPlanilha');
                        if (offlineData && offlineData.length > 0) {
                            foundRecord = offlineData.find(item =>
                                item.spx_tn && item.spx_tn.toString() === qrData.toString()
                            );
                        }
                    } catch (err) {}
                }

                // 4. Fallback: Busca em cachedRouteMarkers (dados podem estar só lá)
                if (!foundRecord) {
                    try {
                        const cachedMarkers = await getCachedRouteMarkers();
                        if (cachedMarkers && cachedMarkers.geojson && cachedMarkers.geojson.features) {
                            // Procura pelo spx_tn nos ids dos marcadores
                            for (const feature of cachedMarkers.geojson.features) {
                                const props = feature.properties;
                                const ids = props.ids ? props.ids.split(',') : [];

                                // Verifica se o QR code corresponde a algum ID
                                if (ids.some(id => id.trim() === qrData.toString())) {
                                    // Extrai dados do marcador
                                    const addresses = props.allAddresses ?
                                        (typeof props.allAddresses === 'string' ? props.allAddresses.split('|||') : props.allAddresses) :
                                        [props.address];
                                    const sequences = props.sequences ?
                                        (typeof props.sequences === 'string' ? props.sequences.split(',').map(s => parseInt(s.trim())) : props.sequences) :
                                        [];

                                    // Encontra o índice correspondente ao ID
                                    const idIndex = ids.findIndex(id => id.trim() === qrData.toString());

                                    foundRecord = {
                                        id: qrData,
                                        spx_tn: qrData,
                                        destination_address: addresses[idIndex] || addresses[0] || props.address,
                                        sequence: sequences[idIndex] || sequences[0],
                                        bairro: props.bairro || '',
                                        city: props.city || '',
                                        zipcode: props.zipcode || '',
                                        latitude: feature.geometry.coordinates[1],
                                        longitude: feature.geometry.coordinates[0]
                                    };
                                    break;
                                }
                            }
                        }
                    } catch (err) {}
                }

                // ============================================
                // Se encontrou no cache, processa imediatamente
                // ============================================
                if (foundRecord) {
                    playQrBeep(); // Som de confirmação de leitura
                    turnOffTorch(); // Desliga lanterna após leitura
                    qrLoading.classList.remove('active');
                    currentRecord = foundRecord;
                    const addressToCheck = foundRecord.destination_address;

                    // Usa APENAS cache local para verificar se já está cadastrado
                    const existingClient = await findExistingClientFast(addressToCheck, {
                        skipOnline: true  // Pula busca online - resposta instantânea
                    });

                    if (existingClient) {
                        closeQrScanner();
                        showAddressExistsModal(addressToCheck, existingClient);
                    } else {
                        enterAdjustMode();
                    }
                    return;
                }

                // ============================================
                // Se não encontrou no cache e está online, tenta Supabase
                // ============================================
                if (isOnline && !foundRecord) {
                    try {
                        const { data, error } = await db
                            .from('planilha')
                            .select('*')
                            .eq('spx_tn', qrData)
                            .limit(1);

                        if (!error && data && data.length > 0) {
                            foundRecord = data[0];
                        }
                    } catch (supabaseError) {}
                }

                qrLoading.classList.remove('active');

                if (foundRecord) {
                    playQrBeep(); // Som de confirmação de leitura
                    turnOffTorch(); // Desliga lanterna após leitura
                    currentRecord = foundRecord;
                    const addressToCheck = foundRecord.destination_address;

                    // Usa cache local para verificar (skipOnline)
                    const existingClient = await findExistingClientFast(addressToCheck, {
                        skipOnline: true
                    });

                    if (existingClient) {
                        closeQrScanner();
                        showAddressExistsModal(addressToCheck, existingClient);
                    } else {
                        enterAdjustMode();
                    }
                } else {
                    // Code not found
                    currentRecord = null;
                    qrStatusText.textContent = 'Código não encontrado';
                    setTimeout(() => {
                        if (qrModal.classList.contains('active')) {
                            qrStatusText.textContent = 'Aponte para o QR Code';
                            startScanning();
                        }
                    }, 2000);
                }

            } catch (error) {
                qrLoading.classList.remove('active');
                currentRecord = null;
                qrStatusText.textContent = 'Erro na busca';
                setTimeout(() => {
                    if (qrModal.classList.contains('active')) {
                        qrStatusText.textContent = 'Aponte para o QR Code';
                        startScanning();
                    }
                }, 2000);
            }
        }

        // ========================================
        // Adjust Location & Save Functionality
        // ========================================
        const adjustModeBar = document.getElementById('adjustModeBar');
        const adjustModeAddress = document.getElementById('adjustModeAddress');
        const adjustModeCancel = document.getElementById('adjustModeCancel');
        const adjustModeConfirm = document.getElementById('adjustModeConfirm');

        let adjustedCoordinates = null;
        let isAdjustMode = false;
        let isMapAnimating = false; // Flag para detectar se o mapa está em animação
        const centerPin = document.getElementById('centerPin');

        // Posiciona o pino no centro exato do container do mapa
        function positionCenterPin() {
            const mapContainer = document.getElementById('map');
            if (!mapContainer || !centerPin) return;

            const rect = mapContainer.getBoundingClientRect();
            // Centro do container do mapa em relação ao próprio container
            centerPin.style.left = (rect.width / 2) + 'px';
            centerPin.style.top = (rect.height / 2) + 'px';
        }

        // Atualiza posição do pino quando a janela redimensiona
        window.addEventListener('resize', () => {
            if (isAdjustMode) {
                positionCenterPin();
            }
        });

        // Address exists modal elements
        const addressExistsModal = document.getElementById('addressExistsModal');
        const addressExistsText = document.getElementById('addressExistsText');
        const addressExistsCancel = document.getElementById('addressExistsCancel');
        const addressExistsAdjust = document.getElementById('addressExistsAdjust');

        // Old position tracking
        let existingClientRecord = null;
        let oldPositionMarker = null;

        // Show address exists modal
        function showAddressExistsModal(address, clientRecord) {
            existingClientRecord = clientRecord;
            addressExistsText.textContent = address;
            document.getElementById('overlay').classList.add('active');
            addressExistsModal.classList.add('active');
        }

        // Hide address exists modal
        function hideAddressExistsModal() {
            addressExistsModal.classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            existingClientRecord = null;
        }

        // Address exists modal event listeners
        addressExistsCancel.addEventListener('click', () => {
            hideAddressExistsModal();
            // Resume QR scanning
            qrStatusText.textContent = 'Aponte para o QR Code';
            startScanning();
        });

        addressExistsAdjust.addEventListener('click', () => {
            // Hide modal without resetting existingClientRecord
            addressExistsModal.classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            // Enter adjust mode with old position marker (will use existingClientRecord)
            enterAdjustModeWithOldPosition();
        });

        // Function to update coordinates from map center and display in real-time
        // Called on 'move' event for immediate visual feedback
        function updateAdjustedCoordinates() {
            const center = map.getCenter();
            adjustedCoordinates = {
                latitude: center.lat,
                longitude: center.lng
            };
        }

        // THROTTLED: Versão otimizada para eventos 'move' frequentes
        // Atualiza no máximo 30x por segundo (33ms) durante drag do mapa
        const throttledUpdateCoordinates = throttle(updateAdjustedCoordinates, 33);

        // Function to get current map center coordinates (for immediate capture)
        // Esta função captura as coordenadas EXATAS no momento da chamada
        // independente de qualquer evento ou animação
        function getCurrentMapCenterCoordinates() {
            const center = map.getCenter();
            return {
                latitude: center.lat,
                longitude: center.lng
            };
        }

        // Handler para detectar início de animação do mapa
        function onMapMoveStart() {
            if (isAdjustMode) {
                isMapAnimating = true;
                // Opcional: adicionar classe para feedback visual
                adjustModeConfirm.classList.add('disabled');
            }
        }

        // Handler para detectar fim de animação do mapa
        function onMapMoveEnd() {
            if (isAdjustMode) {
                isMapAnimating = false;
                adjustModeConfirm.classList.remove('disabled');
                // Atualiza as coordenadas finais (sem throttle para captura exata)
                updateAdjustedCoordinates();
            }
        }

        // Enter adjust mode - show fixed center pin, start at GPS position
        async function enterAdjustMode() {
            closeQrScanner();
            isAdjustMode = true;

            // Get current GPS position (not the address location)
            let initialLng, initialLat;

            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                initialLng = position.coords.longitude;
                initialLat = position.coords.latitude;
            } catch {
                // Fallback to map center if GPS fails
                const center = map.getCenter();
                initialLng = center.lng;
                initialLat = center.lat;
            }

            // Fly to current GPS position
            map.flyTo({
                center: [initialLng, initialLat],
                zoom: 17,
                duration: 1500
            });

            // Show center pin - posiciona no centro exato do mapa
            positionCenterPin();
            centerPin.classList.add('active');

            // Initialize adjusted coordinates with current GPS position
            adjustedCoordinates = {
                latitude: initialLat,
                longitude: initialLng
            };

            // Desabilita o botão confirmar durante a animação flyTo
            isMapAnimating = true;
            adjustModeConfirm.classList.add('disabled');

            // Registra listeners para atualização em tempo real
            // 'move' - atualiza coordenadas durante o movimento (feedback visual) - THROTTLED
            // 'movestart' - detecta início de animação
            // 'moveend' - detecta fim de animação e habilita confirmação
            map.on('move', throttledUpdateCoordinates);
            map.on('movestart', onMapMoveStart);
            map.on('moveend', onMapMoveEnd);

            // Show adjust mode UI
            adjustModeAddress.textContent = currentRecord.destination_address || 'Endereço';
            adjustModeBar.classList.add('active');

            // Hide other UI elements
            document.getElementById('cadastrarBtn').style.display = 'none';
        }

        // Enter adjust mode with old position marker
        async function enterAdjustModeWithOldPosition() {
            isAdjustMode = true;

            // Se tem cliente existente com coordenadas, vai direto para a posição cadastrada
            // Isso permite ajustar a partir da posição atual do cliente
            if (existingClientRecord && existingClientRecord.latitude && existingClientRecord.longitude) {
                const clientLng = existingClientRecord.longitude;
                const clientLat = existingClientRecord.latitude;

                map.flyTo({
                    center: [clientLng, clientLat],
                    zoom: 18,
                    duration: 1500
                });

                // Show center pin - posiciona no centro exato do mapa
                positionCenterPin();
                centerPin.classList.add('active');

                // Initialize adjusted coordinates with existing client position
                adjustedCoordinates = {
                    latitude: clientLat,
                    longitude: clientLng
                };
            } else {
                // Novo cliente - usa GPS atual
                let initialLng, initialLat;

                try {
                    const position = await new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(resolve, reject, {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        });
                    });
                    initialLng = position.coords.longitude;
                    initialLat = position.coords.latitude;
                } catch {
                    // Fallback to map center if GPS fails
                    const center = map.getCenter();
                    initialLng = center.lng;
                    initialLat = center.lat;
                }

                map.flyTo({
                    center: [initialLng, initialLat],
                    zoom: 17,
                    duration: 1500
                });

                // Show center pin - posiciona no centro exato do mapa
                positionCenterPin();
                centerPin.classList.add('active');

                // Initialize adjusted coordinates with current GPS position
                adjustedCoordinates = {
                    latitude: initialLat,
                    longitude: initialLng
                };
            }

            // Desabilita o botão confirmar durante a animação flyTo
            isMapAnimating = true;
            adjustModeConfirm.classList.add('disabled');

            // Registra listeners para atualização em tempo real - THROTTLED
            map.on('move', throttledUpdateCoordinates);
            map.on('movestart', onMapMoveStart);
            map.on('moveend', onMapMoveEnd);

            // Create and add old position marker if we have existing coordinates
            if (existingClientRecord && existingClientRecord.latitude && existingClientRecord.longitude) {
                // Create marker element - tamanho reduzido para melhor visualização do mapa
                const markerEl = document.createElement('div');
                markerEl.style.width = '24px';
                markerEl.style.height = '24px';
                markerEl.style.display = 'block';
                markerEl.style.position = 'relative';

                markerEl.innerHTML = `
                    <div style="
                        position: absolute;
                        top: -26px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #ef4444;
                        color: white;
                        padding: 2px 6px;
                        border-radius: 4px;
                        font-size: 9px;
                        font-weight: 600;
                        white-space: nowrap;
                        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
                        font-family: 'Plus Jakarta Sans', sans-serif;
                        z-index: 10;
                    ">
                        Antiga
                        <div style="
                            position: absolute;
                            bottom: -3px;
                            left: 50%;
                            transform: translateX(-50%);
                            width: 0;
                            height: 0;
                            border-left: 3px solid transparent;
                            border-right: 3px solid transparent;
                            border-top: 3px solid #ef4444;
                        "></div>
                    </div>
                    <div style="
                        width: 100%;
                        height: 100%;
                        background: #ef4444;
                        border: 2px solid white;
                        border-radius: 50%;
                        box-shadow: 0 2px 6px rgba(239, 68, 68, 0.4);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                    ">
                        <div style="
                            position: absolute;
                            width: 100%;
                            height: 100%;
                            background: #ef4444;
                            border-radius: 50%;
                            opacity: 0.3;
                            animation: oldMarkerPulse 2s ease-out infinite;
                        "></div>
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5" style="width: 12px; height: 12px; color: white; position: relative; z-index: 1;">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </div>
                `;


                try {
                    // Create and add marker to map using CADASTRO coordinates
                    const oldLng = existingClientRecord.longitude;
                    const oldLat = existingClientRecord.latitude;

                    oldPositionMarker = ResourceRegistry.registerMarker(new mapboxgl.Marker({
                        element: markerEl,
                        anchor: 'bottom'
                    })
                    .setLngLat([oldLng, oldLat])
                    .addTo(map));
                } catch (error) {}
            }

            // Show adjust mode UI
            adjustModeAddress.textContent = currentRecord.destination_address || 'Endereço';
            adjustModeBar.classList.add('active');

            // Hide other UI elements
            document.getElementById('cadastrarBtn').style.display = 'none';
        }

        // Cancel adjust mode
        adjustModeCancel.addEventListener('click', () => {
            exitAdjustMode();
        });

        // Confirm adjust mode - save adjusted coordinates with quick success
        adjustModeConfirm.addEventListener('click', async () => {
            // Não permite confirmação durante animação do mapa
            if (isMapAnimating) {
                return;
            }

            // Capture the EXACT current map center at the moment of confirmation
            // Esta chamada é síncrona e independente de GPS ou qualquer evento assíncrono
            // O map.getCenter() retorna as coordenadas exatas do centro visual do mapa
            const finalCoordinates = getCurrentMapCenterCoordinates();

            if (finalCoordinates && finalCoordinates.latitude && finalCoordinates.longitude) {
                await saveClientLocationQuick(finalCoordinates);
            } else if (adjustedCoordinates) {
                // Fallback to last tracked coordinates (improvável de ocorrer)
                await saveClientLocationQuick(adjustedCoordinates);
            }
            exitAdjustMode();
        });

        // Show quick success icon
        function showQuickSuccess() {
            const toast = document.createElement('div');
            toast.className = 'quick-success';
            toast.innerHTML = `
                <div class="quick-success-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
                    </svg>
                </div>
            `;
            document.body.appendChild(toast);

            // Remove after animation
            setTimeout(() => {
                toast.remove();
            }, 1200);
        }

        // Save client location quickly (for adjust mode - no loading modal)
        async function saveClientLocationQuick(coordinates) {
            if (!currentRecord) return;

            const isUpdate = existingClientRecord !== null;

            // Para updates, usa o endereço do cliente existente para garantir match correto
            // Para novos, usa o endereço da planilha
            const addressToUse = isUpdate && existingClientRecord.address
                ? existingClientRecord.address
                : currentRecord.destination_address;

            const clientData = {
                address: addressToUse,
                bairro: currentRecord.bairro || null,
                city: currentRecord.city || null,
                zipcode: currentRecord.zipcode || null,
                latitude: coordinates.latitude,
                longitude: coordinates.longitude
            };

            // Guarda o endereço original do cliente para atualização do marcador
            const originalClientAddress = isUpdate ? existingClientRecord.address : null;

            // If offline, save locally and show success
            if (!isOnline) {
                try {
                    if (isUpdate) {
                        // For updates, remove old record and add new one
                        // First, get all pending clients
                        const pendingClients = await getAllFromOfflineDB('pendingClients');

                        // Find and remove the old record
                        const oldRecordIndex = pendingClients.findIndex(client =>
                            client.address === clientData.address
                        );

                        if (oldRecordIndex !== -1) {
                            // Remove old record from IndexedDB
                            // Note: We need to delete by key, not by index
                            // Since getAllFromOfflineDB doesn't return keys, we'll just save the new one
                            // The sync function will handle duplicates
                        }

                        // Save updated coordinates
                        await saveToOfflineDB('pendingClients', clientData);
                    } else {
                        // New client - just save
                        await saveToOfflineDB('pendingClients', clientData);
                    }

                    // Gera ID temporário para o cliente offline
                    const clientWithTempId = {
                        ...clientData,
                        id: 'pending_' + Date.now()
                    };

                    // Atualiza cache em memória (clientesCache)
                    if (clientesCache.data) {
                        const existingIdx = clientesCache.data.findIndex(c => c.address === clientData.address);
                        if (existingIdx !== -1) {
                            clientesCache.data[existingIdx] = { ...clientesCache.data[existingIdx], ...clientWithTempId };
                        } else {
                            clientesCache.data.unshift(clientWithTempId);
                        }
                        clientesCache.timestamp = Date.now();
                    }

                    // Atualiza allClientes (lista em memória)
                    if (allClientes) {
                        const existingIdx = allClientes.findIndex(c => c.address === clientData.address);
                        if (existingIdx !== -1) {
                            allClientes[existingIdx] = { ...allClientes[existingIdx], ...clientWithTempId };
                        } else {
                            allClientes.unshift(clientWithTempId);
                        }
                    }

                    // Atualiza o IndexedDB cache (cachedClients)
                    try {
                        const cachedClients = await getAllFromOfflineDB('cachedClients');
                        const existingIndex = cachedClients.findIndex(c => c.address === clientData.address);

                        if (existingIndex !== -1) {
                            cachedClients[existingIndex] = {
                                ...cachedClients[existingIndex],
                                ...clientWithTempId
                            };
                        } else {
                            cachedClients.unshift(clientWithTempId);
                        }

                        await saveCacheToDB('cachedClients', cachedClients);
                    } catch (cacheUpdateErr) {
                        // Cache update failed, but pendingClients was saved
                    }

                    // Re-renderiza lista de clientes
                    if (allClientes && allClientes.length > 0) {
                        renderClientes(allClientes);
                    }

                    // IMPORTANTE: Atualiza marcador de cliente (verde) se visível no mapa
                    if (markersVisible && map && map.getSource && map.getSource('clientes') && clientData.latitude && clientData.longitude) {
                        const source = map.getSource('clientes');
                        const currentData = source._data;
                        if (currentData && currentData.features) {
                            if (isUpdate) {
                                // Atualiza feature existente - usa comparação normalizada para maior robustez
                                const normalizedClientAddr = normalizeAddressForComparison(clientData.address);
                                const updatedFeatures = currentData.features.map(f => {
                                    const normalizedFeatureAddr = normalizeAddressForComparison(f.properties.address);
                                    if (normalizedFeatureAddr === normalizedClientAddr) {
                                        return {
                                            ...f,
                                            geometry: {
                                                type: 'Point',
                                                coordinates: [clientData.longitude, clientData.latitude]
                                            },
                                            properties: {
                                                ...f.properties,
                                                latitude: clientData.latitude,
                                                longitude: clientData.longitude
                                            }
                                        };
                                    }
                                    return f;
                                });
                                source.setData({ type: 'FeatureCollection', features: updatedFeatures });
                            } else {
                                // Adiciona novo feature
                                const newFeature = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: [clientData.longitude, clientData.latitude]
                                    },
                                    properties: {
                                        id: clientWithTempId.id,
                                        address: clientData.address,
                                        latitude: clientData.latitude,
                                        longitude: clientData.longitude
                                    }
                                };
                                source.setData({
                                    type: 'FeatureCollection',
                                    features: [...currentData.features, newFeature]
                                });
                            }
                        }
                    }

                    // IMPORTANTE: Atualiza marcador de rota se visível (vermelho → verde)
                    if (map && map.getSource && map.getSource('route-stops')) {
                        await updateRouteMarkerForNewClient(clientData);
                    }

                    showQuickSuccess();
                    updateOfflineIndicator();

                    // Remove o endereço cadastrado da lista manual
                    removeAddressFromManualList(clientData.address);

                    currentRecord = null;
                    existingClientRecord = null;
                    return;
                } catch (err) {
                    // Erro ao salvar offline
                    showErrorModal('Erro ao salvar offline.');
                    return;
                }
            }

            // If online, try to save/update in Supabase
            try {
                if (isUpdate) {
                    // UPDATE existing record
                    const { error } = await db
                        .from('clients')
                        .update({
                            bairro: clientData.bairro,
                            city: clientData.city,
                            zipcode: clientData.zipcode,
                            latitude: coordinates.latitude,
                            longitude: coordinates.longitude
                        })
                        .eq('address', clientData.address);

                    if (error) throw error;
                } else {
                    // INSERT new record
                    const { error } = await db
                        .from('clients')
                        .insert(clientData);

                    if (error) throw error;
                }

                // Show quick success icon
                showQuickSuccess();

                // Remove o endereço cadastrado da lista manual
                removeAddressFromManualList(clientData.address);

                // PERFORMANCE: Atualização incremental em vez de recarregar tudo
                // Adiciona o cliente diretamente aos caches e UI sem fazer novas requisições
                await addSingleClientToUI(clientData, isUpdate);

                // Reset current record
                currentRecord = null;
                existingClientRecord = null;

            } catch (error) {
                try {
                    await saveToOfflineDB('pendingClients', clientData);

                    // Gera ID temporário para o cliente offline
                    const clientWithTempId = {
                        ...clientData,
                        id: 'pending_' + Date.now()
                    };

                    // PERFORMANCE: Atualização incremental para modo offline também
                    // Atualiza caches e UI sem precisar recarregar tudo
                    if (clientesCache.data) {
                        const existingIdx = clientesCache.data.findIndex(c => c.address === clientData.address);
                        if (existingIdx !== -1) {
                            clientesCache.data[existingIdx] = { ...clientesCache.data[existingIdx], ...clientWithTempId };
                        } else {
                            clientesCache.data.unshift(clientWithTempId);
                        }
                        clientesCache.timestamp = Date.now();
                    }

                    if (allClientes) {
                        const existingIdx = allClientes.findIndex(c => c.address === clientData.address);
                        if (existingIdx !== -1) {
                            allClientes[existingIdx] = { ...allClientes[existingIdx], ...clientWithTempId };
                        } else {
                            allClientes.unshift(clientWithTempId);
                        }
                    }

                    // Atualiza IndexedDB cache
                    try {
                        const cachedClients = await getAllFromOfflineDB('cachedClients');
                        if (cachedClients) {
                            const existingIndex = cachedClients.findIndex(c => c.address === clientData.address);
                            if (existingIndex !== -1) {
                                cachedClients[existingIndex] = { ...cachedClients[existingIndex], ...clientWithTempId };
                            } else {
                                cachedClients.unshift(clientWithTempId);
                            }
                            await saveCacheToDB('cachedClients', cachedClients);
                        }
                    } catch (cacheErr) {}

                    // Re-renderiza lista de clientes
                    if (allClientes && allClientes.length > 0) {
                        renderClientes(allClientes);
                    }

                    // Atualiza marcador de cliente (verde) se visível no mapa
                    if (markersVisible && map && map.getSource && map.getSource('clientes') && clientData.latitude && clientData.longitude) {
                        const source = map.getSource('clientes');
                        const currentData = source._data;
                        if (currentData && currentData.features) {
                            // Verifica se é update (endereço já existe nos features) - usa comparação normalizada
                            const normalizedClientAddr = normalizeAddressForComparison(clientData.address);
                            const existingFeatureIdx = currentData.features.findIndex(f => {
                                const normalizedFeatureAddr = normalizeAddressForComparison(f.properties.address);
                                return normalizedFeatureAddr === normalizedClientAddr;
                            });
                            if (existingFeatureIdx !== -1) {
                                // Atualiza feature existente
                                const updatedFeatures = currentData.features.map(f => {
                                    const normalizedFeatureAddr = normalizeAddressForComparison(f.properties.address);
                                    if (normalizedFeatureAddr === normalizedClientAddr) {
                                        return {
                                            ...f,
                                            geometry: {
                                                type: 'Point',
                                                coordinates: [clientData.longitude, clientData.latitude]
                                            },
                                            properties: {
                                                ...f.properties,
                                                latitude: clientData.latitude,
                                                longitude: clientData.longitude
                                            }
                                        };
                                    }
                                    return f;
                                });
                                source.setData({ type: 'FeatureCollection', features: updatedFeatures });
                            } else {
                                // Adiciona novo feature
                                const newFeature = {
                                    type: 'Feature',
                                    geometry: {
                                        type: 'Point',
                                        coordinates: [clientData.longitude, clientData.latitude]
                                    },
                                    properties: {
                                        id: clientWithTempId.id,
                                        address: clientData.address,
                                        latitude: clientData.latitude,
                                        longitude: clientData.longitude
                                    }
                                };
                                source.setData({
                                    type: 'FeatureCollection',
                                    features: [...currentData.features, newFeature]
                                });
                            }
                        }
                    }

                    // Atualiza marcador de rota se visível
                    if (map && map.getSource && map.getSource('route-stops')) {
                        await updateRouteMarkerForNewClient(clientData);
                    }

                    showQuickSuccess();
                    updateOfflineIndicator();

                    // Remove o endereço cadastrado da lista manual
                    removeAddressFromManualList(clientData.address);

                    currentRecord = null;
                    existingClientRecord = null;
                } catch (offlineErr) {
                    showErrorModal('Erro ao salvar o endereço. Tente novamente.');
                }
            }
        }

        // Função para remover um endereço da lista manual de cadastro
        function removeAddressFromManualList(address) {
            if (!address || !planilhaAddressData || planilhaAddressData.length === 0) return;

            // Normaliza o endereço para comparação
            const normalizedAddress = normalizeAddressForComparison(address);

            // Encontra e remove o endereço da lista usando comparação normalizada
            const index = planilhaAddressData.findIndex(item => {
                const normalizedItemAddr = normalizeAddressForComparison(item.destination_address);
                return normalizedItemAddr === normalizedAddress;
            });

            if (index !== -1) {
                planilhaAddressData.splice(index, 1);

                // Re-renderiza a lista se ainda houver endereços
                if (planilhaAddressData.length > 0) {
                    renderAddressList(planilhaAddressData);
                } else {
                    // Mostra mensagem de todos cadastrados
                    const qrAddressList = document.getElementById('qrAddressList');
                    if (qrAddressList) {
                        qrAddressList.innerHTML = '<div class="qr-address-list-empty">Todos os endereços já foram cadastrados! 🎉</div>';
                    }
                }
            }
        }

        // Exit adjust mode
        function exitAdjustMode() {
            isAdjustMode = false;
            isMapAnimating = false;

            // Remove all map listeners
            map.off('move', throttledUpdateCoordinates);
            map.off('movestart', onMapMoveStart);
            map.off('moveend', onMapMoveEnd);

            // Hide center pin
            centerPin.classList.remove('active');

            // Remove disabled state from confirm button
            adjustModeConfirm.classList.remove('disabled');

            // Remove old position marker if exists
            if (oldPositionMarker) {
                ResourceRegistry.removeMarker(oldPositionMarker);
                oldPositionMarker = null;
            }

            // Hide adjust mode UI
            adjustModeBar.classList.remove('active');

            // Show other UI elements
            document.getElementById('cadastrarBtn').style.display = 'block';

            // Reset adjusted coordinates and existing client record
            adjustedCoordinates = null;
            existingClientRecord = null;
        }

        // ==================== NAVIGATION SYSTEM ====================
        const endNavBtn = document.getElementById('endNavBtn');
        let currentNavigation = null;
        let navigationGeolocateHandler = null;

        // Get route from Mapbox Directions API
        async function getRoute(startLng, startLat, endLng, endLat) {
            const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${startLng},${startLat};${endLng},${endLat}?alternatives=false&geometries=geojson&overview=full&access_token=${mapboxgl.accessToken}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
                    throw new Error('Não foi possível calcular a rota');
                }

                return data.routes[0];
            } catch (error) {
                throw new Error('Erro ao obter rota. Verifique sua conexão.');
            }
        }

        // Draw route on map
        function drawRoute(route) {
            // Remove existing route first
            removeRoute();

            const geojson = {
                type: 'Feature',
                geometry: route.geometry
            };

            // Add route source
            map.addSource('navigation-route', {
                type: 'geojson',
                data: geojson
            });

            // Find a label layer to insert route below it
            let labelLayerId;
            const layers = map.getStyle().layers;
            for (const layer of layers) {
                if (layer.type === 'symbol' && layer.layout && layer.layout['text-field']) {
                    labelLayerId = layer.id;
                    break;
                }
            }

            // Add route outline layer (for border effect)
            map.addLayer({
                id: 'navigation-route-outline',
                type: 'line',
                source: 'navigation-route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#1e40af',
                    'line-width': 10,
                    'line-opacity': 0.4
                }
            }, labelLayerId);

            // Add route line layer
            map.addLayer({
                id: 'navigation-route',
                type: 'line',
                source: 'navigation-route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#3b82f6',
                    'line-width': 6,
                    'line-opacity': 0.9
                }
            }, labelLayerId);
        }

        // Remove route from map
        function removeRoute() {
            if (map.getLayer('navigation-route')) {
                map.removeLayer('navigation-route');
            }
            if (map.getLayer('navigation-route-outline')) {
                map.removeLayer('navigation-route-outline');
            }
            if (map.getSource('navigation-route')) {
                map.removeSource('navigation-route');
            }
        }

        // Last navigation position for bearing calculation
        let lastNavPosition = null;
        let navUserMarker = null;

        // Calculate haversine distance between two points (returns km)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calculate bearing between two points
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const toRad = (deg) => deg * Math.PI / 180;
            const toDeg = (rad) => rad * 180 / Math.PI;

            const dLng = toRad(lng2 - lng1);
            const y = Math.sin(dLng) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                      Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLng);

            return (toDeg(Math.atan2(y, x)) + 360) % 360;
        }

        // Create smooth navigation marker
        function createNavUserMarker(lng, lat) {
            if (navUserMarker) {
                ResourceRegistry.removeMarker(navUserMarker);
            }

            const el = document.createElement('div');
            el.className = 'nav-user-marker';
            el.innerHTML = `
                <div class="nav-user-pulse"></div>
                <div class="nav-user-dot"></div>
            `;

            navUserMarker = ResourceRegistry.registerMarker(new mapboxgl.Marker({
                element: el,
                anchor: 'center',
                rotationAlignment: 'map',
                pitchAlignment: 'map'
            })
            .setLngLat([lng, lat])
            .addTo(map));

            return navUserMarker;
        }

        // Update navigation marker position smoothly
        function updateNavUserMarker(lng, lat, heading) {
            if (!navUserMarker) {
                createNavUserMarker(lng, lat);
            } else {
                navUserMarker.setLngLat([lng, lat]);
            }

            // Arrow direction removed
        }

        // Remove navigation marker
        function removeNavUserMarker() {
            if (navUserMarker) {
                ResourceRegistry.removeMarker(navUserMarker);
                navUserMarker = null;
            }
        }

        // Hide/show default geolocate marker
        function setGeolocateMarkerVisible(visible) {
            const geoMarker = document.querySelector('.mapboxgl-user-location');
            if (geoMarker) {
                geoMarker.style.display = visible ? '' : 'none';
            }
        }

        // Calculate distance from point to line segment
        function pointToLineDistance(point, lineStart, lineEnd) {
            const { lat: lat0, lng: lng0 } = point;
            const { lat: lat1, lng: lng1 } = lineStart;
            const { lat: lat2, lng: lng2 } = lineEnd;

            const A = lng0 - lng1;
            const B = lat0 - lat1;
            const C = lng2 - lng1;
            const D = lat2 - lat1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = lng1;
                yy = lat1;
            } else if (param > 1) {
                xx = lng2;
                yy = lat2;
            } else {
                xx = lng1 + param * C;
                yy = lat1 + param * D;
            }

            const dx = lng0 - xx;
            const dy = lat0 - yy;
            const distDegrees = Math.sqrt(dx * dx + dy * dy);
            return distDegrees * 111; // Approximate km per degree
        }

        // Find closest point on route to current position
        function getDistanceToRoute(currentLng, currentLat, routeGeometry) {
            if (!routeGeometry || !routeGeometry.coordinates || routeGeometry.coordinates.length < 2) {
                return null;
            }

            let minDistance = Infinity;
            const coordinates = routeGeometry.coordinates;

            for (let i = 0; i < coordinates.length - 1; i++) {
                const lineStart = { lng: coordinates[i][0], lat: coordinates[i][1] };
                const lineEnd = { lng: coordinates[i + 1][0], lat: coordinates[i + 1][1] };
                const distance = pointToLineDistance(
                    { lat: currentLat, lng: currentLng },
                    lineStart,
                    lineEnd
                );

                if (distance < minDistance) {
                    minDistance = distance;
                }
            }

            return minDistance;
        }

        // Check if user is off-route and recalculate if necessary
        async function checkAndRecalculateRoute(currentLng, currentLat) {
            if (!currentNavigation || !currentNavigation.route) return;

            const distanceToRoute = getDistanceToRoute(
                currentLng,
                currentLat,
                currentNavigation.route.geometry
            );

            // If user is more than 20 meters off-route, recalculate
            if (distanceToRoute && distanceToRoute > 0.02) {

                try {
                    const newRoute = await getRoute(
                        currentLng,
                        currentLat,
                        currentNavigation.destination.lng,
                        currentNavigation.destination.lat
                    );

                    // Update navigation with new route
                    currentNavigation.route = newRoute;
                    drawRoute(newRoute);

                } catch (error) {
                    // Erro ao recalcular rota
                }
            }
        }

        // Handler for geolocate events during navigation
        function onNavigationGeolocate(e) {
            if (!currentNavigation) return;

            const lng = e.coords.longitude;
            const lat = e.coords.latitude;
            let heading = e.coords.heading;

            // Calculate heading from movement if GPS doesn't provide it
            if ((heading === null || heading === undefined || isNaN(heading)) && lastNavPosition) {
                const distance = Math.sqrt(
                    Math.pow(lng - lastNavPosition.lng, 2) +
                    Math.pow(lat - lastNavPosition.lat, 2)
                );
                // Only calculate bearing if moved enough (avoid jitter)
                if (distance > 0.00003) {
                    heading = calculateBearing(lastNavPosition.lat, lastNavPosition.lng, lat, lng);
                } else {
                    // Use last known heading if not moved enough
                    heading = lastNavPosition.heading || map.getBearing();
                }
            }

            // Store current position for next calculation
            lastNavPosition = { lng, lat, heading };

            // Update custom marker (smooth via CSS transition)
            updateNavUserMarker(lng, lat, heading);

            // Check and recalculate route if user is off-route
            checkAndRecalculateRoute(lng, lat);

            // Calculate distance to destination in meters
            const destLat = currentNavigation.destination.lat;
            const destLng = currentNavigation.destination.lng;
            const distanceToDestKm = haversineDistance(lat, lng, destLat, destLng);
            const distanceToDestM = distanceToDestKm * 1000;

            // Update navigation info notification with current distance
            updateNavigationInfoDistance(distanceToDestM);

            // Dynamic zoom and pitch based on distance to destination
            // As user approaches, zoom increases and pitch decreases for better precision view
            let dynamicZoom, dynamicPitch, dynamicBearing;

            if (distanceToDestM > 500) {
                // Far from destination: standard navigation view (3D perspective)
                dynamicZoom = 17;
                dynamicPitch = 50;
                dynamicBearing = heading || map.getBearing();
            } else if (distanceToDestM > 200) {
                // Approaching: start increasing zoom, slightly reduce pitch
                dynamicZoom = 17.5;
                dynamicPitch = 45;
                dynamicBearing = heading || map.getBearing();
            } else if (distanceToDestM > 100) {
                // Getting close: higher zoom
                dynamicZoom = 18;
                dynamicPitch = 40;
                dynamicBearing = heading || map.getBearing();
            } else if (distanceToDestM > 50) {
                // Very close: high zoom
                dynamicZoom = 18.5;
                dynamicPitch = 35;
                dynamicBearing = heading || map.getBearing();
            } else if (distanceToDestM > 20) {
                // Almost there: higher zoom, reduced pitch
                dynamicZoom = 19;
                dynamicPitch = 30;
                dynamicBearing = heading || map.getBearing();
            } else {
                // Arrived: closest zoom, top-down 2D view
                dynamicZoom = 19.5;
                dynamicPitch = 0;
                dynamicBearing = heading || map.getBearing();
            }

            // Smoothly update map view with dynamic zoom/pitch based on proximity
            map.easeTo({
                center: [lng, lat],
                zoom: dynamicZoom,
                pitch: dynamicPitch,
                bearing: dynamicBearing,
                duration: 800,
                easing: (t) => t * (2 - t)
            });

        }

        // Navigation info notification element reference
        let navigationInfoNotification = null;

        // Show navigation info notification (bottom-left) when navigation starts
        function showNavigationInfoNotification(address, order, distance = null, ids = '') {
            // Remove existing notification if any
            hideNavigationInfoNotification();

            const notification = document.createElement('div');
            notification.className = 'navigation-info-notification';
            notification.id = 'navigation-info-notification';
            notification.innerHTML = `
                <div class="nav-info-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </div>
                <div class="nav-info-content">
                    <div class="nav-info-title">Navegando até</div>
                    <div class="nav-info-order">📦 Ordem: ${order}</div>
                    <div class="nav-info-address">${address}</div>
                    <div class="nav-info-distance" id="nav-info-distance">${distance !== null ? distance + 'm restantes' : 'Calculando...'}</div>
                    <div class="nav-info-actions">
                        <button class="nav-info-btn delivered" data-action="delivered" data-ids="${ids}">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>
                            <span>Entregue</span>
                        </button>
                        <button class="nav-info-btn not-delivered" data-action="not_delivered" data-ids="${ids}">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
                            <span>Não entregue</span>
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(notification);
            navigationInfoNotification = notification;

            // Add click handlers for delivery buttons
            notification.querySelectorAll('.nav-info-btn').forEach(btn => {
                btn.addEventListener('click', async (evt) => {
                    evt.stopPropagation();
                    evt.preventDefault();

                    const action = btn.dataset.action;
                    const idsStr = btn.dataset.ids;
                    if (!idsStr) return;

                    const idsArr = idsStr.split(',').map(id => parseInt(id.trim())).filter(id => !isNaN(id));
                    if (idsArr.length === 0) return;

                    // PROTEÇÃO CONTRA PISCADA: Marca timestamp imediatamente
                    lastRouteMarkersSave = Date.now();

                    // Atualiza UI imediatamente (otimista)
                    const sourceData = map.getSource('route-stops')?._data;
                    if (sourceData) {
                        const markerFeature = sourceData.features.find(f => f.properties.ids === idsStr);
                        if (markerFeature) {
                            markerFeature.properties.deliveryStatus = action;

                            // Atualiza o ícone baseado no novo status
                            const props = markerFeature.properties;
                            let newColor;
                            if (action === 'delivered') {
                                newColor = 'gray';
                            } else if (action === 'not_delivered') {
                                newColor = 'gray-x';
                            } else if (props.isRegistered) {
                                newColor = props.matchType === 'exact' ? 'green' : 'purple';
                            } else {
                                newColor = 'red';
                            }

                            const newIconName = `pin-${newColor}-${props.packageCount}`;
                            markerFeature.properties.icon = newIconName;

                            // CORREÇÃO PISCADA OFFLINE: setData IMEDIATAMENTE
                            map.getSource('route-stops').setData(sourceData);
                            updateRouteMarkersCache(sourceData);

                            // Carrega ícone em background se não existir
                            if (!map.hasImage(newIconName)) {
                                const { dataUrl, pixelRatio } = generatePinIcon(props.packageCount, newColor);
                                const img = new Image();
                                img.onload = () => {
                                    if (!map.hasImage(newIconName)) {
                                        map.addImage(newIconName, img, { pixelRatio: pixelRatio });
                                    }
                                    // Re-renderiza para mostrar o ícone correto
                                    map.getSource('route-stops').setData(sourceData);
                                };
                                img.src = dataUrl;
                            }
                        }
                    }

                    // Update fixed stats panel after status change
                    updateFixedStatsPanel();

                    // Encerra navegação após marcar status
                    stopNavigation();

                    // Sincroniza em background
                    updateDeliveryStatus(idsArr, action).catch(() => {});
                });
            });
        }

        // Update distance in navigation info notification
        function updateNavigationInfoDistance(distanceM) {
            const distanceEl = document.getElementById('nav-info-distance');
            if (distanceEl) {
                if (distanceM < 1000) {
                    distanceEl.textContent = `${Math.round(distanceM)}m restantes`;
                } else {
                    distanceEl.textContent = `${(distanceM / 1000).toFixed(1)}km restantes`;
                }
            }
        }

        // Hide navigation info notification
        function hideNavigationInfoNotification() {
            const existing = document.getElementById('navigation-info-notification');
            if (existing) {
                existing.classList.add('fade-out');
                setTimeout(() => existing.remove(), 400);
            }
            navigationInfoNotification = null;
        }

        // Start navigation tracking using Mapbox GeolocateControl
        let navigationWatchId = null;

        function startNavigationTracking() {
            if (!geolocateControl) return;

            // Reset last position
            lastNavPosition = null;

            // Hide default geolocate marker
            setGeolocateMarkerVisible(false);

            // Add geolocate event handler for smooth map following
            navigationGeolocateHandler = onNavigationGeolocate;
            geolocateControl.on('geolocate', navigationGeolocateHandler);

            // Trigger tracking mode
            geolocateControl.trigger();

            // Força atualização mais frequente durante navegação usando watchPosition nativo
            if (navigator.geolocation && !navigationWatchId) {
                navigationWatchId = navigator.geolocation.watchPosition(
                    (position) => {
                        // Dispara o handler com a posição mais recente
                        if (currentNavigation && navigationGeolocateHandler) {
                            onNavigationGeolocate(position);
                        }
                    },
                    () => {}, // Ignora erros silenciosamente
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,        // Sempre posição fresca durante navegação
                        timeout: 5000         // Timeout curto para respostas rápidas
                    }
                );
            }
        }

        // Stop navigation tracking
        function stopNavigationTracking() {
            if (geolocateControl && navigationGeolocateHandler) {
                geolocateControl.off('geolocate', navigationGeolocateHandler);
                navigationGeolocateHandler = null;
            }

            // Limpa o watchPosition nativo
            if (navigationWatchId !== null) {
                navigator.geolocation.clearWatch(navigationWatchId);
                navigationWatchId = null;
            }

            // Reset last position
            lastNavPosition = null;

            // Remove custom navigation marker
            removeNavUserMarker();

            // Show default geolocate marker again
            setGeolocateMarkerVisible(true);

            // Reset map orientation smoothly
            map.easeTo({
                pitch: 0,
                bearing: 0,
                duration: 500
            });

            // Re-trigger geolocate control to restart GPS tracking
            // Delay to allow map animation to settle
            setTimeout(() => {
                if (geolocateControl) {
                    geolocateControl.trigger();
                }
            }, 600);
        }

        // Stop navigation
        function stopNavigation() {
            stopNavigationTracking();
            removeRoute();
            currentNavigation = null;
            endNavBtn.classList.remove('active');
            // Hide navigation info notification
            hideNavigationInfoNotification();
            // Show cadastrar button again
            document.getElementById('cadastrarBtn').style.display = 'flex';
        }

        // End navigation button event
        endNavBtn.addEventListener('click', stopNavigation);

        // Start navigation - draws route on map and starts real-time tracking
        async function startNavigation(destLng, destLat, destAddress, destOrder = '-', destIds = '') {
            try {
                // Get current position
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });

                const startLng = position.coords.longitude;
                const startLat = position.coords.latitude;

                // Get route
                const route = await getRoute(startLng, startLat, destLng, destLat);

                // Store current navigation
                currentNavigation = {
                    destination: { lng: destLng, lat: destLat, address: destAddress, order: destOrder, ids: destIds },
                    route: route
                };

                // Draw route on map
                drawRoute(route);

                // Hide cadastrar button and show end navigation button
                document.getElementById('cadastrarBtn').style.display = 'none';
                endNavBtn.classList.add('active');

                // Show navigation info notification (bottom-left)
                const initialDistanceM = route.distance || null;
                showNavigationInfoNotification(destAddress, destOrder, initialDistanceM ? Math.round(initialDistanceM) : null, destIds);

                // First, show entire route overview
                const coordinates = route.geometry.coordinates;
                const bounds = new mapboxgl.LngLatBounds();
                coordinates.forEach(coord => bounds.extend(coord));
                map.fitBounds(bounds, {
                    padding: { top: 80, bottom: 150, left: 50, right: 50 },
                    duration: 1500
                });

                // After showing route overview, start tracking with GeolocateControl
                setTimeout(() => {
                    startNavigationTracking();
                }, 2000);

            } catch (error) {
                showErrorModal(error.message || 'Erro ao calcular rota');
            }
        }

        // ==================== END NAVIGATION SYSTEM ====================

        // Re-center map on GPS when returning to the app (after screen off, tab switch, etc.)
        function recenterOnGPS() {
            // Skip if map not ready, still initializing, in adjust mode, or navigation is active
            if (!map || !mapFullyInitialized || isAdjustMode || currentNavigation) return;

            // Remove view marker if any
            if (typeof removeViewMarker === 'function') {
                removeViewMarker();
            }

            // Get current GPS position and center map
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const { latitude, longitude } = position.coords;
                    map.flyTo({
                        center: [longitude, latitude],
                        zoom: Math.max(map.getZoom(), 14),
                        duration: 1500
                    });
                },
                () => {
                    // Silently fail if GPS not available
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // Função para forçar re-renderização do centerPin e sincronizar o mapa
        function resyncCenterPin() {
            if (isAdjustMode && centerPin) {
                // Força re-renderização removendo e re-adicionando a classe
                centerPin.classList.remove('active');

                // Força reflow do navegador
                void centerPin.offsetHeight;

                // Re-posiciona e re-adiciona a classe
                positionCenterPin();
                centerPin.classList.add('active');

                // Força o mapa a re-renderizar
                if (map) {
                    map.resize();

                    // Atualiza as coordenadas após resize
                    setTimeout(() => {
                        updateAdjustedCoordinates();
                    }, 100);
                }
            }
        }

        // Unified visibility/resume handler to avoid duplicate actions
        // Uses debounce to prevent multiple simultaneous executions
        let lastVisibilityHandled = 0;
        function handleVisibilityResume() {
            const now = Date.now();
            // Debounce: ignore if handled within last 800ms
            if (now - lastVisibilityHandled < 800) return;
            lastVisibilityHandled = now;

            setTimeout(() => {
                if (isAdjustMode) {
                    resyncCenterPin();
                } else {
                    recenterOnGPS();
                }
            }, 500);
        }

        // Multiple event listeners for better mobile compatibility (consolidated)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                handleVisibilityResume();
            }
        });

        window.addEventListener('focus', handleVisibilityResume);

        window.addEventListener('pageshow', (event) => {
            if (event.persisted) {
                handleVisibilityResume();
            }
        });

        // Listener adicional para resize da janela (rotação de tela) - DEBOUNCED
        // DEBOUNCE: Aguarda 150ms após parar de redimensionar para evitar múltiplas chamadas
        const handleResize = debounce(() => {
            if (map) {
                map.resize();
            }
        }, 150);
        window.addEventListener('resize', handleResize);

        // ============================================
        // CLEANUP GERAL - Antes de fechar/recarregar
        // ============================================

        /**
         * Função de cleanup geral chamada antes de fechar a página
         * Limpa todos os recursos registrados para evitar memory leaks
         */
        function cleanupApplication() {
            // Limpa todos os recursos registrados (popups, marcadores, timers)
            ResourceRegistry.clearAll();

            // Para interval de refresh do cache
            if (typeof cacheRefreshInterval !== 'undefined' && cacheRefreshInterval) {
                clearInterval(cacheRefreshInterval);
            }

            // Para navigation watch se ativo
            if (typeof navWatchId !== 'undefined' && navWatchId) {
                navigator.geolocation.clearWatch(navWatchId);
            }
        }

        // Registra cleanup para beforeunload
        window.addEventListener('beforeunload', cleanupApplication);

        // Também limpa quando a página fica oculta por muito tempo (economia de memória)
        let hiddenSince = null;
        const HIDDEN_CLEANUP_TIMEOUT = 5 * 60 * 1000; // 5 minutos

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                hiddenSince = Date.now();
            } else if (document.visibilityState === 'visible' && hiddenSince) {
                const hiddenDuration = Date.now() - hiddenSince;
                hiddenSince = null;

                // Se ficou oculto por mais de 5 minutos, limpa caches antigos
                if (hiddenDuration > HIDDEN_CLEANUP_TIMEOUT) {
                    pruneOldCacheData(7); // Remove dados com mais de 7 dias
                }
            }
        });

        } // Fecha initApplication()

        // ============================================
        // PWA - SERVICE WORKER E INSTALAÇÃO
        // ============================================

        // Registrar Service Worker (arquivo externo sw.js)
        async function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    // Registra o arquivo sw.js com caminho relativo (funciona em GitHub Pages, Vercel, Cloudflare, etc.)
                    const registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });

                    console.log('✅ Service Worker registrado:', registration.scope);

                    // Escuta atualizações
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // Nova versão disponível
                                showUpdateNotification();
                            }
                        });
                    });

                    // Escuta mensagens do SW
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data.type === 'SYNC_REQUEST') {
                            // Trigger sync de dados pendentes
                            if (typeof syncAllPendingData === 'function') {
                                syncAllPendingData();
                            }
                        }
                    });

                } catch (error) {
                    console.warn('Service Worker não pôde ser registrado:', error);
                }
            }
        }

        // Variável para armazenar evento de instalação
        let deferredInstallPrompt = null;

        // Captura evento beforeinstallprompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredInstallPrompt = e;
            showInstallButton();
        });

        // Mostra botão de instalação
        function showInstallButton() {
            // Cria botão de instalação se não existir
            if (document.getElementById('pwaInstallBtn')) return;

            const installBtn = document.createElement('button');
            installBtn.id = 'pwaInstallBtn';
            installBtn.className = 'pwa-install-btn';
            installBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
                <span>Instalar App</span>
            `;
            installBtn.onclick = installPWA;

            document.body.appendChild(installBtn);

            // Animação de entrada
            setTimeout(() => installBtn.classList.add('visible'), 100);
        }

        // Instala o PWA
        async function installPWA() {
            if (!deferredInstallPrompt) return;

            deferredInstallPrompt.prompt();
            const { outcome } = await deferredInstallPrompt.userChoice;

            if (outcome === 'accepted') {
                console.log('✅ PWA instalado');
                hideInstallButton();
            }

            deferredInstallPrompt = null;
        }

        // Esconde botão após instalação
        function hideInstallButton() {
            const btn = document.getElementById('pwaInstallBtn');
            if (btn) {
                btn.classList.remove('visible');
                setTimeout(() => btn.remove(), 300);
            }
        }

        // Detecta se já está instalado
        window.addEventListener('appinstalled', () => {
            hideInstallButton();
            deferredInstallPrompt = null;
            console.log('✅ App instalado com sucesso');
        });

        // Notificação de atualização disponível
        function showUpdateNotification() {
            const notification = document.createElement('div');
            notification.className = 'pwa-update-notification';
            notification.innerHTML = `
                <div class="pwa-update-content">
                    <span>🔄 Nova versão disponível!</span>
                    <button onclick="location.reload()">Atualizar</button>
                    <button onclick="this.parentElement.parentElement.remove()">✕</button>
                </div>
            `;
            document.body.appendChild(notification);
            setTimeout(() => notification.classList.add('visible'), 100);
        }

        // Inicia Service Worker quando DOM estiver pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', registerServiceWorker);
        } else {
            registerServiceWorker();
        }

    </script>
</body>
</html>